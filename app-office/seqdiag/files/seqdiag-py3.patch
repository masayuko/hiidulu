diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/drawer.py
--- a/src/seqdiag/drawer.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/drawer.py	Fri Sep 20 09:02:47 2013 +0900
@@ -24,7 +24,7 @@
 
     def _draw_background(self):
         for node in self.nodes:
-            node.activities.sort(lambda x, y: cmp(x['level'], y['level']))
+            node.activities.sort(key=lambda x: x['level'])
 
         if self.diagram.shadow_style != 'none':
             for node in self.nodes:
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/metrics.py
--- a/src/seqdiag/metrics.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/metrics.py	Fri Sep 20 09:02:47 2013 +0900
@@ -13,6 +13,7 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
+from __future__ import division
 import sys
 from seqdiag import elements
 import blockdiag.metrics
@@ -49,7 +50,7 @@
 
             height = self.edge_height + edge.textheight
             if edge.diagonal:
-                height += self.node_height * 3 / 4
+                height += self.node_height * 3 // 4
             elif edge.direction == 'self':
                 height += self.cellsize * 2
 
@@ -97,7 +98,7 @@
             if blocks:
                 max_ylevel_top = max(b.ylevel_top for b in blocks)
                 span_height = (self.spreadsheet.span_height[y + 1] +
-                               self.cellsize * 5 / 2 * (max_ylevel_top - 1) +
+                               self.cellsize * 5 // 2 * (max_ylevel_top - 1) +
                                self.cellsize)
                 self.spreadsheet.set_span_height(y + 1, span_height)
 
@@ -105,7 +106,7 @@
             if blocks:
                 max_ylevel_bottom = max(b.ylevel_bottom for b in blocks)
                 span_height = (self.spreadsheet.span_height[y + 2] +
-                               self.cellsize / 2 * (max_ylevel_bottom - 1))
+                               self.cellsize // 2 * (max_ylevel_bottom - 1))
 
                 self.spreadsheet.set_span_height(y + 2, span_height)
 
@@ -120,7 +121,7 @@
         dummy = elements.DiagramNode(None)
         dummy.xy = XY(1, height)
         _, y = self.spreadsheet._node_bottomright(dummy, use_padding=False)
-        y += self.spreadsheet.span_height[len(self.edges) + 1] / 2
+        y += self.spreadsheet.span_height[len(self.edges) + 1] // 2
         return y
 
     @property
@@ -159,7 +160,7 @@
         y1 = self.edge(edge).baseheight
         if isinstance(edge, elements.DiagramEdge):
             if edge.diagonal and edge.node2 == node:
-                y1 += self.edge_height * 3 / 4
+                y1 += self.edge_height * 3 // 4
 
         # y coodinates for bottom of activity box
         ends = activity['lifetime'][-1] + 1
@@ -170,8 +171,8 @@
 
         index = activity['level']
         base_x = self.cell(node).bottom.x
-        box = Box(base_x + (index - 1) * self.cellsize / 2, y1,
-                  base_x + (index + 1) * self.cellsize / 2, y2)
+        box = Box(base_x + (index - 1) * self.cellsize // 2, y1,
+                  base_x + (index + 1) * self.cellsize // 2, y2)
 
         return box
 
@@ -251,10 +252,10 @@
         cellsize = metrics.cellsize
 
         box = node.box
-        box[0] -= (sheet.span_width[block.xy.x + 1] / 2 -
+        box[0] -= (sheet.span_width[block.xy.x + 1] // 2 -
                    cellsize * (block.xlevel - 1))
-        box[1] -= cellsize * 5 / 2 * (block.ylevel_top - 1) + cellsize * 3
-        box[2] += (sheet.span_width[block.xy.x + block.colwidth + 2] / 2 -
+        box[1] -= cellsize * 5 // 2 * (block.ylevel_top - 1) + cellsize * 3
+        box[2] += (sheet.span_width[block.xy.x + block.colwidth + 2] // 2 -
                    cellsize * (block.xlevel - 1))
         box[3] += cellsize * (block.ylevel_bottom - 1) + cellsize
 
@@ -290,17 +291,17 @@
         if self.edge.direction == 'self':
 
             if self.edge.node1.xy.x + 1 == m.node_count:
-                width = cell.width / 2 + m.cellsize * 3
+                width = cell.width // 2 + m.cellsize * 3
             else:
                 span_width = m.spreadsheet.span_width[self.edge.node1.xy.x]
-                width = cell.width / 2 + span_width / 2
+                width = cell.width // 2 + span_width // 2
 
             x = cell.bottom.x + width
         else:
             x = cell.bottom.x - m.cellsize
 
             if self.edge.failed:
-                x -= self.metrics.edge_length / 2
+                x -= self.metrics.edge_length // 2
 
         return x
 
@@ -329,7 +330,7 @@
 
             margin = m.cellsize
             if self.edge.diagonal:
-                height = m.node_height * 3 / 4
+                height = m.node_height * 3 // 4
                 if self.edge.direction == 'right':
                     line = [XY(x1 + margin, baseheight),
                             XY(x2 - margin, baseheight + height)]
@@ -344,9 +345,9 @@
                 edge_length = self.metrics.edge_length
                 pt1, pt2 = line
                 if self.edge.direction == 'right':
-                    pt2 = XY(pt2.x - edge_length / 2, (pt1.y + pt2.y) / 2)
+                    pt2 = XY(pt2.x - edge_length // 2, (pt1.y + pt2.y) // 2)
                 else:
-                    pt1 = XY(pt1.x + edge_length / 2, (pt1.y + pt2.y) / 2)
+                    pt1 = XY(pt1.x + edge_length // 2, (pt1.y + pt2.y) // 2)
                 line = [pt1, pt2]
 
         return line
@@ -378,19 +379,19 @@
         head = []
         if self.edge.direction == 'right':
             xy = self.shaft[-1]
-            head.append(XY(xy.x - cell, xy.y - cell / 2))
+            head.append(XY(xy.x - cell, xy.y - cell // 2))
             head.append(xy)
-            head.append(XY(xy.x - cell, xy.y + cell / 2))
+            head.append(XY(xy.x - cell, xy.y + cell // 2))
         elif self.edge.direction == 'left':
             xy = self.shaft[0]
-            head.append(XY(xy.x + cell, xy.y - cell / 2))
+            head.append(XY(xy.x + cell, xy.y - cell // 2))
             head.append(xy)
-            head.append(XY(xy.x + cell, xy.y + cell / 2))
+            head.append(XY(xy.x + cell, xy.y + cell // 2))
         else:  # self
             xy = self.shaft[-1]
-            head.append(XY(xy.x + cell, xy.y - cell / 2))
+            head.append(XY(xy.x + cell, xy.y - cell // 2))
             head.append(xy)
-            head.append(XY(xy.x + cell, xy.y + cell / 2))
+            head.append(XY(xy.x + cell, xy.y + cell // 2))
 
         return head
 
@@ -404,7 +405,7 @@
         elif self.edge.direction == 'right':
             x = m.node(self.edge.left_node).bottom.x + \
                 self.activity_line_width(self.edge.left_node) + \
-                self.metrics.cellsize / 2
+                self.metrics.cellsize // 2
         else:  # left
             x = m.node(self.edge.right_node).bottom.x - self.edge.textwidth
 
@@ -421,7 +422,7 @@
         else:
             level = 0
 
-        return m.cellsize / 2 * level
+        return m.cellsize // 2 * level
 
     @property
     def leftnotebox(self):
@@ -433,10 +434,10 @@
         notesize = self.edge.leftnotesize
 
         x = cell.center.x - m.cellsize * 3 - notesize.width
-        y = self.baseheight - notesize.height / 2
+        y = self.baseheight - notesize.height // 2
 
         if self.edge.failed and self.edge.direction == 'left':
-            x += self.metrics.edge_length / 2 - m.cellsize
+            x += self.metrics.edge_length // 2 - m.cellsize
 
         return Box(x, y, x + notesize.width, y + notesize.height)
 
@@ -466,7 +467,7 @@
             x = cell.center.x + m.cellsize * 2
 
         notesize = self.edge.rightnotesize
-        y = self.baseheight - notesize.height / 2
+        y = self.baseheight - notesize.height // 2
         return Box(x, y, x + notesize.width, y + notesize.height)
 
     @property
@@ -489,12 +490,12 @@
         x1, x2 = self.baseline
         y1 = self.baseheight
         y2 = y1 + self.metrics.node_height
-        d = self.metrics.cellsize / 4
+        d = self.metrics.cellsize // 4
 
         font = metrics.font_for(self)
         size = metrics.textsize(separator.label, font, x2 - x1)
-        dx = (x2 - x1 - size.width) / 2
-        dy = (y2 - y1 - size.height) / 2
+        dx = (x2 - x1 - size.width) // 2
+        dy = (y2 - y1 - size.height) // 2
         self.labelbox = Box(x1 + dx - d,
                             y1 + dy - d,
                             x1 + dx + size.width + d,
@@ -517,9 +518,9 @@
     def lines(self):
         lines = []
         if self.separator.type == 'divider':
-            y = (self.labelbox[1] + self.labelbox[3]) / 2
+            y = (self.labelbox[1] + self.labelbox[3]) // 2
             x1, x2 = self.baseline
-            d = self.metrics.cellsize / 4
+            d = self.metrics.cellsize // 4
 
             lines.append((XY(x1, y - d), XY(self.labelbox[0], y - d)))
             lines.append((XY(x1, y + d), XY(self.labelbox[0], y + d)))
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/parser.py
--- a/src/seqdiag/parser.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/parser.py	Fri Sep 20 09:02:47 2013 +0900
@@ -35,7 +35,7 @@
   [1]: http://www.graphviz.org/doc/info/lang.html
 '''
 
-import codecs
+import io
 from re import MULTILINE, DOTALL
 from funcparserlib.lexer import make_tokenizer, Token, LexerError
 from funcparserlib.parser import (some, a, maybe, many, finished, skip,
@@ -61,15 +61,15 @@
 
 
 def tokenize(string):
-    'str -> Sequence(Token)'
+    """str -> Sequence(Token)"""
     specs = [
         ('Comment', (r'/\*(.|[\r\n])*?\*/', MULTILINE)),
         ('Comment', (r'(//|#).*',)),
         ('NL',      (r'[\r\n]+',)),
         ('Space',   (r'[ \t\r\n]+',)),
         ('Separator', (r'(?P<sep>===|\.\.\.)[^\r\n]+(?P=sep)',)),
-        ('Name',    (ur'[A-Za-z_0-9\u0080-\uffff]'
-                     ur'[A-Za-z_\-.0-9\u0080-\uffff]*',)),
+        ('Name',    (u'[A-Za-z_0-9\u0080-\uffff]'
+                     u'[A-Za-z_\\-.0-9\u0080-\uffff]*',)),
         ('Op',      (r'(=>)|[{};,=\[\]]|(<<?--?)|(--?>>?)',)),
         ('Number',  (r'-?(\.[0-9]+)|([0-9]+(\.[0-9]*)?)',)),
         ('String',  (r'(?P<quote>"|\').*?(?<!\\)(?P=quote)', DOTALL)),
@@ -80,7 +80,7 @@
 
 
 def parse(seq):
-    'Sequence(Token) -> object'
+    """Sequence(Token) -> object"""
     unarg = lambda f: lambda args: f(*args)
     tokval = lambda x: x.value
     flatten = lambda list: sum(list, [])
@@ -226,11 +226,8 @@
         else:
             return 2
 
-    def compare(node1, node2):
-        return cmp(weight(node1), weight(node2))
-
     if hasattr(tree, 'stmts'):
-        tree.stmts.sort(compare)
+        tree.stmts.sort(key=lambda x: weight(x))
         for stmt in tree.stmts:
             sort_tree(stmt)
 
@@ -241,13 +238,13 @@
     try:
         tree = parse(tokenize(string))
         return sort_tree(tree)
-    except LexerError, e:
+    except LexerError as e:
         message = "Got unexpected token at line %d column %d" % e.place
         raise ParseException(message)
-    except Exception, e:
+    except Exception as e:
         raise ParseException(str(e))
 
 
 def parse_file(path):
-    code = codecs.open(path, 'r', 'utf-8').read()
+    code = io.open(path, 'r', encoding='utf-8-sig').read()
     return parse_string(code)
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/tests/test_pep8.py
--- a/src/seqdiag/tests/test_pep8.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/tests/test_pep8.py	Fri Sep 20 09:02:47 2013 +0900
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from __future__ import print_function
 import os
 import sys
 import pep8
@@ -48,5 +49,5 @@
     errors = report.get_count('E')
     warnings = report.get_count('W')
     message = 'pep8: %d errors / %d warnings' % (errors, warnings)
-    print message
+    print(message)
     assert report.total_errors == 0, message
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/tests/test_rst_directives.py
--- a/src/seqdiag/tests/test_rst_directives.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/tests/test_rst_directives.py	Fri Sep 20 09:02:47 2013 +0900
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 
 import os
+import io
 import tempfile
 import unittest2
 from blockdiag.tests.utils import stderr_wrapper, assertRaises
@@ -106,7 +107,7 @@
 
         self.assertEqual(1, len(doctree))
         self.assertEqual(directives.seqdiag, type(doctree[0]))
-        self.assertEqual(open(filename).read(), doctree[0]['code'])
+        self.assertEqual(io.open(filename).read(), doctree[0]['code'])
         self.assertEqual(None, doctree[0]['alt'])
         self.assertEqual({}, doctree[0]['options'])
 
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/tests/utils.py
--- a/src/seqdiag/tests/utils.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/tests/utils.py	Fri Sep 20 09:02:47 2013 +0900
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+from __future__ import print_function
 import re
 import sys
 from StringIO import StringIO
@@ -26,12 +27,12 @@
             stderr = sys.stderr
             sys.stderr = StringIO()
 
-            print args, kwargs
+            print(args, kwargs)
             func(*args, **kwargs)
         finally:
             if sys.stderr.getvalue():
-                print "---[ stderr ] ---"
-                print sys.stderr.getvalue()
+                print("---[ stderr ] ---")
+                print(sys.stderr.getvalue())
 
             sys.stderr = stderr
 
@@ -54,13 +55,13 @@
 
     for name, values in kwargs.items():
         if re.match('edge_', name):
-            print "[%s]" % name
+            print("[%s]" % name)
             name = re.sub('edge_', '', name)
             for (id1, id2), value in values.items():
                 found = False
                 for edge in diagram.edges:
                     if edge.node1.id == id1 and edge.node2.id == id2:
-                        print edge
+                        print(edge)
                         eq_(value, getattr(edge, name))
                         found = True
 
@@ -68,8 +69,8 @@
                     raise RuntimeError('edge (%s -> %s) is not found' %
                                        (id1, id2))
         else:
-            print "[node.%s]" % name
+            print("[node.%s]" % name)
             for node in (n for n in diagram.nodes if n.drawable):
-                print node
+                print(node)
                 value = getattr(node, name)
                 eq_(values[node.id], value)
diff -r f00cd35d59db -r e62f7e02ed4c src/seqdiag/utils/rst/directives.py
--- a/src/seqdiag/utils/rst/directives.py	Mon Feb 11 12:46:17 2013 +0900
+++ b/src/seqdiag/utils/rst/directives.py	Fri Sep 20 09:02:47 2013 +0900
@@ -76,7 +76,7 @@
                     new_size = (options['maxwidth'], int(size[1] * ratio))
                     content = drawer.save(new_size)
 
-                return nodes.raw('', content.decode('utf-8'), format='html')
+                return nodes.raw('', content, format='html')
 
         size = drawer.pagesize()
         if 'maxwidth' in options and options['maxwidth'] < size[0]:
