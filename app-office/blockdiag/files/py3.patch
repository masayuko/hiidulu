diff -r 8c51cce1e9ea src/blockdiag/builder.py
--- a/src/blockdiag/builder.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/builder.py	Mon Sep 02 04:13:45 2013 +0900
@@ -16,7 +16,7 @@
 from blockdiag import parser
 from blockdiag.elements import Diagram, DiagramNode, NodeGroup, DiagramEdge
 from blockdiag.utils import unquote, XY
-
+from functools import cmp_to_key
 
 class DiagramTreeBuilder:
     def build(self, tree):
@@ -201,7 +201,7 @@
             else:
                 related.append(uniq_node)
 
-        related.sort(lambda x, y: cmp(x.order, y.order))
+        related.sort(key=lambda x: x.order)
         return related
 
     def get_parent_nodes(self, node):
@@ -250,9 +250,7 @@
                         if not parent in circular:
                             parents.append(parent)
 
-                parents.sort(lambda x, y: cmp(x.order, y.order))
-
-                for parent in parents:
+                for parent in sorted(parents, key=lambda x: x.order):
                     children = self.get_child_nodes(parent)
                     if node1 in children and node2 in children:
                         if circular.index(node1) > circular.index(node2):
@@ -364,11 +362,11 @@
                 x.node1 = x.node1.group
                 y.node1 = y.node1.group
 
-            return cmp(x.node1.order, y.node1.order)
+            return -1 if x.node1.order < y.node1.order else ( 0 if x.node1.order == y.node1.order else 1)
 
         edges = (DiagramEdge.find(parent, node1) +
                  DiagramEdge.find(parent, node2))
-        edges.sort(compare)
+        edges.sort(key=cmp_to_key(compare))
         if len(edges) == 0:
             return 0
         elif edges[0].node2 == node2:
@@ -392,7 +390,7 @@
 
         count = 0
         children = self.get_child_nodes(node)
-        children.sort(lambda x, y: cmp(x.xy.x, y.xy.y))
+        children.sort(key=cmp_to_key(lambda x, y: -1 if x.xy.x < y.xy.y else ( 0 if x.xy.x == y.xy.y else 1)))
 
         grandchild = 0
         for child in children:
@@ -710,9 +708,9 @@
 
             # pick up nodes to base diagram
             nodes1 = [e.node1 for e in DiagramEdge.find(None, group)]
-            nodes1.sort(lambda x, y: cmp(x.order, y.order))
+            nodes1.sort(key=lambda x: x.order)
             nodes2 = [e.node2 for e in DiagramEdge.find(group, None)]
-            nodes2.sort(lambda x, y: cmp(x.order, y.order))
+            nodes2.sort(key=lambda x: x.order)
 
             nodes = nodes1 + [group] + nodes2
             for i, n in enumerate(nodes):
diff -r 8c51cce1e9ea src/blockdiag/imagedraw/png.py
--- a/src/blockdiag/imagedraw/png.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/imagedraw/png.py	Mon Sep 02 04:13:45 2013 +0900
@@ -15,7 +15,11 @@
 
 import re
 import math
-from itertools import izip, tee
+from itertools import tee
+try:
+    from future_builtins import zip
+except ImportError:
+    pass
 from functools import partial, wraps
 from blockdiag.imagedraw import base
 from blockdiag.imagedraw.utils import cached, ellipse
@@ -48,7 +52,7 @@
 def line_segments(xylist):
     p1, p2 = tee(point_pairs(xylist))
     p2.next()
-    return izip(p1, p2)
+    return zip(p1, p2)
 
 
 def dashize_line(line, length):
@@ -356,10 +360,13 @@
 
     def image(self, box, url):
         if urlutil.isurl(url):
-            import cStringIO
+            try:
+                from io import StringIO
+            except ImportError:
+                from cStringIO import StringIO
             import urllib
             try:
-                url = cStringIO.StringIO(urllib.urlopen(url).read())
+                url = StringIO(urllib.urlopen(url).read())
             except:
                 import sys
                 msg = "WARNING: Could not retrieve: %s\n" % url
@@ -401,8 +408,11 @@
             self._image.save(self.filename, _format)
             image = None
         else:
-            import cStringIO
-            tmp = cStringIO.StringIO()
+            try:
+                from io import StringIO
+            except ImportError:
+                from cStringIO import StringIO
+            tmp = StringIO()
             self._image.save(tmp, _format)
             image = tmp.getvalue()
 
diff -r 8c51cce1e9ea src/blockdiag/imagedraw/simplesvg.py
--- a/src/blockdiag/imagedraw/simplesvg.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/imagedraw/simplesvg.py	Mon Sep 02 04:13:45 2013 +0900
@@ -14,11 +14,20 @@
 #  limitations under the License.
 
 import re
-import cStringIO
+try:
+    from io import StringIO
+except ImportError:
+    from cStringIO import StringIO
+
+import sys
+if sys.version_info[0] == 2:
+    string_types = (str, unicode)
+else:
+    string_types = (str,)
 
 
 def _escape(s):
-    if not isinstance(s, (str, unicode)):
+    if not isinstance(s, string_types):
         s = str(s)
     return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
 
@@ -53,28 +62,26 @@
         clsname = self.__class__.__name__
         indent = '  ' * level
 
-        io.write('%s<%s' % (indent, clsname))
+        io.write(u'%s<%s' % (indent, clsname))
         for key in sorted(self.attributes):
             value = self.attributes[key]
             if value is not None:
-                io.write(' %s=%s' % (_escape(key), _quote(value)))
+                io.write(u' %s=%s' % (_escape(key), _quote(value)))
 
         if self.elements == []:
             if self.text is not None:
-                text = _escape(self.text).encode('utf-8')
-                io.write(">%s</%s>\n" % (text, clsname))
+                io.write(u">%s</%s>\n" % (_escape(self.text), clsname))
             else:
-                io.write(" />\n")
+                io.write(u" />\n")
         elif self.elements:
             if self.text is not None:
-                text = _escape(self.text).encode('utf-8')
-                io.write(">%s\n" % (text,))
+                io.write(u">%s\n" % (_escape(self.text),))
             else:
-                io.write(">\n")
+                io.write(u">\n")
 
             for e in self.elements:
                 e.to_xml(io, level + 1)
-            io.write('%s</%s>\n' % (indent, clsname))
+            io.write(u'%s</%s>\n' % (indent, clsname))
 
 
 class element(base):
@@ -100,13 +107,13 @@
         self.add_attribute('xmlns', 'http://www.w3.org/2000/svg')
 
     def to_xml(self):
-        io = cStringIO.StringIO()
+        io = StringIO()
 
         if not self.nodoctype:
             url = "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"
-            io.write("<?xml version='1.0' encoding='UTF-8'?>\n")
-            io.write('<!DOCTYPE svg PUBLIC '
-                     '"-//W3C//DTD SVG 1.0//EN" "%s">\n' % url)
+            io.write(u"<?xml version='1.0' encoding='UTF-8'?>\n")
+            io.write(u'<!DOCTYPE svg PUBLIC '
+                     u'"-//W3C//DTD SVG 1.0//EN" "%s">\n' % url)
 
         super(svg, self).to_xml(io)
 
diff -r 8c51cce1e9ea src/blockdiag/imagedraw/svg.py
--- a/src/blockdiag/imagedraw/svg.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/imagedraw/svg.py	Mon Sep 02 04:13:45 2013 +0900
@@ -292,7 +292,7 @@
         image = self.svg.to_xml()
 
         if self.filename:
-            open(self.filename, 'w').write(image)
+            open(self.filename, 'wb').write(image.encode('utf-8'))
 
         return image
 
diff -r 8c51cce1e9ea src/blockdiag/imagedraw/textfolder.py
--- a/src/blockdiag/imagedraw/textfolder.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/imagedraw/textfolder.py	Mon Sep 02 04:13:45 2013 +0900
@@ -16,6 +16,12 @@
 import re
 from blockdiag.utils import Box, Size, XY
 
+import sys
+if sys.version_info[0] == 2:
+    string_types = (str, unicode)
+else:
+    string_types = (str,)
+
 
 def splitlabel(string):
     """Split text to lines as generator.
@@ -84,7 +90,7 @@
         self._result = self._lines()
 
     def textsize(self, text, scaled=False):
-        if isinstance(text, (str, unicode)):
+        if isinstance(text, string_types):
             size = [self.drawer.textlinesize(c, self.font) for c in text]
             width = max(s.width for s in size)
             height = (sum(s.height for s in size) +
@@ -206,7 +212,7 @@
         self._result = self._lines()
 
     def textsize(self, text, scaled=False):
-        if isinstance(text, (str, unicode)):
+        if isinstance(text, string_types):
             textsize = self.drawer.textlinesize(text, self.font)
         else:
             if text:
diff -r 8c51cce1e9ea src/blockdiag/metrics.py
--- a/src/blockdiag/metrics.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/metrics.py	Mon Sep 02 04:13:45 2013 +0900
@@ -293,12 +293,12 @@
 
         if use_padding:
             width = node.width or self.metrics.node_width
-            xdiff = (self.node_width[x] - width) / 2
+            xdiff = int((self.node_width[x] - width) / 2)
             if xdiff < 0:
                 xdiff = 0
 
             height = node.height or self.metrics.node_height
-            ydiff = (self.node_height[y] - height) / 2
+            ydiff = int((self.node_height[y] - height) / 2)
             if ydiff < 0:
                 ydiff = 0
         else:
@@ -323,12 +323,12 @@
 
         if use_padding:
             width = node.width or self.metrics.node_width
-            xdiff = (self.node_width[x] - width) / 2
+            xdiff = int((self.node_width[x] - width) / 2)
             if xdiff < 0:
                 xdiff = 0
 
             height = node.height or self.metrics.node_height
-            ydiff = (self.node_height[y] - height) / 2
+            ydiff = int((self.node_height[y] - height) / 2)
             if ydiff < 0:
                 ydiff = 0
         else:
@@ -373,10 +373,10 @@
 
     @property
     def marginbox(self):
-        return Box(self._box.x1 - self.span_width / 8,
-                   self._box.y1 - self.span_height / 4,
-                   self._box.x2 + self.span_width / 8,
-                   self._box.y2 + self.span_height / 4)
+        return Box(self._box.x1 - int(self.span_width / 8),
+                   self._box.y1 - int(self.span_height / 4),
+                   self._box.x2 + int(self.span_width / 8),
+                   self._box.y2 + int(self.span_height / 4))
 
     @property
     def corebox(self):
@@ -387,7 +387,7 @@
 
     @property
     def grouplabelbox(self):
-        return Box(self._box.x1, self._box.y1 - self.span_height / 2,
+        return Box(self._box.x1, self._box.y1 - int(self.span_height / 2),
                    self._box.x2, self._box.y1)
 
 
@@ -425,30 +425,30 @@
         if direct == 'up':
             xy = node.bottom
             head.append(XY(xy.x, xy.y + 1))
-            head.append(XY(xy.x - cell / 2, xy.y + cell))
+            head.append(XY(xy.x - int(cell / 2), xy.y + cell))
             head.append(XY(xy.x, xy.y + cell * 2))
-            head.append(XY(xy.x + cell / 2, xy.y + cell))
+            head.append(XY(xy.x + int(cell / 2), xy.y + cell))
             head.append(XY(xy.x, xy.y + 1))
         elif direct == 'down':
             xy = node.top
             head.append(XY(xy.x, xy.y - 1))
-            head.append(XY(xy.x - cell / 2, xy.y - cell))
+            head.append(XY(xy.x - int(cell / 2), xy.y - cell))
             head.append(XY(xy.x, xy.y - cell * 2))
-            head.append(XY(xy.x + cell / 2, xy.y - cell))
+            head.append(XY(xy.x + int(cell / 2), xy.y - cell))
             head.append(XY(xy.x, xy.y - 1))
         elif direct == 'right':
             xy = node.left
             head.append(XY(xy.x - 1, xy.y))
-            head.append(XY(xy.x - cell, xy.y - cell / 2))
+            head.append(XY(xy.x - cell, xy.y - int(cell / 2)))
             head.append(XY(xy.x - cell * 2, xy.y))
-            head.append(XY(xy.x - cell, xy.y + cell / 2))
+            head.append(XY(xy.x - cell, xy.y + int(cell / 2)))
             head.append(XY(xy.x - 1, xy.y))
         elif direct == 'left':
             xy = node.right
             head.append(XY(xy.x + 1, xy.y))
-            head.append(XY(xy.x + cell, xy.y - cell / 2))
+            head.append(XY(xy.x + cell, xy.y - int(cell / 2)))
             head.append(XY(xy.x + cell * 2, xy.y))
-            head.append(XY(xy.x + cell, xy.y + cell / 2))
+            head.append(XY(xy.x + cell, xy.y + int(cell / 2)))
             head.append(XY(xy.x + 1, xy.y))
         elif direct == 'rup':
             xy = node.bottom
@@ -591,12 +591,12 @@
             shaft.moveTo(node1.right)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.right.x + span.x / 2, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell1.bottomright.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4,
-                             cell2.bottomright.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4, cell2.left.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell1.bottomright.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4),
+                             cell2.bottomright.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell2.left.y)
 
             shaft.lineTo(node2.left)
 
@@ -604,40 +604,40 @@
             shaft.moveTo(node1.right)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.right.x + span.x / 2, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell2.bottomleft.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4,
-                             cell2.bottomleft.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4, cell2.left.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell2.bottomleft.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4),
+                             cell2.bottomleft.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell2.left.y)
             else:
-                shaft.lineTo(cell2.left.x - span.x / 4, cell1.right.y)
-                shaft.lineTo(cell2.left.x - span.x / 4, cell2.left.y)
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell1.right.y)
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell2.left.y)
 
             shaft.lineTo(node2.left)
 
         elif _dir == 'right-down':
             shaft.moveTo(node1.right)
-            shaft.lineTo(cell1.right.x + span.x / 2, cell1.right.y)
+            shaft.lineTo(cell1.right.x + int(span.x / 2), cell1.right.y)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell2.topleft.y - span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4,
-                             cell2.topleft.y - span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4, cell2.left.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell2.topleft.y - int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4),
+                             cell2.topleft.y - int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell2.left.y)
             else:
-                shaft.lineTo(cell1.right.x + span.x / 2, cell2.left.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2), cell2.left.y)
 
             shaft.lineTo(node2.left)
 
         elif _dir == 'up':
             if self.edge.skipped:
                 shaft.moveTo(node1.right)
-                shaft.lineTo(cell1.right.x + span.x / 4, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x / 4,
-                             cell2.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.bottom.x, cell2.bottom.y + span.y / 2)
+                shaft.lineTo(cell1.right.x + int(span.x / 4), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 4),
+                             cell2.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.bottom.x, cell2.bottom.y + int(span.y / 2))
             else:
                 shaft.moveTo(node1.top)
 
@@ -645,36 +645,36 @@
 
         elif _dir in ('left-up', 'left', 'same'):
             shaft.moveTo(node1.right)
-            shaft.lineTo(cell1.right.x + span.x / 4, cell1.right.y)
-            shaft.lineTo(cell1.right.x + span.x / 4,
-                         cell2.top.y - span.y / 2 + span.y / 8)
+            shaft.lineTo(cell1.right.x + int(span.x / 4), cell1.right.y)
+            shaft.lineTo(cell1.right.x + int(span.x / 4),
+                         cell2.top.y - int(span.y / 2 + span.y / 8))
             shaft.lineTo(cell2.top.x,
-                         cell2.top.y - span.y / 2 + span.y / 8)
+                         cell2.top.y - int(span.y / 2 + span.y / 8))
             shaft.lineTo(node2.top)
 
         elif _dir == 'left-down':
             if self.edge.skipped:
                 shaft.moveTo(node1.right)
-                shaft.lineTo(cell1.right.x + span.x / 2, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell2.top.y - span.y / 2)
-                shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+                shaft.lineTo(cell1.right.x + int(span.x / 2), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell2.top.y - int(span.y / 2))
+                shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
             else:
                 shaft.moveTo(node1.bottom)
                 shaft.lineTo(cell1.bottom.x,
-                             cell2.top.y - span.y / 2)
-                shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+                             cell2.top.y - int(span.y / 2))
+                shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
 
             shaft.lineTo(node2.top)
 
         elif _dir == 'down':
             if self.edge.skipped:
                 shaft.moveTo(node1.right)
-                shaft.lineTo(cell1.right.x + span.x / 2, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell2.top.y - span.y / 2 + span.y / 8)
+                shaft.lineTo(cell1.right.x + int(span.x / 2), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell2.top.y - int(span.y / 2 + span.y / 8))
                 shaft.lineTo(cell2.top.x,
-                             cell2.top.y - span.y / 2 + span.y / 8)
+                             cell2.top.y - int(span.y / 2 + span.y / 8))
             else:
                 shaft.moveTo(node1.bottom)
 
@@ -696,40 +696,40 @@
                 box = Box(node1.bottomright.x + span.x,
                           node1.bottomright.y,
                           node2.bottomleft.x - span.x,
-                          node2.bottomleft.y + span.y / 2)
+                          node2.bottomleft.y + int(span.y / 2))
             else:
-                box = Box(node1.topright.x, node1.topright.y - span.y / 8,
-                          node2.left.x, node2.left.y - span.y / 8)
+                box = Box(node1.topright.x, node1.topright.y - int(span.y / 8),
+                          node2.left.x, node2.left.y - int(span.y / 8))
 
         elif _dir == 'right-up':
-            box = Box(node2.left.x - span.x, node1.top.y - node.y / 2,
+            box = Box(node2.left.x - span.x, node1.top.y - int(node.y / 2),
                       node2.bottomleft.x, node1.top.y)
 
         elif _dir == 'right-down':
-            box = Box(node1.right.x, node2.topleft.y - span.y / 8,
-                      node1.right.x + span.x, node2.left.y - span.y / 8)
+            box = Box(node1.right.x, node2.topleft.y - int(span.y / 8),
+                      node1.right.x + span.x, node2.left.y - int(span.y / 8))
 
         elif _dir in ('up', 'left-up', 'left', 'same'):
             if self.edge.node2.xy.y < self.edge.node1.xy.y:
-                box = Box(node1.topright.x - span.x / 2 + span.x / 4,
+                box = Box(node1.topright.x - span.x / 2 + int(span.x / 4),
                           node1.topright.y - span.y / 2,
-                          node1.topright.x + span.x / 2 + span.x / 4,
+                          node1.topright.x + span.x / 2 + int(span.x / 4),
                           node1.topright.y)
             else:
-                box = Box(node1.top.x + span.x / 4,
+                box = Box(node1.top.x + int(span.x / 4),
                           node1.top.y - span.y,
-                          node1.topright.x + span.x / 4,
-                          node1.topright.y - span.y / 2)
+                          node1.topright.x + int(span.x / 4),
+                          node1.topright.y - int(span.y / 2))
 
         elif _dir in ('left-down', 'down'):
-            box = Box(node2.top.x + span.x / 4,
+            box = Box(node2.top.x + int(span.x / 4),
                       node2.top.y - span.y,
-                      node2.topright.x + span.x / 4,
-                      node2.topright.y - span.y / 2)
+                      node2.topright.x + int(span.x / 4),
+                      node2.topright.y - int(span.y / 2))
 
         # shrink box
-        box = Box(box[0] + span.x / 8, box[1],
-                  box[2] - span.x / 8, box[3])
+        box = Box(box[0] + int(span.x / 8), box[1],
+                  box[2] - int(span.x / 8), box[3])
 
         return box
 
@@ -797,64 +797,64 @@
                 shaft.lineTo(node2.left)
             else:
                 shaft.moveTo(node1.bottom)
-                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.right.x + span.x / 4,
-                             cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.right.x + span.x / 4,
-                             cell2.top.y - span.y / 2 + span.y / 8)
+                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.right.x + int(span.x / 4),
+                             cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.right.x + int(span.x / 4),
+                             cell2.top.y - int(span.y / 2 + span.y / 8))
                 shaft.lineTo(cell2.top.x,
-                             cell2.top.y - span.y / 2 + span.y / 8)
+                             cell2.top.y - int(span.y / 2 + span.y / 8))
                 shaft.lineTo(node2.top)
 
         elif _dir == 'right-down':
             shaft.moveTo(node1.bottom)
-            shaft.lineTo(cell1.bottom.x, cell1.bottom.y + span.y / 2)
+            shaft.lineTo(cell1.bottom.x, cell1.bottom.y + int(span.y / 2))
 
             if self.edge.skipped:
-                shaft.lineTo(cell2.left.x - span.x / 2,
-                             cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.topleft.x - span.x / 2,
-                             cell2.topleft.y - span.y / 2)
-                shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+                shaft.lineTo(cell2.left.x - int(span.x / 2),
+                             cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.topleft.x - int(span.x / 2),
+                             cell2.topleft.y - int(span.y / 2))
+                shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
             else:
-                shaft.lineTo(cell2.top.x, cell1.bottom.y + span.y / 2)
+                shaft.lineTo(cell2.top.x, cell1.bottom.y + int(span.y / 2))
 
             shaft.lineTo(node2.top)
 
         elif _dir in ('left-up', 'left', 'same'):
             shaft.moveTo(node1.right)
-            shaft.lineTo(cell1.right.x + span.x / 4, cell1.right.y)
-            shaft.lineTo(cell1.right.x + span.x / 4,
-                         cell2.top.y - span.y / 2 + span.y / 8)
+            shaft.lineTo(cell1.right.x + int(span.x / 4), cell1.right.y)
+            shaft.lineTo(cell1.right.x + int(span.x / 4),
+                         cell2.top.y - int(span.y / 2 + span.y / 8))
             shaft.lineTo(cell2.top.x,
-                         cell2.top.y - span.y / 2 + span.y / 8)
+                         cell2.top.y - int(span.y / 2 + span.y / 8))
             shaft.lineTo(node2.top)
 
         elif _dir == 'left-down':
             shaft.moveTo(node1.bottom)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.right.x + span.x / 2,
-                             cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.right.x + span.x / 2,
-                             cell2.top.y - span.y / 2)
+                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.right.x + int(span.x / 2),
+                             cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.right.x + int(span.x / 2),
+                             cell2.top.y - int(span.y / 2))
             else:
-                shaft.lineTo(cell1.bottom.x, cell2.top.y - span.y / 2)
+                shaft.lineTo(cell1.bottom.x, cell2.top.y - int(span.y / 2))
 
-            shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+            shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
             shaft.lineTo(node2.top)
 
         elif _dir == 'down':
             shaft.moveTo(node1.bottom)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell1.right.x + span.x / 2,
-                             cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.right.x + span.x / 2,
-                             cell2.top.y - span.y / 2)
-                shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell1.right.x + int(span.x / 2),
+                             cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.right.x + int(span.x / 2),
+                             cell2.top.y - int(span.y / 2))
+                shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
 
             shaft.lineTo(node2.top)
 
@@ -873,44 +873,44 @@
                 box = Box(node1.bottomright.x + span.x,
                           node1.bottomright.y,
                           node2.bottomleft.x - span.x,
-                          node2.bottomleft.y + span.y / 2)
+                          node2.bottomleft.y + int(span.y / 2))
             else:
-                box = Box(node1.topright.x, node1.topright.y - span.y / 8,
-                          node2.left.x, node2.left.y - span.y / 8)
+                box = Box(node1.topright.x, node1.topright.y - int(span.y / 8),
+                          node2.left.x, node2.left.y - int(span.y / 8))
 
         elif _dir == 'right-up':
             box = Box(node2.left.x - span.x, node2.left.y,
                       node2.bottomleft.x, node2.bottomleft.y)
 
         elif _dir == 'right-down':
-            box = Box(node2.topleft.x, node2.topleft.y - span.y / 2,
+            box = Box(node2.topleft.x, node2.topleft.y - int(span.y / 2),
                       node2.top.x, node2.top.y)
 
         elif _dir in ('up', 'left-up', 'left', 'same'):
             if self.edge.node2.xy.y < self.edge.node1.xy.y:
-                box = Box(node1.topright.x - span.x / 2 + span.x / 4,
-                          node1.topright.y - span.y / 2,
-                          node1.topright.x + span.x / 2 + span.x / 4,
+                box = Box(node1.topright.x - int(span.x / 2 + span.x / 4),
+                          node1.topright.y - int(span.y / 2),
+                          node1.topright.x + int(span.x / 2 + span.x / 4),
                           node1.topright.y)
             else:
-                box = Box(node1.top.x + span.x / 4,
+                box = Box(node1.top.x + int(span.x / 4),
                           node1.top.y - span.y,
-                          node1.topright.x + span.x / 4,
-                          node1.topright.y - span.y / 2)
+                          node1.topright.x + int(span.x / 4),
+                          node1.topright.y - int(span.y / 2))
 
         elif _dir == 'down':
-            box = Box(node2.top.x + span.x / 4,
-                      node2.top.y - span.y / 2,
-                      node2.topright.x + span.x / 4,
+            box = Box(node2.top.x + int(span.x / 4),
+                      node2.top.y - int(span.y / 2),
+                      node2.topright.x + int(span.x / 4),
                       node2.topright.y)
 
         elif _dir == 'left-down':
             box = Box(node1.bottomleft.x, node1.bottomleft.y,
-                      node1.bottom.x, node1.bottom.y + span.y / 2)
+                      node1.bottom.x, node1.bottom.y + int(span.y / 2))
 
         # shrink box
-        box = Box(box[0] + span.x / 8, box[1],
-                  box[2] - span.x / 8, box[3])
+        box = Box(box[0] + int(span.x / 8), box[1],
+                  box[2] - int(span.x / 8), box[3])
 
         return box
 
@@ -954,10 +954,10 @@
             shaft.moveTo(node1.bottom)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4,
-                             cell1.bottom.y + span.y / 2)
-                shaft.lineTo(cell2.left.x - span.x / 4, cell2.left.y)
+                shaft.lineTo(cell1.bottom.x, cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4),
+                             cell1.bottom.y + int(span.y / 2))
+                shaft.lineTo(cell2.left.x - int(span.x / 4), cell2.left.y)
             else:
                 shaft.lineTo(cell1.bottom.x, cell2.left.y)
 
@@ -978,9 +978,9 @@
             if self.edge.skipped:
                 box = Box(cell1.bottom.x, cell1.bottom.y,
                           cell1.bottomright.x,
-                          cell1.bottomright.y + span.y / 2)
+                          cell1.bottomright.y + int(span.y / 2))
             else:
-                box = Box(cell1.bottom.x, cell2.left.y - span.y / 2,
+                box = Box(cell1.bottom.x, cell2.left.y - int(span.y / 2),
                           cell1.bottom.x, cell2.left.y)
         else:
             box = super(FlowchartLandscapeEdgeMetrics, self).labelbox
@@ -1027,10 +1027,10 @@
             shaft.moveTo(node1.right)
 
             if self.edge.skipped:
-                shaft.lineTo(cell1.right.x + span.x * 3 / 4, cell1.right.y)
-                shaft.lineTo(cell1.right.x + span.x * 3 / 4,
-                             cell2.topleft.y - span.y / 2)
-                shaft.lineTo(cell2.top.x, cell2.top.y - span.y / 2)
+                shaft.lineTo(cell1.right.x + int(span.x * 3 / 4), cell1.right.y)
+                shaft.lineTo(cell1.right.x + int(span.x * 3 / 4),
+                             cell2.topleft.y - int(span.y / 2))
+                shaft.lineTo(cell2.top.x, cell2.top.y - int(span.y / 2))
             else:
                 shaft.lineTo(cell2.top.x, cell1.right.y)
 
@@ -1048,15 +1048,15 @@
         cell2 = self.cell(self.edge.node2, use_padding=False)
 
         if _dir == 'down':
-            box = Box(cell2.topleft.x, cell2.top.y - span.y / 2,
+            box = Box(cell2.topleft.x, cell2.top.y - int(span.y / 2),
                       cell2.top.x, cell2.top.y)
         elif _dir == 'right':
             if self.edge.skipped:
                 box = Box(cell1.bottom.x, cell1.bottom.y,
                           cell1.bottomright.x,
-                          cell1.bottomright.y + span.y / 2)
+                          cell1.bottomright.y + int(span.y / 2))
             else:
-                box = Box(cell1.bottom.x, cell2.left.y - span.y / 2,
+                box = Box(cell1.bottom.x, cell2.left.y - int(span.y / 2),
                           cell1.bottom.x, cell2.left.y)
         else:
             box = super(FlowchartPortraitEdgeMetrics, self).labelbox
diff -r 8c51cce1e9ea src/blockdiag/parser.py
--- a/src/blockdiag/parser.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/parser.py	Mon Sep 02 04:13:45 2013 +0900
@@ -61,14 +61,14 @@
 
 
 def tokenize(string):
-    'str -> Sequence(Token)'
+    """str -> Sequence(Token)"""
     specs = [
         ('Comment', (r'/\*(.|[\r\n])*?\*/', MULTILINE)),
         ('Comment', (r'(//|#).*',)),
         ('NL',      (r'[\r\n]+',)),
         ('Space',   (r'[ \t\r\n]+',)),
-        ('Name',    (ur'[A-Za-z_0-9\u0080-\uffff]'
-                     ur'[A-Za-z_\-.0-9\u0080-\uffff]*',)),
+        ('Name',    (u'[A-Za-z_0-9\u0080-\uffff]'
+                     u'[A-Za-z_\\-.0-9\u0080-\uffff]*',)),
         ('Op',      (r'[{};,=\[\]]|(<->)|(<-)|(--)|(->)|(>-<)|(-<)|(>-)',)),
         ('Number',  (r'-?(\.[0-9]+)|([0-9]+(\.[0-9]*)?)',)),
         ('String',  (r'(?P<quote>"|\').*?(?<!\\)(?P=quote)', DOTALL)),
@@ -79,7 +79,7 @@
 
 
 def parse(seq):
-    'Sequence(Token) -> object'
+    """Sequence(Token) -> object"""
     unarg = lambda f: lambda args: f(*args)
     tokval = lambda x: x.value
     flatten = lambda list: sum(list, [])
@@ -194,11 +194,11 @@
         else:
             return 2
 
-    def compare(a, b):
-        return cmp(weight(a), weight(b))
+    def keyfunction(item):
+        return weight(item)
 
     if hasattr(tree, 'stmts'):
-        tree.stmts.sort(compare)
+        tree.stmts.sort(key=keyfunction)
         for stmt in tree.stmts:
             sort_tree(stmt)
 
@@ -209,10 +209,10 @@
     try:
         tree = parse(tokenize(string))
         return sort_tree(tree)
-    except LexerError, e:
+    except LexerError as e:
         message = "Got unexpected token at line %d column %d" % e.place
         raise ParseException(message)
-    except Exception, e:
+    except Exception as e:
         raise ParseException(str(e))
 
 
diff -r 8c51cce1e9ea src/blockdiag/tests/test_builder_separate.py
--- a/src/blockdiag/tests/test_builder_separate.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/tests/test_builder_separate.py	Mon Sep 02 04:13:45 2013 +0900
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from __future__ import print_function
 from blockdiag.builder import SeparateDiagramBuilder
 from blockdiag.elements import DiagramNode
 from blockdiag.parser import parse_string
@@ -26,7 +27,7 @@
     for i, diagram in enumerate(diagram):
         for node in diagram.traverse_nodes():
             if isinstance(node, DiagramNode):
-                print node, assert_pos[i][node.id]
+                print(node, assert_pos[i][node.id])
                 assert node.xy == assert_pos[i][node.id]
 
 
@@ -43,5 +44,5 @@
     for i, diagram in enumerate(diagram):
         for node in diagram.traverse_nodes():
             if isinstance(node, DiagramNode):
-                print node, assert_pos[i][node.id]
+                print(node, assert_pos[i][node.id])
                 assert node.xy == assert_pos[i][node.id]
diff -r 8c51cce1e9ea src/blockdiag/tests/test_parser.py
--- a/src/blockdiag/tests/test_parser.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/tests/test_parser.py	Mon Sep 02 04:13:45 2013 +0900
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from __future__ import print_function
 from blockdiag.parser import parse_string, ParseException
 from blockdiag.parser import Graph, SubGraph, Statements, Node, Edge
 from nose.tools import raises
@@ -78,7 +79,7 @@
            """
     tree = parse_string(code)
     assert isinstance(tree, Graph)
-    print tree.stmts
+    print(tree.stmts)
     assert len(tree.stmts) == 1
     assert isinstance(tree.stmts[0], Edge)
 
@@ -90,7 +91,7 @@
            """
     tree = parse_string(code)
     assert isinstance(tree, Graph)
-    print tree.stmts
+    print(tree.stmts)
     assert len(tree.stmts) == 2
     assert isinstance(tree.stmts[0], Edge)
     assert isinstance(tree.stmts[1], Edge)
diff -r 8c51cce1e9ea src/blockdiag/tests/test_pep8.py
--- a/src/blockdiag/tests/test_pep8.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/tests/test_pep8.py	Mon Sep 02 04:13:45 2013 +0900
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from __future__ import print_function
 import os
 import sys
 import pep8
@@ -48,5 +49,5 @@
     errors = report.get_count('E')
     warnings = report.get_count('W')
     message = 'pep8: %d errors / %d warnings' % (errors, warnings)
-    print message
+    print(message)
     assert report.total_errors == 0, message
diff -r 8c51cce1e9ea src/blockdiag/tests/test_utils_fontmap.py
--- a/src/blockdiag/tests/test_utils_fontmap.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/tests/test_utils_fontmap.py	Mon Sep 02 04:13:45 2013 +0900
@@ -6,7 +6,10 @@
 import unittest2
 from blockdiag.tests.utils import stderr_wrapper, assertRaises
 
-from cStringIO import StringIO
+try:
+    from io import StringIO
+except ImportError:
+    from cStringIO import StringIO
 from collections import namedtuple
 from blockdiag.utils.fontmap import FontInfo, FontMap
 
diff -r 8c51cce1e9ea src/blockdiag/tests/utils.py
--- a/src/blockdiag/tests/utils.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/tests/utils.py	Mon Sep 02 04:13:45 2013 +0900
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+from __future__ import print_function
 import re
 import sys
 from StringIO import StringIO
@@ -60,12 +61,12 @@
             stderr = sys.stderr
             sys.stderr = StringIO()
 
-            print args, kwargs
+            print(args, kwargs)
             func(*args, **kwargs)
         finally:
             if sys.stderr.getvalue():
-                print "---[ stderr ] ---"
-                print sys.stderr.getvalue()
+                print("---[ stderr ] ---")
+                print(sys.stderr.getvalue())
 
             sys.stderr = stderr
 
@@ -106,13 +107,13 @@
 
     for name, values in kwargs.items():
         if re.match('edge_', name):
-            print "[%s]" % name
+            print("[%s]" % name)
             name = re.sub('edge_', '', name)
             for (id1, id2), value in values.items():
                 found = False
                 for edge in diagram.edges:
                     if edge.node1.id == id1 and edge.node2.id == id2:
-                        print edge
+                        print(edge)
                         eq_(value, getattr(edge, name))
                         found = True
 
@@ -120,8 +121,8 @@
                     raise RuntimeError('edge (%s -> %s) is not found' %
                                        (id1, id2))
         else:
-            print "[node.%s]" % name
+            print("[node.%s]" % name)
             for node in (n for n in diagram.nodes if n.drawable):
-                print node
+                print(node)
                 value = getattr(node, name)
                 eq_(values[node.id], value)
diff -r 8c51cce1e9ea src/blockdiag/utils/__init__.py
--- a/src/blockdiag/utils/__init__.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/__init__.py	Mon Sep 02 04:13:45 2013 +0900
@@ -29,7 +29,10 @@
         return super(XY, cls).__new__(cls, (x, y))
 
     def __getattr__(self, name):
-        return self[self.mapper[name]]
+        try:
+            return self[self.mapper[name]]
+        except KeyError:
+            raise AttributeError(name)
 
     def shift(self, x=0, y=0):
         return self.__class__(self.x + x, self.y + y)
@@ -42,7 +45,10 @@
         super(Box, self).__init__((x1, y1, x2, y2))
 
     def __getattr__(self, name):
-        return self[self.mapper[name]]
+        try:
+            return self[self.mapper[name]]
+        except KeyError:
+            raise AttributeError(name)
 
     def __repr__(self):
         _format = "<%s (%s, %s) %dx%d at 0x%08x>"
diff -r 8c51cce1e9ea src/blockdiag/utils/bootstrap.py
--- a/src/blockdiag/utils/bootstrap.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/bootstrap.py	Mon Sep 02 04:13:45 2013 +0900
@@ -34,14 +34,14 @@
 
             parsed = self.parse_diagram()
             return self.build_diagram(parsed)
-        except SystemExit, e:
+        except SystemExit as e:
             return e
-        except UnicodeEncodeError, e:
+        except UnicodeEncodeError as e:
             msg = "ERROR: UnicodeEncodeError caught " + \
                   "(check your font settings)\n"
             sys.stderr.write(msg)
             return -1
-        except Exception, e:
+        except Exception as e:
             if self.options and self.options.debug:
                 import traceback
                 traceback.print_exc()
diff -r 8c51cce1e9ea src/blockdiag/utils/config.py
--- a/src/blockdiag/utils/config.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/config.py	Mon Sep 02 04:13:45 2013 +0900
@@ -15,7 +15,10 @@
 
 import sys
 import codecs
-from ConfigParser import SafeConfigParser
+try:
+    from configparser import SafeConfigParser
+except ImportError:
+    from ConfigParser import SafeConfigParser
 
 
 class ConfigParser(SafeConfigParser):
diff -r 8c51cce1e9ea src/blockdiag/utils/images.py
--- a/src/blockdiag/utils/images.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/images.py	Mon Sep 02 04:13:45 2013 +0900
@@ -61,10 +61,13 @@
     if filename not in _image_size_cache:
         uri = filename
         if urlutil.isurl(filename):
-            import cStringIO
+            try:
+                from io import StringIO
+            except ImportError:
+                from cStringIO import StringIO
             import urllib
             try:
-                uri = cStringIO.StringIO(urllib.urlopen(filename).read())
+                uri = StringIO(urllib.urlopen(filename).read())
             except:
                 return None
 
diff -r 8c51cce1e9ea src/blockdiag/utils/rst/directives.py
--- a/src/blockdiag/utils/rst/directives.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/rst/directives.py	Mon Sep 02 04:13:45 2013 +0900
@@ -137,7 +137,7 @@
 
         try:
             diagram = self.node2diagram(node)
-        except Exception, e:
+        except Exception as e:
             raise self.warning(e.message)
 
         if 'desctable' in node['options']:
diff -r 8c51cce1e9ea src/blockdiag/utils/urlutil.py
--- a/src/blockdiag/utils/urlutil.py	Sat Jul 06 17:01:45 2013 +0900
+++ b/src/blockdiag/utils/urlutil.py	Mon Sep 02 04:13:45 2013 +0900
@@ -1,7 +1,9 @@
 # -*- coding: utf-8 -*-
 
-import urlparse
-
+try:
+    import urlparse
+except ImportError:
+    import urllib.parse as urlparse
 
 def isurl(url):
     o = urlparse.urlparse(url)
