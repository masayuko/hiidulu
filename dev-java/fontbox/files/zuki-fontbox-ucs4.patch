diff --git a/fontbox/src/main/java/org/apache/fontbox/ttf/CMAPTable.java b/fontbox/src/main/java/org/apache/fontbox/ttf/CMAPTable.java
index 9ace400..3c9287f 100644
--- a/fontbox/src/main/java/org/apache/fontbox/ttf/CMAPTable.java
+++ b/fontbox/src/main/java/org/apache/fontbox/ttf/CMAPTable.java
@@ -75,6 +75,11 @@ public class CMAPTable extends TTFTable
      */
     public static final int ENCODING_JOHAB = 6;
 
+    /**
+     * An encoding constant.
+     */
+    public static final int ENCODING_UCS4 = 10;
+
     private CMAPEncodingEntry[] cmaps;
 
     /**
diff --git a/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubFont.java b/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubFont.java
index a2a9330..42c38b8 100755
--- a/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubFont.java
+++ b/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubFont.java
@@ -63,6 +63,8 @@ public class TTFSubFont
     // A sorted version of this set will comprise the generated glyph IDs
     // for the written truetype font.
     private final SortedSet<Integer> glyphIds;
+
+    private boolean useUCS4;
     
     /**
      * Constructs a subfont based on the given font using the given prefix.
@@ -79,19 +81,37 @@ public class TTFSubFont
         glyphIds = new TreeSet<Integer>();
         
         CMAPEncodingEntry[] cmaps = this.baseTTF.getCMAP().getCmaps();
-        CMAPEncodingEntry unicodeCmap = null;
+        CMAPEncodingEntry unicodeCmap_bmp = null;
+        CMAPEncodingEntry unicodeCmap_ucs4 = null;
         
         for (CMAPEncodingEntry cmap : cmaps) 
         {
             // take first unicode map.
-            if (cmap.getPlatformId() == 0 || (cmap.getPlatformId() == 3 && cmap.getPlatformEncodingId() == 1)) 
+            if ( (cmap.getPlatformId() == 3 && cmap.getPlatformEncodingId() == 10)
+              || (cmap.getPlatformId() == 0 && (cmap.getPlatformEncodingId() == 4
+                                             || cmap.getPlatformEncodingId() == 6)) )
             {
-                unicodeCmap = cmap;
+                unicodeCmap_ucs4 = cmap;
                 break;
             }
+            else if ((cmap.getPlatformId() == 0 && cmap.getPlatformEncodingId() != 4
+                                                && cmap.getPlatformEncodingId() != 6)
+                  || (cmap.getPlatformId() == 3 && cmap.getPlatformEncodingId() == 1)) 
+            {
+                unicodeCmap_bmp = cmap;
+            }
         }
 
-        baseCmap = unicodeCmap;
+        if (unicodeCmap_ucs4 != null)
+        {
+            baseCmap = unicodeCmap_ucs4;
+            useUCS4 = true;
+        }
+        else
+        {
+            baseCmap = unicodeCmap_bmp;
+            useUCS4 = false;
+        }
 
         // add notdef character.
         addCharCode(0);
@@ -812,7 +832,7 @@ public class TTFSubFont
          */
         writeUint16(dos,0);
         writeUint16(dos,1);
-        /*
+       /*
          * UInt16    platformID    Platform identifier
          * UInt16    platformSpecificID    Platform-specific encoding identifier
          * UInt32    offset    Offset of the mapping table
@@ -871,6 +891,130 @@ public class TTFSubFont
         endCode[nseg] = 0xffff;
         idDelta[nseg] = 1;
         ++nseg;
+
+        /*
+         * UInt16    format    Format number is set to 4     
+         * UInt16    length    Length of subtable in bytes     
+         * UInt16    language    Language code for this encoding subtable, or zero if language-independent     
+         * UInt16    segCountX2    2 * segCount     
+         * UInt16    searchRange    2 * (2**FLOOR(log2(segCount)))     
+         * UInt16    entrySelector    log2(searchRange/2)     
+         * UInt16    rangeShift    (2 * segCount) - searchRange     
+         * UInt16    endCode[segCount]    Ending character code for each segment, last = 0xFFFF.    
+         * UInt16    reservedPad    This value should be zero    
+         * UInt16    startCode[segCount]    Starting character code for each segment    
+         * UInt16    idDelta[segCount]    Delta for all character codes in segment     
+         * UInt16    idRangeOffset[segCount]    Offset in bytes to glyph indexArray, or 0     
+         * UInt16    glyphIndexArray[variable]    Glyph index array
+         */
+        
+        writeUint16(dos,4);
+        writeUint16(dos, 8*2 + nseg * (4*2));
+        writeUint16(dos,0);
+        writeUint16(dos,nseg*2);
+        int nsegHigh = Integer.highestOneBit(nseg);
+        writeUint16(dos,nsegHigh*2);
+        writeUint16(dos,log2i(nsegHigh));
+        writeUint16(dos,2*(nseg-nsegHigh));
+        
+        for (int i=0;i<nseg;++i) 
+        {    
+            writeUint16(dos,endCode[i]);
+        }
+        writeUint16(dos,0);
+        for (int i=0;i<nseg;++i) 
+        {    
+            writeUint16(dos,startCode[i]);
+        }
+        for (int i=0;i<nseg;++i) 
+        {    
+            writeUint16(dos,idDelta[i]);
+        }
+        for (int i=0;i<nseg;++i) 
+        {    
+            writeUint16(dos,0);
+        }
+        LOG.debug("Finished table [cmap].");
+        return bos.toByteArray();
+    }
+
+    private byte[] buildUCS4CmapTable() throws IOException 
+    {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        DataOutputStream dos = new DataOutputStream(bos);
+        LOG.debug("Building table [cmap]...");
+        /*
+         * UInt16    version    Version number (Set to zero)
+         * UInt16    numberSubtables    Number of encoding subtables
+         */
+        writeUint16(dos,0);
+        writeUint16(dos,2);
+       /*
+         * UInt16    platformID    Platform identifier
+         * UInt16    platformSpecificID    Platform-specific encoding identifier
+         * UInt32    offset    Offset of the mapping table
+         */
+        writeUint16(dos,3); // unicode
+        writeUint16(dos,1); // Default Semantics
+        writeUint32(dos, 8 * 2 + 4);
+        // mapping of type 4.
+        Iterator<Entry<Integer, Integer>> it = this.characters.entrySet().iterator();
+        it.next(); // notdef
+        Entry<Integer, Integer> lastChar = it.next();
+        Entry<Integer, Integer> prevChar = lastChar;
+        int lastGid = this.getNewGlyphId(lastChar.getValue());
+
+        int[] startCode = new int[this.characters.size()];
+        int[] endCode = new int[this.characters.size()];
+        int[] idDelta = new int[this.characters.size()];
+        int nseg = 0;
+        while(it.hasNext()) 
+        {
+            Entry<Integer, Integer> curChar = it.next();
+            int curGid = this.getNewGlyphId(curChar.getValue());
+            
+            if (curChar.getKey() != prevChar.getKey()+1 ||
+                    curGid - lastGid != curChar.getKey() - lastChar.getKey()) 
+            {
+                // Don't emit ranges, which map to the undef glyph, the
+                // undef glyph is emitted a the very last segment.
+                if (lastGid != 0) 
+                {
+                    startCode[nseg] = lastChar.getKey();
+                    endCode[nseg] = prevChar.getKey();
+                    idDelta[nseg] = lastGid - lastChar.getKey();
+                    ++nseg;
+                }
+                // shorten ranges which start with undef by one.
+                else if (!lastChar.getKey().equals(prevChar.getKey())) 
+                {
+                    startCode[nseg] = lastChar.getKey()+1;
+                    endCode[nseg] = prevChar.getKey();
+                    idDelta[nseg] = lastGid - lastChar.getKey();
+                    ++nseg;
+                }
+                lastGid = curGid;
+                lastChar = curChar;
+            }
+            prevChar = curChar;
+        }
+        // trailing segment
+        startCode[nseg] = lastChar.getKey();
+        endCode[nseg] = prevChar.getKey();
+        idDelta[nseg] = lastGid -lastChar.getKey();
+        ++nseg;
+        // notdef character.
+        startCode[nseg] = 0xffff;
+        endCode[nseg] = 0xffff;
+        idDelta[nseg] = 1;
+        ++nseg;
+
+        // record of encodingID 10
+        writeUint16(dos,3);  // Windows
+        writeUint16(dos,10); // Unicode UCS-4
+        // header (4 byte) + encoding record (2 * 8 byte) 
+        //  + length of encoding 1 record (fixed 2 byte * 8 + nseg * 2byte * 4)
+        writeUint32(dos, 4 + 2*8 + 8*2 + nseg * (4*2));
         
         /*
          * UInt16    format    Format number is set to 4     
@@ -914,6 +1058,65 @@ public class TTFSubFont
         {    
             writeUint16(dos,0);
         }
+
+        // mapping of type 12
+        it = this.characters.entrySet().iterator();
+        it.next();  // ignore .notdef code
+        lastChar = it.next();
+        prevChar = lastChar;
+        lastGid = this.getNewGlyphId(lastChar.getValue());
+
+        startCode      = new int[this.characters.size()];
+        endCode        = new int[this.characters.size()];
+        int[] startGid = new int[this.characters.size()];
+        int ngrp = 0;
+        while(it.hasNext()) 
+        {
+            Entry<Integer, Integer> curChar = it.next();
+            int curGid = this.getNewGlyphId(curChar.getValue());
+            if (curChar.getKey() != prevChar.getKey()+1
+             || curGid - lastGid != curChar.getKey() - lastChar.getKey()) 
+            {
+                if (lastGid != 0) 
+                {
+                    startCode[ngrp] = lastChar.getKey();
+                    endCode[ngrp]   = prevChar.getKey();
+                    startGid[ngrp]  = lastGid;
+                    ++ngrp;
+                }
+                lastGid = curGid;
+                lastChar = curChar;
+            }
+            prevChar = curChar;
+        }
+        // trailing segment
+        startCode[ngrp] = lastChar.getKey();
+        endCode[ngrp] = prevChar.getKey();
+        startGid[ngrp] = lastGid;
+        ++ngrp;
+
+        /*
+         * UInt16    format    Format number is set to 12
+         * UInt16    reserved
+         * UInt32    length    Length of subtable in bytes (including the header)
+         * UInt32    language  0
+         * UInt32    nGropus
+         * UInt32    startCharCode
+         * UInt32    entryCharCode
+         * UInt32    startGlyphID
+         */
+        
+        writeUint16(dos,12);
+        writeUint16(dos,0);
+        dos.writeInt(4*4 + ngrp*4*3);
+        dos.writeInt(0);
+        dos.writeInt(ngrp);
+        for (int i=0; i<ngrp; i++)
+        {
+            dos.writeInt(startCode[i]);
+            dos.writeInt(endCode[i]);
+            dos.writeInt(startGid[i]);
+        }
         LOG.debug("Finished table [cmap].");
         return bos.toByteArray();
     }
@@ -1129,7 +1332,15 @@ public class TTFSubFont
             tables[0] = this.buildOS2Table();
             tables[2] = this.buildGlyfTable(newOffsets);
             tables[6] = this.buildLocaTable(newOffsets);
-            tables[1] = this.buildCmapTable();
+            if (useUCS4)
+            {
+                tables[1] = this.buildUCS4CmapTable();
+            }
+            else
+            {
+                tables[1] = this.buildCmapTable();
+            }
+
             tables[5] = this.buildHmtxTable();
             tables[9] = this.buildPostTable();
             long checksum = writeFileHeader(dos,tableNames.length);
