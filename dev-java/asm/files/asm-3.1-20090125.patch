diff -uNr asm-3.1.orig/.classpath asm-3.1/.classpath
--- asm-3.1.orig/.classpath	2006-07-06 00:22:55.000000000 +0900
+++ asm-3.1/.classpath	2009-01-27 12:46:21.000000000 +0900
@@ -12,15 +12,26 @@
 	<classpathentry kind="src" path="examples/helloworld/src"/>
 	<classpathentry kind="src" path="examples/jbfc/src"/>
 	<classpathentry kind="src" path="examples/xml"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="test/lib/javassist.jar"/>
+	<classpathentry kind="src" path="examples/jasmin/src"/>
+	<classpathentry kind="src" path="examples/jasmin/test"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="lib" path="test/lib/jd.xslt-1.5.5.jar"/>
 	<classpathentry kind="lib" path="test/lib/saxon7.jar"/>
-	<classpathentry kind="lib" path="test/lib/serp.jar"/>
 	<classpathentry kind="lib" path="test/lib/xalan-2.6.0.jar"/>
-	<classpathentry sourcepath="ECLIPSE_HOME/plugins/org.eclipse.jdt.source_3.0.0/src/org.junit_3.8.1/junitsrc.zip" kind="var" path="JUNIT_HOME/junit.jar"/>
-	<classpathentry kind="lib" path="test/lib/janino-2.3.4.jar"/>
-	<classpathentry kind="lib" path="test/lib/aspectjweaver.jar"/>
-	<classpathentry kind="lib" path="test/lib/bcel-5.1.jar"/>
+	<classpathentry kind="lib" path="test/lib/csg-bytecode.jar"/>
+	<classpathentry kind="lib" path="test/lib/kawa-1.9.1.jar"/>
+	<classpathentry kind="lib" path="test/lib/cojen-2.0.jar"/>
+	<classpathentry kind="lib" path="test/lib/jbet3-R1.jar"/>
+	<classpathentry kind="lib" path="test/lib/jclasslib.jar"/>
+	<classpathentry kind="lib" path="test/lib/jiapi.jar"/>
+	<classpathentry kind="lib" path="test/lib/log4j-1.2.9.jar"/>
+	<classpathentry kind="lib" path="test/lib/rhino1_7R1.jar"/>
+	<classpathentry kind="lib" path="test/lib/bcel-5.2.jar"/>
+	<classpathentry kind="lib" path="test/lib/janino-2.5.11.jar"/>
+	<classpathentry kind="lib" path="test/lib/javassist.3.6.GA.jar"/>
+	<classpathentry kind="lib" path="test/lib/serp-1.14.2.jar"/>
+	<classpathentry kind="lib" path="test/lib/aspectjweaver-1.5.3.jar"/>
+	<classpathentry kind="lib" path="examples/jasmin/test/jasmin.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/3"/>
 	<classpathentry kind="output" path="output/eclipse"/>
 </classpath>
diff -uNr asm-3.1.orig/.fbprefs asm-3.1/.fbprefs
--- asm-3.1.orig/.fbprefs	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/.fbprefs	2009-01-27 12:46:48.000000000 +0900
@@ -0,0 +1,157 @@
+#FindBugs User Preferences
+#Tue Dec 30 20:00:35 CET 2008
+detectorAppendingToAnObjectOutputStream=AppendingToAnObjectOutputStream|true
+detectorBCPMethodReturnCheck=BCPMethodReturnCheck|false
+detectorBadAppletConstructor=BadAppletConstructor|false
+detectorBadResultSetAccess=BadResultSetAccess|false
+detectorBadSyntaxForRegularExpression=BadSyntaxForRegularExpression|true
+detectorBadUseOfReturnValue=BadUseOfReturnValue|true
+detectorBadlyOverriddenAdapter=BadlyOverriddenAdapter|true
+detectorBooleanReturnNull=BooleanReturnNull|true
+detectorBuildInterproceduralCallGraph=BuildInterproceduralCallGraph|false
+detectorBuildObligationPolicyDatabase=BuildObligationPolicyDatabase|true
+detectorCallToUnsupportedMethod=CallToUnsupportedMethod|true
+detectorCalledMethods=CalledMethods|true
+detectorCheckCalls=CheckCalls|false
+detectorCheckExpectedWarnings=CheckExpectedWarnings|false
+detectorCheckImmutableAnnotation=CheckImmutableAnnotation|true
+detectorCheckTypeQualifiers=CheckTypeQualifiers|true
+detectorCloneIdiom=CloneIdiom|true
+detectorComparatorIdiom=ComparatorIdiom|false
+detectorConfusedInheritance=ConfusedInheritance|true
+detectorConfusionBetweenInheritedAndOuterMethod=ConfusionBetweenInheritedAndOuterMethod|true
+detectorCrossSiteScripting=CrossSiteScripting|true
+detectorDoInsideDoPrivileged=DoInsideDoPrivileged|true
+detectorDontCatchIllegalMonitorStateException=DontCatchIllegalMonitorStateException|true
+detectorDontUseEnum=DontUseEnum|true
+detectorDroppedException=DroppedException|true
+detectorDumbMethodInvocations=DumbMethodInvocations|true
+detectorDumbMethods=DumbMethods|true
+detectorDuplicateBranches=DuplicateBranches|true
+detectorEmptyZipFileEntry=EmptyZipFileEntry|true
+detectorEqStringTest=EqStringTest|false
+detectorEqualsOperandShouldHaveClassCompatibleWithThis=EqualsOperandShouldHaveClassCompatibleWithThis|true
+detectorFieldItemSummary=FieldItemSummary|true
+detectorFinalizerNullsFields=FinalizerNullsFields|true
+detectorFindBadCast=FindBadCast|false
+detectorFindBadCast2=FindBadCast2|true
+detectorFindBadEqualsImplementation=FindBadEqualsImplementation|false
+detectorFindBadForLoop=FindBadForLoop|true
+detectorFindBugsSummaryStats=FindBugsSummaryStats|true
+detectorFindCircularDependencies=FindCircularDependencies|false
+detectorFindDeadLocalStores=FindDeadLocalStores|true
+detectorFindDoubleCheck=FindDoubleCheck|true
+detectorFindEmptySynchronizedBlock=FindEmptySynchronizedBlock|true
+detectorFindFieldSelfAssignment=FindFieldSelfAssignment|true
+detectorFindFinalizeInvocations=FindFinalizeInvocations|true
+detectorFindFloatEquality=FindFloatEquality|true
+detectorFindFloatMath=FindFloatMath|false
+detectorFindHEmismatch=FindHEmismatch|true
+detectorFindInconsistentSync2=FindInconsistentSync2|true
+detectorFindJSR166LockMonitorenter=FindJSR166LockMonitorenter|true
+detectorFindLocalSelfAssignment2=FindLocalSelfAssignment2|true
+detectorFindMaskedFields=FindMaskedFields|true
+detectorFindMismatchedWaitOrNotify=FindMismatchedWaitOrNotify|true
+detectorFindNakedNotify=FindNakedNotify|true
+detectorFindNonSerializableStoreIntoSession=FindNonSerializableStoreIntoSession|false
+detectorFindNonSerializableValuePassedToWriteObject=FindNonSerializableValuePassedToWriteObject|true
+detectorFindNonShortCircuit=FindNonShortCircuit|true
+detectorFindNullDeref=FindNullDeref|true
+detectorFindNullDerefsInvolvingNonShortCircuitEvaluation=FindNullDerefsInvolvingNonShortCircuitEvaluation|true
+detectorFindOpenStream=FindOpenStream|true
+detectorFindPuzzlers=FindPuzzlers|true
+detectorFindRefComparison=FindRefComparison|true
+detectorFindReturnRef=FindReturnRef|false
+detectorFindRunInvocations=FindRunInvocations|true
+detectorFindSelfComparison=FindSelfComparison|true
+detectorFindSelfComparison2=FindSelfComparison2|true
+detectorFindSleepWithLockHeld=FindSleepWithLockHeld|true
+detectorFindSpinLoop=FindSpinLoop|true
+detectorFindSqlInjection=FindSqlInjection|false
+detectorFindTwoLockWait=FindTwoLockWait|true
+detectorFindUncalledPrivateMethods=FindUncalledPrivateMethods|true
+detectorFindUnconditionalWait=FindUnconditionalWait|true
+detectorFindUninitializedGet=FindUninitializedGet|true
+detectorFindUnrelatedTypesInGenericContainer=FindUnrelatedTypesInGenericContainer|true
+detectorFindUnreleasedLock=FindUnreleasedLock|true
+detectorFindUnsatisfiedObligation=FindUnsatisfiedObligation|true
+detectorFindUnsyncGet=FindUnsyncGet|true
+detectorFindUselessControlFlow=FindUselessControlFlow|true
+detectorFormatStringChecker=FormatStringChecker|true
+detectorHugeSharedStringConstants=HugeSharedStringConstants|true
+detectorIDivResultCastToDouble=IDivResultCastToDouble|true
+detectorIncompatMask=IncompatMask|true
+detectorInconsistentAnnotations=InconsistentAnnotations|true
+detectorInefficientMemberAccess=InefficientMemberAccess|false
+detectorInefficientToArray=InefficientToArray|true
+detectorInfiniteLoop=InfiniteLoop|true
+detectorInfiniteRecursiveLoop=InfiniteRecursiveLoop|true
+detectorInfiniteRecursiveLoop2=InfiniteRecursiveLoop2|false
+detectorInheritanceUnsafeGetResource=InheritanceUnsafeGetResource|true
+detectorInitializationChain=InitializationChain|true
+detectorInstantiateStaticClass=InstantiateStaticClass|true
+detectorInvalidJUnitTest=InvalidJUnitTest|true
+detectorIteratorIdioms=IteratorIdioms|true
+detectorLazyInit=LazyInit|true
+detectorLoadOfKnownNullValue=LoadOfKnownNullValue|true
+detectorLockedFields=LockedFields|false
+detectorMethodReturnCheck=MethodReturnCheck|true
+detectorMethods=Methods|true
+detectorMultithreadedInstanceAccess=MultithreadedInstanceAccess|true
+detectorMutableLock=MutableLock|true
+detectorMutableStaticFields=MutableStaticFields|false
+detectorNaming=Naming|true
+detectorNoteAnnotationRetention=NoteAnnotationRetention|true
+detectorNoteCheckReturnValue=NoteCheckReturnValue|true
+detectorNoteCheckReturnValueAnnotations=NoteCheckReturnValueAnnotations|true
+detectorNoteDirectlyRelevantTypeQualifiers=NoteDirectlyRelevantTypeQualifiers|true
+detectorNoteJCIPAnnotation=NoteJCIPAnnotation|true
+detectorNoteNonNullAnnotations=NoteNonNullAnnotations|true
+detectorNoteNonnullReturnValues=NoteNonnullReturnValues|true
+detectorNoteSuppressedWarnings=NoteSuppressedWarnings|true
+detectorNoteUnconditionalParamDerefs=NoteUnconditionalParamDerefs|true
+detectorNumberConstructor=NumberConstructor|false
+detectorOverridingEqualsNotSymmetrical=OverridingEqualsNotSymmetrical|true
+detectorPreferZeroLengthArrays=PreferZeroLengthArrays|true
+detectorPublicSemaphores=PublicSemaphores|true
+detectorQuestionableBooleanAssignment=QuestionableBooleanAssignment|true
+detectorReadReturnShouldBeChecked=ReadReturnShouldBeChecked|true
+detectorRedundantInterfaces=RedundantInterfaces|true
+detectorReflectiveClasses=ReflectiveClasses|true
+detectorRepeatedConditionals=RepeatedConditionals|true
+detectorResolveAllReferences=ResolveAllReferences|false
+detectorRuntimeExceptionCapture=RuntimeExceptionCapture|true
+detectorSerializableIdiom=SerializableIdiom|false
+detectorStartInConstructor=StartInConstructor|true
+detectorStaticCalendarDetector=StaticCalendarDetector|true
+detectorStringConcatenation=StringConcatenation|true
+detectorSuperfluousInstanceOf=SuperfluousInstanceOf|true
+detectorSuspiciousThreadInterrupted=SuspiciousThreadInterrupted|true
+detectorSwitchFallthrough=SwitchFallthrough|true
+detectorSynchronizationOnSharedBuiltinConstant=SynchronizationOnSharedBuiltinConstant|true
+detectorSynchronizeAndNullCheckField=SynchronizeAndNullCheckField|true
+detectorSynchronizeOnClassLiteralNotGetClass=SynchronizeOnClassLiteralNotGetClass|true
+detectorSynchronizingOnContentsOfFieldToProtectField=SynchronizingOnContentsOfFieldToProtectField|true
+detectorTestASM=TestASM|false
+detectorTestDataflowAnalysis=TestDataflowAnalysis|false
+detectorTestingGround=TestingGround|false
+detectorTrainFieldStoreTypes=TrainFieldStoreTypes|true
+detectorTrainNonNullAnnotations=TrainNonNullAnnotations|true
+detectorTrainUnconditionalDerefParams=TrainUnconditionalDerefParams|true
+detectorURLProblems=URLProblems|true
+detectorUncallableMethodOfAnonymousClass=UncallableMethodOfAnonymousClass|true
+detectorUnnecessaryMath=UnnecessaryMath|true
+detectorUnreadFields=UnreadFields|true
+detectorUseObjectEquals=UseObjectEquals|true
+detectorUselessSubclassMethod=UselessSubclassMethod|true
+detectorVarArgsProblems=VarArgsProblems|true
+detectorVolatileUsage=VolatileUsage|true
+detectorWaitInLoop=WaitInLoop|true
+detectorWrongMapIterator=WrongMapIterator|true
+detectorXMLFactoryBypass=XMLFactoryBypass|true
+detector_threshold=2
+effort=max
+excludefilter0=findbugsExclude.xml
+filter_settings=Medium|BAD_PRACTICE,CORRECTNESS,EXPERIMENTAL,I18N,MALICIOUS_CODE,MT_CORRECTNESS,PERFORMANCE,SECURITY,STYLE|false
+filter_settings_neg=|
+run_at_full_build=false
diff -uNr asm-3.1.orig/.project asm-3.1/.project
--- asm-3.1.orig/.project	2006-11-06 00:03:11.000000000 +0900
+++ asm-3.1/.project	2009-01-27 12:47:17.000000000 +0900
@@ -10,8 +10,14 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>edu.umd.cs.findbugs.plugin.eclipse.findbugsNature</nature>
 	</natures>
 </projectDescription>
diff -uNr asm-3.1.orig/archive/asm-all.xml asm-3.1/archive/asm-all.xml
--- asm-3.1.orig/archive/asm-all.xml	2006-10-28 03:50:40.000000000 +0900
+++ asm-3.1/archive/asm-all.xml	2009-01-27 12:44:22.000000000 +0900
@@ -12,6 +12,15 @@
         <attribute name="Implementation-Title" value="ASM all classes"/>
         <attribute name="Implementation-Version" value="${product.artifact}"/> 
         <attribute name="Implementation-Vendor" value="France Telecom R&amp;D"/>
+
+        <attribute name="Bundle-ManifestVersion" value="2"/>
+        <attribute name="Bundle-Name"      value="ASM all classes"/>
+        <attribute name="Bundle-Vendor"    value="France Telecom R&amp;D"/>
+        <attribute name="Bundle-Version"   value="${product.artifact}"/>
+        <attribute name="Bundle-DocURL"    value="http://asm.objectweb.org"/>
+        <attribute name="Bundle-SymbolicName" value="org.objectweb.asm.all"/>
+        <attribute name="Export-Package" value="org.objectweb.asm;version=${product.artifact},org.objectweb.asm.signature;version=${product.artifact},org.objectweb.asm.commons;version=${product.artifact},org.objectweb.asm.tree;version=${product.artifact},org.objectweb.asm.tree.analysis;version=${product.artifact},org.objectweb.asm.util;version=${product.artifact},org.objectweb.asm.xml;version=${product.artifact}"/>
+        <attribute name="Bundle-RequiredExecutionEnvironment" value="J2SE-1.3"/>
       </manifest>
     </jar>
 
diff -uNr asm-3.1.orig/archive/asm-debug-all.pom asm-3.1/archive/asm-debug-all.pom
--- asm-3.1.orig/archive/asm-debug-all.pom	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/archive/asm-debug-all.pom	2009-01-27 12:44:22.000000000 +0900
@@ -0,0 +1,15 @@
+<project>
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>asm</groupId>
+    <artifactId>asm-parent</artifactId>
+    <version>@product.artifact@</version>
+  </parent>
+
+  <name>ASM Debug All</name>
+  <groupId>asm</groupId>
+  <artifactId>asm-debug-all</artifactId>
+  <packaging>jar</packaging>
+  
+</project>
diff -uNr asm-3.1.orig/archive/asm-debug-all.xml asm-3.1/archive/asm-debug-all.xml
--- asm-3.1.orig/archive/asm-debug-all.xml	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/archive/asm-debug-all.xml	2009-01-27 12:44:22.000000000 +0900
@@ -0,0 +1,43 @@
+<project name="asm-debug-all" default="dist">
+  
+  <target name="dist" depends="build-jar,build-snapshot"/>
+
+  <target name="build-jar">
+    <mkdir dir="${out.dist.lib}/all"/>
+    <jar jarfile="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.jar"
+         basedir="${out.build}/tmp">
+      <include name="org/objectweb/asm/**/*.class"/>
+      <exclude name="org/objectweb/asm/optimizer/*.class"/>
+      <manifest>
+        <attribute name="Implementation-Title" value="ASM all classes with debug info"/>
+        <attribute name="Implementation-Version" value="${product.artifact}"/> 
+        <attribute name="Implementation-Vendor" value="France Telecom R&amp;D"/>
+
+        <attribute name="Bundle-ManifestVersion" value="2"/>
+        <attribute name="Bundle-Name"      value="ASM all classes with debug info"/>
+        <attribute name="Bundle-Vendor"    value="France Telecom R&amp;D"/>
+        <attribute name="Bundle-Version"   value="${product.artifact}"/>
+        <attribute name="Bundle-DocURL"    value="http://asm.objectweb.org"/>
+        <attribute name="Bundle-SymbolicName" value="org.objectweb.asm.all"/>
+        <attribute name="Export-Package" value="org.objectweb.asm;version=${product.artifact},org.objectweb.asm.signature;version=${product.artifact},org.objectweb.asm.commons;version=${product.artifact},org.objectweb.asm.tree;version=${product.artifact},org.objectweb.asm.tree.analysis;version=${product.artifact},org.objectweb.asm.util;version=${product.artifact},org.objectweb.asm.xml;version=${product.artifact}"/>
+        <attribute name="Bundle-RequiredExecutionEnvironment" value="J2SE-1.3"/>
+      </manifest>
+    </jar>
+
+    <copy file="${archive}/asm-all.pom" toFile="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.pom"/>
+    <replace file="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.pom" token="@product.name@" value="${ant.project.name}"/>
+    <replace file="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.pom" token="@product.artifact@" value="${product.artifact}"/>
+
+    <echo file="${out.dist.lib}/all/README.txt">It is highly recommended to use only the necessary ASM jars for your
+application instead of using the asm-all jar, unless you really need
+all ASM packages.</echo>
+  </target>
+
+  <target name="build-snapshot" if="product.snapshot">
+    <mkdir dir="${out.dist.lib}/all"/>
+    <copy file="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.jar" toFile="${out.dist.lib}/${ant.project.name}-SNAPSHOT.jar"/>
+    <copy file="${out.dist.lib}/all/${ant.project.name}-${product.artifact}.pom" toFile="${out.dist.lib}/${ant.project.name}-SNAPSHOT.pom"/>
+    <echo file="${out.dist.lib}/all/${ant.project.name}-snapshot-version" message="${product.build.time}"/>
+  </target>
+
+</project>
diff -uNr asm-3.1.orig/archive/asm-parent.pom asm-3.1/archive/asm-parent.pom
--- asm-3.1.orig/archive/asm-parent.pom	2006-10-28 03:50:39.000000000 +0900
+++ asm-3.1/archive/asm-parent.pom	2009-01-27 12:44:22.000000000 +0900
@@ -1,4 +1,7 @@
-<project>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+                        http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <artifactId>asm-parent</artifactId>
@@ -15,6 +18,13 @@
     <url>http://www.objectweb.org/</url>
   </organization>
   <inceptionYear>2000</inceptionYear>
+  
+  <licenses>
+    <license>
+      <name>BSD</name>
+      <url>http://asm.objectweb.org/license.html</url>
+    </license>
+  </licenses>
 
   <developers>
     <developer>
@@ -37,7 +47,7 @@
   </developers>
 
   <scm>
-    <connection>scm:cvs:pserver:anonymous@cvs.forge.objectweb.org:/cvsroot/asm:asm</connection>
+    <connection>scm:cvs:pserver:anonymous:@cvs.forge.objectweb.org:/cvsroot/asm:asm</connection>
     <developerConnection>scm:cvs:ext:${maven.username}@cvs.forge.objectweb.org:/cvsroot/asm:asm</developerConnection>
     <url>http://cvs.forge.objectweb.org/cgi-bin/viewcvs.cgi/asm/asm/</url>
   </scm>
@@ -88,4 +98,39 @@
     </dependencies>
   </dependencyManagement>
 
+  <mailingLists>
+    <mailingList>
+      <name>ASM Users List</name>
+      <subscribe>sympa@ow2.org?subject=subscribe%20asm</subscribe>
+      <unsubscribe>sympa@ow2.org?subject=unsubscribe%20asm</unsubscribe>
+      <post>asm@ow2.org</post>
+      <archive>http://www.ow2.org/wws/arc/asm</archive>
+    </mailingList>
+    <mailingList>
+      <name>ASM Team List</name>
+      <subscribe>sympa@ow2.org?subject=subscribe%20asm-team</subscribe>
+      <unsubscribe>sympa@ow2.org?subject=unsubscribe%20asm-team</unsubscribe>
+      <post>asm-team@ow2.org</post>
+      <archive>http://www.ow2.org/wws/arc/asm-team</archive>
+    </mailingList>
+  </mailingLists>
+
+  <distributionManagement>
+    <downloadUrl>http://mojo.codehaus.org/my-project</downloadUrl>
+    <repository>
+      <id>objectweb</id>
+      <uniqueVersion>false</uniqueVersion>
+      <name>ObjectWeb Maven 2.0 Repository</name>
+      <url>dav:https://maven.forge.objectweb.org:8002/maven2/</url>
+      <layout>default</layout>
+    </repository>
+    <snapshotRepository>
+      <id>objectweb.snapshots</id>
+      <uniqueVersion>false</uniqueVersion>
+      <name>ObjectWeb Maven 2.0 Snapshot Repository</name>
+      <url>dav:https://maven.forge.objectweb.org:8002/maven2-snapshot/</url>
+      <layout>default</layout>
+    </snapshotRepository>
+  </distributionManagement>
+
 </project>
diff -uNr asm-3.1.orig/build.config asm-3.1/build.config
--- asm-3.1.orig/build.config	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/build.config	2009-01-27 12:44:27.000000000 +0900
@@ -0,0 +1,32 @@
+# Defines values for the 'build.properties' build properties
+# This file is used to build the project in the case of bundled external jars
+
+objectweb.ant.tasks.path config/ow_util_ant_tasks.jar
+
+bcel.path test/lib/bcel-5.2.jar
+
+aspectj.path test/lib/aspectjweaver-1.5.3.jar
+
+serp.path test/lib/serp-1.14.2.jar
+
+javassist.path test/lib/javassist.3.6.GA.jar
+
+janino.path test/lib/janino-2.5.11.jar
+
+cobertura.path test/lib/cobertura-1.9.jar;test/lib/jakarta-oro-2.0.8.jar;test/lib/log4j-1.2.9.jar;test/lib/asm-2.2.1.jar;test/lib/asm-tree-2.2.1.jar
+
+cobertura.runtime.path test/lib/cobertura-1.9.jar
+
+kawa.runtime.path test/lib/kawa-1.9.1.jar
+
+csg-bytecode.runtime.path test/lib/csg-bytecode.jar
+
+cojen.runtime.path test/lib/cojen-2.0.jar
+
+jbet.runtime.path test/lib/jbet3-R1.jar
+
+jclasslib.runtime.path test/lib/jclasslib.jar
+
+jiapi.runtime.path test/lib/jiapi.jar
+
+rhino.runtime.path test/lib/rhino1_7R1.jar
diff -uNr asm-3.1.orig/build.properties asm-3.1/build.properties
--- asm-3.1.orig/build.properties	2007-10-27 19:24:27.000000000 +0900
+++ asm-3.1/build.properties	2009-01-27 12:44:23.000000000 +0900
@@ -58,7 +58,7 @@
 # TESTS (PERFORMANCE COMPARISONS WITH BCEL AND SERP)
 ###############################################################################
 
-# Class path for the BCEL library (version 5.1)
+# Class path for the BCEL library (version 5.2)
 # See http://jakarta.apache.org/bcel
 
 # bcel.path bcel.jar
@@ -68,26 +68,54 @@
 
 # aspectj.path aspectjweaver.jar
 
-# Class path for the SERP library (version 1.4.2)
+# Class path for the SERP library (version 1.14.2)
 # See http://serp.sourceforge.net
 
 # serp.path serp.jar
 
-# Class path for the Javassist library (version 2.6)
+# Class path for the Javassist library (version 3.6.GA)
 # See http://www.csg.is.titech.ac.jp/~chiba/javassist
 
 # javassist.path javassist.jar
 
-# Class path for the Janino compiler (version 2.3.3)
+# Class path for the Janino compiler (version 2.5.11)
 # See http://www.janino.net/
 
 # janino.path janino.jar
 
-# Class paths for Cobertura (version 1.7)
+# Class paths for Cobertura (version 1.9)
 
 # corbertura.path cobertura.jar
 # cobertura.runtime.path cobertura.jar
 
+# Class paths for Kawa (version 1.9.1)
+
+# kawa.runtime.path kawa.jar
+
+# Class paths for CSG Bytecode
+
+# csg-bytecode.runtime.path csg-bytecode.jar
+
+# Class paths for Cojen (version 2.0)
+
+# cojen.runtime.path cojen.jar
+
+# Class paths for JBET (version 3-R1)
+
+# jbet.runtime.path jbet.jar
+
+# Class paths for JClassLib
+
+# jclasslib.runtime.path jclasslib.jar
+
+# Class paths for Jiapi
+
+# jiapi.runtime.path jiapi.jar
+
+# Class paths for mozilla.classfile (version 1_7R1)
+
+# rhino.runtime.path rhino.jar
+
 ###############################################################################
 # DOCUMENTATION
 ###############################################################################
diff -uNr asm-3.1.orig/build.xml asm-3.1/build.xml
--- asm-3.1.orig/build.xml	2007-09-08 23:32:02.000000000 +0900
+++ asm-3.1/build.xml	2009-01-27 12:44:23.000000000 +0900
@@ -131,19 +131,14 @@
        <pathelement path="${cobertura.path}"/> 
     </path>
 
-    <taskdef name="multipleAnt"
-             classname="org.objectweb.util.ant.MultipleAnt"
-             classpath="${objectweb.ant.tasks.path}"/>
-
-    <taskdef name="javadocMultipleLink"
-             classname="org.objectweb.util.ant.JavadocMultipleLink"
-             classpath="${objectweb.ant.tasks.path}"/>
-
-    <taskdef name="multipleCopy"
-             classname="org.objectweb.util.ant.MultipleCopy"
-             classpath="${objectweb.ant.tasks.path}"/>
-
     <taskdef classpathref="cobertura.classpath" resource="tasks.properties"/>
+
+    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant">
+      <classpath>
+        <pathelement location="test/lib/maven-ant-tasks-2.0.7.jar"/>
+      </classpath>
+    </typedef>
+
   </target>
 
   <!-- =================================== -->
@@ -309,7 +304,15 @@
   </target>
     
   <target name="jar" depends="dist.init,dist.version,compile,shrink">
-    <multipleAnt dir="${archive}"/>
+    <ant antfile="${archive}/asm.xml"/>
+    <ant antfile="${archive}/asm-all.xml"/>
+    <ant antfile="${archive}/asm-analysis.xml"/>
+    <ant antfile="${archive}/asm-commons.xml"/>
+    <ant antfile="${archive}/asm-debug-all.xml"/>
+    <ant antfile="${archive}/asm-parent.xml"/>
+    <ant antfile="${archive}/asm-tree.xml"/>
+    <ant antfile="${archive}/asm-util.xml"/>
+    <ant antfile="${archive}/asm-xml.xml"/>
     <java classname="org.objectweb.asm.optimizer.JarOptimizer">
       <classpath>
         <pathelement location="${out.build}/tmp"/>
@@ -329,7 +332,7 @@
         <exclude name="**/*.fig"/>
       </fileset>
     </copy>
-    <multipleAnt dir="${jdoc}"/>
+    <ant antfile="${jdoc}/user.xml"/>
   </target>
 
   <target name="examples" depends="init,dist.init" if="examples.exist">
@@ -343,15 +346,27 @@
       </fileset>
     </copy>
 
-    <multipleCopy file="${examples}/common/build.xml"
-                  toDir="${out.dist.examples}"
-                  notReplace="yes"
-                  preservelastmodified="yes">
-      <include name="*"/>
-      <exclude name="etc"/>
-      <exclude name="lib"/>
-    </multipleCopy>
-
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/adapt" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/analysis" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/annotations" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/attributes" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/compile" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/dependencies" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/helloworld"  preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/jasmin"  preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/jbfc" preservelastmodified="yes"/>
+    <copy file="${examples}/common/build.xml"
+        toDir="${out.dist.examples}/xml" preservelastmodified="yes"/>
+    
     <copy toDir="${out.dist.examples}" preservelastmodified="yes">
       <fileset dir="${examples.common}">
         <include name="**/*"/>
@@ -565,96 +580,90 @@
     <echo message="  -Dtest.name=&lt;test name&gt;  Only a single test. The target &lt;test name&gt; is called"/>
   </target>
 
-  <target name="maven.install" xmlns:artifact="urn:maven-artifact-ant">
-    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant">
-      <classpath>
-        <pathelement location="test/lib/maven-artifact-ant-2.0.4-dep.jar"/>
-      </classpath>
-    </typedef>
+  <target name="maven.install" xmlns:artifact="urn:maven-artifact-ant" depends="init">
 
-    <artifact:install file="${out.dist.lib}/asm-parent-3.0.pom">
-      <artifact:pom file="${out.dist.lib}/asm-parent-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-parent-${product.artifact}.pom">
+      <artifact:pom file="${out.dist.lib}/asm-parent-${product.artifact}.pom"/>
     </artifact:install>
 
-    <artifact:install file="${out.dist.lib}/asm-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-${product.artifact}.pom"/>
     </artifact:install>
 
-    <artifact:install file="${out.dist.lib}/asm-analysis-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-analysis-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-analysis-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-analysis-${product.artifact}.pom"/>
     </artifact:install>
 
-    <artifact:install file="${out.dist.lib}/asm-commons-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-commons-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-commons-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-commons-${product.artifact}.pom"/>
     </artifact:install>
 
-    <artifact:install file="${out.dist.lib}/asm-tree-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-tree-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-tree-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-tree-${product.artifact}.pom"/>
     </artifact:install>
     
-    <artifact:install file="${out.dist.lib}/asm-util-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-util-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-util-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-util-${product.artifact}.pom"/>
     </artifact:install>
   
-    <artifact:install file="${out.dist.lib}/asm-xml-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-xml-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/asm-xml-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-xml-${product.artifact}.pom"/>
     </artifact:install>
 
-    <artifact:install file="${out.dist.lib}/all/asm-all-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/all/asm-all-3.0.pom"/>
+    <artifact:install file="${out.dist.lib}/all/asm-all-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/all/asm-all-${product.artifact}.pom"/>
+      <artifact:attach file="${out.dist}/src.zip" type="jar" classifier="sources"/>
     </artifact:install>
   </target>
 
-  <target name="maven.deploy" xmlns:artifact="urn:maven-artifact-ant">
-    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant">
-      <classpath>
-        <pathelement location="test/lib/maven-artifact-ant-2.0.4-dep.jar"/>
-      </classpath>
-    </typedef>
+  <target name="maven.deploy" xmlns:artifact="urn:maven-artifact-ant" depends="init">
 
-    <artifact:install-provider artifactId="wagon-file" version="1.0-alpha-5"/>
+    <artifact:install-provider artifactId="wagon-file" version="1.0-alpha-7"/>
+    <artifact:install-provider artifactId="wagon-webdav" version="1.0-alpha-6"/>
 
-    <property name="repository.url" value="file:${out}/maven"/>
+    <artifact:remoteRepository id="objectweb.repo" layout="default" url="file:${out}/maven"/>
 
-    <artifact:deploy file="${out.dist.lib}/asm-parent-3.0.pom">
-      <artifact:pom file="${out.dist.lib}/asm-parent-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-parent-${product.artifact}.pom">
+      <artifact:pom file="${out.dist.lib}/asm-parent-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
 
-    <artifact:deploy file="${out.dist.lib}/asm-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
 
-    <artifact:deploy file="${out.dist.lib}/asm-analysis-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-analysis-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-analysis-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-analysis-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
 
-    <artifact:deploy file="${out.dist.lib}/asm-commons-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-commons-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-commons-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-commons-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
 
-    <artifact:deploy file="${out.dist.lib}/asm-tree-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-tree-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-tree-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-tree-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
     
-    <artifact:deploy file="${out.dist.lib}/asm-util-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-util-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-util-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-util-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
   
-    <artifact:deploy file="${out.dist.lib}/asm-xml-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/asm-xml-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/asm-xml-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/asm-xml-${product.artifact}.pom"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
 
-    <artifact:deploy file="${out.dist.lib}/all/asm-all-3.0.jar">
-      <artifact:pom file="${out.dist.lib}/all/asm-all-3.0.pom"/>
-      <remoteRepository url="${repository.url}"/>
+    <artifact:deploy file="${out.dist.lib}/all/asm-all-${product.artifact}.jar">
+      <artifact:pom file="${out.dist.lib}/all/asm-all-${product.artifact}.pom"/>
+      <artifact:attach file="${out.dist}/src.zip" type="jar" classifier="sources"/>
+      <remoteRepository refid="objectweb.repo"/>
     </artifact:deploy>
+
   </target>
 
 </project>
diff -uNr asm-3.1.orig/examples/jasmin/etc/execute.properties asm-3.1/examples/jasmin/etc/execute.properties
--- asm-3.1.orig/examples/jasmin/etc/execute.properties	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/examples/jasmin/etc/execute.properties	2009-01-27 12:44:23.000000000 +0900
@@ -0,0 +1,2 @@
+run.classname JasminifierClassAdapter
+run.parameters java.lang.Object
diff -uNr asm-3.1.orig/examples/jasmin/src/JasminifierClassAdapter.java asm-3.1/examples/jasmin/src/JasminifierClassAdapter.java
--- asm-3.1.orig/examples/jasmin/src/JasminifierClassAdapter.java	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/examples/jasmin/src/JasminifierClassAdapter.java	2009-01-27 13:01:38.000000000 +0900
@@ -0,0 +1,922 @@
+/***
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2005 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+import java.io.FileInputStream;
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.objectweb.asm.ClassAdapter;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.EmptyVisitor;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.AnnotationNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.FieldNode;
+import org.objectweb.asm.tree.InnerClassNode;
+import org.objectweb.asm.tree.LabelNode;
+import org.objectweb.asm.tree.LocalVariableNode;
+import org.objectweb.asm.tree.MemberNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.tree.TryCatchBlockNode;
+import org.objectweb.asm.util.AbstractVisitor;
+
+/**
+ * A {@link ClassVisitor} that prints a disassembled view of the classes it
+ * visits in Jasmin assembler format. This class visitor can be used alone (see
+ * the {@link #main main} method) to disassemble a class. It can also be used in
+ * the middle of class visitor chain to trace the class that is visited at a
+ * given point in this chain. This may be uselful for debugging purposes. <p>
+ * The trace printed when visiting the <tt>Hello</tt> class is the following:
+ * <p> <blockquote>
+ *
+ * <pre>
+ * .bytecode 45.3
+ * .class public Hello
+ * .super java/lang/Object
+ *
+ * .method public <init>()V
+ * aload 0
+ * invokespecial java/lang/Object/<init>()V
+ * return
+ * .limit locals 1
+ * .limit stack 1
+ * .end method
+ *
+ * .method public static main([Ljava/lang/String;)V
+ * getstatic java/lang/System/out Ljava/io/PrintStream;
+ * ldc "hello"
+ * invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
+ * return
+ * .limit locals 2
+ * .limit stack 2
+ * .end method
+ * </pre>
+ *
+ * </blockquote> where <tt>Hello</tt> is defined by: <p> <blockquote>
+ *
+ * <pre>
+ * public class Hello {
+ *
+ *     public static void main(String[] args) {
+ *         System.out.println(&quot;hello&quot;);
+ *     }
+ * }
+ * </pre>
+ *
+ * </blockquote>
+ *
+ * @author Eric Bruneton
+ */
+public class JasminifierClassAdapter extends ClassAdapter {
+
+    /**
+     * The print writer to be used to print the class.
+     */
+    protected PrintWriter pw;
+
+    /**
+     * The label names. This map associate String values to Label keys.
+     */
+    protected final Map labelNames;
+
+    /**
+     * Prints a disassembled view of the given class in Jasmin assembler format
+     * to the standard output. <p> Usage: JasminifierClassAdapter [-debug]
+     * &lt;fully qualified class name or class file name &gt;
+     *
+     * @param args the command line arguments.
+     *
+     * @throws Exception if the class cannot be found, or if an IO exception
+     *         occurs.
+     */
+    public static void main(final String[] args) throws Exception {
+        int i = 0;
+        int flags = ClassReader.SKIP_DEBUG;
+
+        boolean ok = true;
+        if (args.length < 1 || args.length > 2) {
+            ok = false;
+        }
+        if (ok && "-debug".equals(args[0])) {
+            i = 1;
+            flags = 0;
+            if (args.length != 2) {
+                ok = false;
+            }
+        }
+        if (!ok) {
+            System.err.println("Prints a disassembled view of the given class.");
+            System.err.println("Usage: JasminifierClassAdapter [-debug] "
+                    + "<fully qualified class name or class file name>");
+            return;
+        }
+        ClassReader cr;
+        if (args[i].endsWith(".class") || args[i].indexOf('\\') > -1
+                || args[i].indexOf('/') > -1)
+        {
+            cr = new ClassReader(new FileInputStream(args[i]));
+        } else {
+            cr = new ClassReader(args[i]);
+        }
+        cr.accept(new JasminifierClassAdapter(new PrintWriter(System.out, true),
+                null),
+                flags | ClassReader.EXPAND_FRAMES);
+    }
+
+    /**
+     * Constructs a new {@link JasminifierClassAdapter}.
+     *
+     * @param pw the print writer to be used to print the class.
+     * @param cv the {@link ClassVisitor} to which this visitor delegates calls.
+     *        May be <tt>null</tt>.
+     */
+    public JasminifierClassAdapter(final PrintWriter pw, final ClassVisitor cv)
+    {
+        super(new ClassNode() {
+            public void visitEnd() {
+                if (cv != null) {
+                    accept(cv);
+                }
+            }
+        });
+        this.pw = pw;
+        labelNames = new HashMap();
+    }
+
+    public void visitEnd() {
+        ClassNode cn = (ClassNode) cv;
+        pw.print(".bytecode ");
+        pw.print(cn.version & 0xFFFF);
+        pw.print('.');
+        pw.println(cn.version >>> 16);
+        println(".source ", cn.sourceFile);
+        pw.print(".class");
+        pw.print(access(cn.access));
+        pw.print(' ');
+        pw.println(cn.name);
+        if (cn.superName == null) { // TODO Jasmin bug workaround
+            println(".super ", "java/lang/Object");
+        } else {
+            println(".super ", cn.superName);
+        }
+        for (int i = 0; i < cn.interfaces.size(); ++i) {
+            println(".implements ", (String) cn.interfaces.get(i));
+        }
+        if (cn.signature != null)
+            println(".signature ", '"' + cn.signature + '"');
+        if (cn.outerClass != null) {
+            pw.print(".enclosing method ");
+            pw.print(cn.outerClass);
+            if (cn.outerMethod != null) {
+                pw.print('/');
+                pw.print(cn.outerMethod);
+                pw.println(cn.outerMethodDesc);
+            } else {
+                pw.println();
+            }
+        }
+        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
+            pw.println(".deprecated");
+        }
+        printAnnotations(cn);
+        println(".debug ", cn.sourceDebug == null
+                ? null
+                : '"' + cn.sourceDebug + '"');
+
+        for (int i = 0; i < cn.innerClasses.size(); ++i) {
+            InnerClassNode in = (InnerClassNode) cn.innerClasses.get(i);
+            pw.print(".inner class");
+            pw.print(access(in.access));
+            if (in.innerName != null) {
+                pw.print(' ');
+                pw.print(in.innerName);
+            }
+            if (in.name != null) {
+                pw.print(" inner ");
+                pw.print(in.name);
+            }
+            if (in.outerName != null) {
+                pw.print(" outer ");
+                pw.print(in.outerName);
+            }
+            pw.println();
+        }
+
+        for (int i = 0; i < cn.fields.size(); ++i) {
+            FieldNode fn = (FieldNode) cn.fields.get(i);
+            boolean annotations = false;
+            if (fn.visibleAnnotations != null
+                    && fn.visibleAnnotations.size() > 0)
+            {
+                annotations = true;
+            }
+            if (fn.invisibleAnnotations != null
+                    && fn.invisibleAnnotations.size() > 0)
+            {
+                annotations = true;
+            }
+            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
+            pw.print("\n.field");
+            pw.print(access(fn.access));
+            pw.print(" '");
+            pw.print(fn.name);
+            pw.print("' ");
+            pw.print(fn.desc);
+            if (fn.signature != null && (!deprecated && !annotations)) {
+                pw.print(" signature \"");
+                pw.print(fn.signature);
+                pw.print("\"");
+            }
+            if (fn.value instanceof String) {
+                StringBuffer buf = new StringBuffer();
+                AbstractVisitor.appendString(buf, (String) fn.value);
+                pw.print(" = ");
+                pw.print(buf.toString());
+            } else if (fn.value != null) {
+                pw.print(" = ");
+                print(fn.value);
+                pw.println();
+            }
+            pw.println();
+            if (fn.signature != null && (deprecated || annotations)) {
+                pw.print(".signature \"");
+                pw.print(fn.signature);
+                pw.println("\"");
+            }
+            if (deprecated) {
+                pw.println(".deprecated");
+            }
+            printAnnotations(fn);
+            if (deprecated || annotations) {
+                pw.println(".end field");
+            }
+        }
+
+        for (int i = 0; i < cn.methods.size(); ++i) {
+            MethodNode mn = (MethodNode) cn.methods.get(i);
+            pw.print("\n.method");
+            pw.print(access(mn.access));
+            pw.print(' ');
+            pw.print(mn.name);
+            pw.println(mn.desc);
+            if (mn.signature != null) {
+                pw.print(".signature \"");
+                pw.print(mn.signature);
+                pw.println("\"");
+            }
+            if (mn.annotationDefault != null) {
+                pw.println(".annotation default");
+                printAnnotationValue(mn.annotationDefault);
+                pw.println(".end annotation");
+            }
+            printAnnotations(mn);
+            if (mn.visibleParameterAnnotations != null) {
+                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j)
+                {
+                    List l = mn.visibleParameterAnnotations[j];
+                    if (l != null) {
+                        for (int k = 0; k < l.size(); ++k) {
+                            printAnnotation((AnnotationNode) l.get(k), 1, j + 1);
+                        }
+                    }
+                }
+            }
+            if (mn.invisibleParameterAnnotations != null) {
+                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j)
+                {
+                    List l = mn.invisibleParameterAnnotations[j];
+                    if (l != null) {
+                        for (int k = 0; k < l.size(); ++k) {
+                            printAnnotation((AnnotationNode) l.get(k), 2, j + 1);
+                        }
+                    }
+                }
+            }
+            for (int j = 0; j < mn.exceptions.size(); ++j) {
+                println(".throws ", (String) mn.exceptions.get(j));
+            }
+            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
+                pw.println(".deprecated");
+            }
+            if (mn.instructions.size() > 0) {
+                labelNames.clear();
+                for (int j = 0; j < mn.tryCatchBlocks.size(); ++j) {
+                    TryCatchBlockNode tcb = (TryCatchBlockNode) mn.tryCatchBlocks.get(j);
+                    pw.print(".catch ");
+                    pw.print(tcb.type);
+                    pw.print(" from ");
+                    print(tcb.start);
+                    pw.print(" to ");
+                    print(tcb.end);
+                    pw.print(" using ");
+                    print(tcb.handler);
+                    pw.println();
+                }
+                for (int j = 0; j < mn.instructions.size(); ++j) {
+                    AbstractInsnNode in = mn.instructions.get(j);
+                    in.accept(new EmptyVisitor() {
+
+                        public void visitFrame(
+                            int type,
+                            int local,
+                            Object[] locals,
+                            int stack,
+                            Object[] stacks)
+                        {
+                            if (type != Opcodes.F_FULL && type != Opcodes.F_NEW)
+                            {
+                                throw new RuntimeException("Compressed frames unsupported, use EXPAND_FRAMES option");
+                            }
+                            pw.println(".stack");
+                            for (int i = 0; i < local; ++i) {
+                                pw.print("locals ");
+                                printFrameType(locals[i]);
+                                pw.println();
+                            }
+                            for (int i = 0; i < stack; ++i) {
+                                pw.print("stack ");
+                                printFrameType(stacks[i]);
+                                pw.println();
+                            }
+                            pw.println(".end stack");
+                        }
+
+                        public void visitInsn(int opcode) {
+                            print(opcode);
+                            pw.println();
+                        }
+
+                        public void visitIntInsn(int opcode, int operand) {
+                            print(opcode);
+                            if (opcode == Opcodes.NEWARRAY) {
+                                switch (operand) {
+                                    case Opcodes.T_BOOLEAN:
+                                        pw.println(" boolean");
+                                        break;
+                                    case Opcodes.T_CHAR:
+                                        pw.println(" char");
+                                        break;
+                                    case Opcodes.T_FLOAT:
+                                        pw.println(" float");
+                                        break;
+                                    case Opcodes.T_DOUBLE:
+                                        pw.println(" double");
+                                        break;
+                                    case Opcodes.T_BYTE:
+                                        pw.println(" byte");
+                                        break;
+                                    case Opcodes.T_SHORT:
+                                        pw.println(" short");
+                                        break;
+                                    case Opcodes.T_INT:
+                                        pw.println(" int");
+                                        break;
+                                    case Opcodes.T_LONG:
+                                    default:
+                                        pw.println(" long");
+                                        break;
+                                }
+                            } else {
+                                pw.print(' ');
+                                pw.println(operand);
+                            }
+                        }
+
+                        public void visitVarInsn(int opcode, int var) {
+                            print(opcode);
+                            pw.print(' ');
+                            pw.println(var);
+                        }
+
+                        public void visitTypeInsn(int opcode, String type) {
+                            print(opcode);
+                            pw.print(' ');
+                            pw.println(type);
+                        }
+
+                        public void visitFieldInsn(
+                            int opcode,
+                            String owner,
+                            String name,
+                            String desc)
+                        {
+                            print(opcode);
+                            pw.print(' ');
+                            pw.print(owner);
+                            pw.print('/');
+                            pw.print(name);
+                            pw.print(' ');
+                            pw.println(desc);
+                        }
+
+                        public void visitMethodInsn(
+                            int opcode,
+                            String owner,
+                            String name,
+                            String desc)
+                        {
+                            print(opcode);
+                            pw.print(' ');
+                            pw.print(owner);
+                            pw.print('/');
+                            pw.print(name);
+                            pw.print(desc);
+                            if (opcode == Opcodes.INVOKEINTERFACE) {
+                                pw.print(' ');
+                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
+                            }
+                            pw.println();
+                        }
+
+                        public void visitJumpInsn(int opcode, Label label) {
+                            print(opcode);
+                            pw.print(' ');
+                            print(label);
+                            pw.println();
+                        }
+
+                        public void visitLabel(Label label) {
+                            print(label);
+                            pw.println(':');
+                        }
+
+                        public void visitLdcInsn(Object cst) {
+                            pw.print("ldc ");
+                            if (cst instanceof Type) {
+                                pw.print(((Type) cst).getInternalName());
+                            } else {
+                                print(cst);
+                            }
+                            pw.println();
+                        }
+
+                        public void visitIincInsn(int var, int increment) {
+                            pw.print("iinc ");
+                            pw.print(var);
+                            pw.print(' ');
+                            pw.println(increment);
+                        }
+
+                        public void visitTableSwitchInsn(
+                            int min,
+                            int max,
+                            Label dflt,
+                            Label[] labels)
+                        {
+                            pw.print("tableswitch ");
+                            pw.println(min);
+                            for (int i = 0; i < labels.length; ++i) {
+                                print(labels[i]);
+                                pw.println();
+                            }
+                            pw.print("default : ");
+                            print(dflt);
+                            pw.println();
+                        }
+
+                        public void visitLookupSwitchInsn(
+                            Label dflt,
+                            int[] keys,
+                            Label[] labels)
+                        {
+                            if (keys.length == 0) {
+                                pw.print("goto "); // TODO Jasmin bug
+                                                    // workaround
+                                print(dflt);
+                                pw.println();
+                                return;
+                            }
+                            pw.println("lookupswitch");
+                            for (int i = 0; i < keys.length; ++i) {
+                                pw.print(keys[i]);
+                                pw.print(" : ");
+                                print(labels[i]);
+                                pw.println();
+                            }
+                            pw.print("default : ");
+                            print(dflt);
+                            pw.println();
+                        }
+
+                        public void visitMultiANewArrayInsn(
+                            String desc,
+                            int dims)
+                        {
+                            pw.print("multianewarray ");
+                            pw.print(desc);
+                            pw.print(' ');
+                            pw.println(dims);
+                        }
+
+                        public void visitLineNumber(int line, Label start) {
+                            pw.print(".line ");
+                            pw.println(line);
+                        }
+                    });
+                }
+                for (int j = 0; j < mn.localVariables.size(); ++j) {
+                    LocalVariableNode lv = (LocalVariableNode) mn.localVariables.get(j);
+                    pw.print(".var ");
+                    pw.print(lv.index);
+                    pw.print(" is '");
+                    pw.print(lv.name);
+                    pw.print("' ");
+                    pw.print(lv.desc);
+                    if (lv.signature != null) {
+                        pw.print(" signature \"");
+                        pw.print(lv.signature);
+                        pw.print("\"");
+                    }
+                    pw.print(" from ");
+                    print(lv.start);
+                    pw.print(" to ");
+                    print(lv.end);
+                    pw.println();
+                }
+                println(".limit locals ", Integer.toString(mn.maxLocals));
+                println(".limit stack ", Integer.toString(mn.maxStack));
+            }
+            pw.println(".end method");
+        }
+        super.visitEnd();
+    }
+
+    protected void println(final String directive, final String arg) {
+        if (arg != null) {
+            pw.print(directive);
+            pw.println(arg);
+        }
+    }
+
+    protected String access(final int access) {
+        StringBuffer b = new StringBuffer();
+        if ((access & Opcodes.ACC_PUBLIC) != 0) {
+            b.append(" public");
+        }
+        if ((access & Opcodes.ACC_PRIVATE) != 0) {
+            b.append(" private");
+        }
+        if ((access & Opcodes.ACC_PROTECTED) != 0) {
+            b.append(" protected");
+        }
+        if ((access & Opcodes.ACC_STATIC) != 0) {
+            b.append(" static");
+        }
+        if ((access & Opcodes.ACC_FINAL) != 0) {
+            b.append(" final");
+        }
+        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {
+            b.append(" synchronized");
+        }
+        if ((access & Opcodes.ACC_VOLATILE) != 0) {
+            b.append(" volatile");
+        }
+        if ((access & Opcodes.ACC_TRANSIENT) != 0) {
+            b.append(" transient");
+        }
+        if ((access & Opcodes.ACC_NATIVE) != 0) {
+            b.append(" native");
+        }
+        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
+            b.append(" abstract");
+        }
+        if ((access & Opcodes.ACC_STRICT) != 0) {
+            b.append(" fpstrict");
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
+            b.append(" synthetic");
+        }
+        if ((access & Opcodes.ACC_INTERFACE) != 0) {
+            b.append(" interface");
+        }
+        if ((access & Opcodes.ACC_ANNOTATION) != 0) {
+            b.append(" annotation");
+        }
+        if ((access & Opcodes.ACC_ENUM) != 0) {
+            b.append(" enum");
+        }
+        return b.toString();
+    }
+
+    protected void print(final int opcode) {
+        pw.print(AbstractVisitor.OPCODES[opcode].toLowerCase());
+    }
+
+    protected void print(final Object cst) {
+        if (cst instanceof String) {
+            StringBuffer buf = new StringBuffer();
+            AbstractVisitor.appendString(buf, (String) cst);
+            pw.print(buf.toString());
+        } else if (cst instanceof Float) {
+            Float f = (Float) cst;
+            if (f.isNaN() || f.isInfinite()) {
+                pw.print("0.0"); // TODO Jasmin bug workaround
+            } else {
+                pw.print(f);
+            }
+        } else if (cst instanceof Double) {
+            Double d = (Double) cst;
+            if (d.isNaN() || d.isInfinite()) {
+                pw.print("0.0"); // TODO Jasmin bug workaround
+            } else {
+                pw.print(d);
+            }
+        } else {
+            pw.print(cst);
+        }
+    }
+
+    protected void print(final Label l) {
+        String name = (String) labelNames.get(l);
+        if (name == null) {
+            name = "L" + labelNames.size();
+            labelNames.put(l, name);
+        }
+        pw.print(name);
+    }
+
+    protected void print(final LabelNode l) {
+        print(l.getLabel());
+    }
+
+    protected void printAnnotations(final MemberNode n) {
+        if (n.visibleAnnotations != null) {
+            for (int j = 0; j < n.visibleAnnotations.size(); ++j) {
+                printAnnotation((AnnotationNode) n.visibleAnnotations.get(j),
+                        1,
+                        -1);
+            }
+        }
+        if (n.invisibleAnnotations != null) {
+            for (int j = 0; j < n.invisibleAnnotations.size(); ++j) {
+                printAnnotation((AnnotationNode) n.invisibleAnnotations.get(j),
+                        2,
+                        -1);
+            }
+        }
+    }
+
+    protected void printAnnotation(
+        final AnnotationNode n,
+        final int visible,
+        final int param)
+    {
+        pw.print(".annotation ");
+        if (visible > 0) {
+            if (param == -1) {
+                pw.print(visible == 1 ? "visible " : "invisible ");
+            } else {
+                pw.print(visible == 1 ? "visibleparam " : "invisibleparam ");
+                pw.print(param);
+                pw.print(' ');
+            }
+            pw.print(n.desc);
+        }
+        pw.println();
+        if (n.values != null) {
+            for (int i = 0; i < n.values.size(); i += 2) {
+                pw.print(n.values.get(i));
+                pw.print(' ');
+                printAnnotationValue(n.values.get(i + 1));
+            }
+        }
+        pw.println(".end annotation");
+    }
+
+    protected void printAnnotationValue(final Object value) {
+        if (value instanceof String[]) {
+            pw.print("e ");
+            pw.print(((String[]) value)[0]);
+            pw.print(" = ");
+            print(((String[]) value)[1]);
+            pw.println();
+        } else if (value instanceof AnnotationNode) {
+            pw.print("@ ");
+            pw.print(((AnnotationNode) value).desc);
+            pw.print(" = ");
+            printAnnotation((AnnotationNode) value, 0, -1);
+        } else if (value instanceof byte[]) {
+            pw.print("[B = ");
+            byte[] v = (byte[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(v[i]);
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof boolean[]) {
+            pw.print("[Z = ");
+            boolean[] v = (boolean[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(v[i] ? '1' : '0');
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof short[]) {
+            pw.print("[S = ");
+            short[] v = (short[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(v[i]);
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof char[]) {
+            pw.print("[C = ");
+            char[] v = (char[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(new Integer(v[i]));
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof int[]) {
+            pw.print("[I = ");
+            int[] v = (int[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(v[i]);
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof long[]) {
+            pw.print("[J = ");
+            long[] v = (long[]) value;
+            for (int i = 0; i < v.length; i++) {
+                pw.print(v[i]);
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof float[]) {
+            pw.print("[F = ");
+            float[] v = (float[]) value;
+            for (int i = 0; i < v.length; i++) {
+                print(new Float(v[i]));
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof double[]) {
+            pw.print("[D = ");
+            double[] v = (double[]) value;
+            for (int i = 0; i < v.length; i++) {
+                print(new Double(v[i]));
+                pw.print(' ');
+            }
+            pw.println();
+        } else if (value instanceof List) {
+            List l = (List) value;
+            if (l.size() > 0) {
+                Object o = l.get(0);
+                if (o instanceof String[]) {
+                    pw.print("[e ");
+                    pw.print(((String[]) o)[0]);
+                    pw.print(" = ");
+                } else if (o instanceof AnnotationNode) {
+                    pw.print("[& ");
+                    pw.print(((AnnotationNode) o).desc);
+                    pw.print(" = ");
+                    pw.print("[@ = ");
+                } else if (o instanceof String) {
+                    pw.print("[s = ");
+                } else if (o instanceof Byte) {
+                    pw.print("[B = ");
+                } else if (o instanceof Boolean) {
+                    pw.print("[Z = ");
+                } else if (o instanceof Character) {
+                    pw.print("[C = ");
+                } else if (o instanceof Short) {
+                    pw.print("[S = ");
+                } else if (o instanceof Type) {
+                    pw.print("[c = ");
+                } else if (o instanceof Integer) {
+                    pw.print("[I = ");
+                } else if (o instanceof Float) {
+                    pw.print("[F = ");
+                } else if (o instanceof Long) {
+                    pw.print("[J = ");
+                } else if (o instanceof Double) {
+                    pw.print("[D = ");
+                }
+                for (int j = 0; j < l.size(); ++j) {
+                    printAnnotationArrayValue(l.get(j));
+                    pw.print(' ');
+                }
+            } else {
+                pw.print("; empty array annotation value");
+            }
+            pw.println();
+        } else if (value instanceof String) {
+            pw.print("s = ");
+            print(value);
+            pw.println();
+        } else if (value instanceof Byte) {
+            pw.print("B = ");
+            pw.println(((Byte) value).intValue());
+        } else if (value instanceof Boolean) {
+            pw.print("Z = ");
+            pw.println(((Boolean) value).booleanValue() ? 1 : 0);
+        } else if (value instanceof Character) {
+            pw.print("C = ");
+            pw.println(new Integer(((Character) value).charValue()));
+        } else if (value instanceof Short) {
+            pw.print("S = ");
+            pw.println(((Short) value).intValue());
+        } else if (value instanceof Type) {
+            pw.print("c = ");
+            pw.println(((Type) value).getDescriptor());
+        } else if (value instanceof Integer) {
+            pw.print("I = ");
+            print(value);
+            pw.println();
+        } else if (value instanceof Float) {
+            pw.print("F = ");
+            print(value);
+            pw.println();
+        } else if (value instanceof Long) {
+            pw.print("J = ");
+            print(value);
+            pw.println();
+        } else if (value instanceof Double) {
+            pw.print("D = ");
+            print(value);
+            pw.println();
+        } else {
+            throw new RuntimeException();
+        }
+    }
+
+    protected void printAnnotationArrayValue(final Object value) {
+        if (value instanceof String[]) {
+            print(((String[]) value)[1]);
+        } else if (value instanceof AnnotationNode) {
+            printAnnotation((AnnotationNode) value, 0, -1);
+        } else if (value instanceof String) {
+            print(value);
+        } else if (value instanceof Byte) {
+            pw.print(((Byte) value).intValue());
+        } else if (value instanceof Boolean) {
+            pw.print(((Boolean) value).booleanValue() ? 1 : 0);
+        } else if (value instanceof Character) {
+            pw.print(new Integer(((Character) value).charValue()));
+        } else if (value instanceof Short) {
+            pw.print(((Short) value).intValue());
+        } else if (value instanceof Type) {
+            pw.print(((Type) value).getDescriptor());
+        } else {
+            print(value);
+        }
+    }
+
+    protected void printFrameType(final Object type) {
+        if (type == Opcodes.TOP) {
+            pw.print("Top");
+        } else if (type == Opcodes.INTEGER) {
+            pw.print("Integer");
+        } else if (type == Opcodes.FLOAT) {
+            pw.print("Float");
+        } else if (type == Opcodes.LONG) {
+            pw.print("Long");
+        } else if (type == Opcodes.DOUBLE) {
+            pw.print("Double");
+        } else if (type == Opcodes.NULL) {
+            pw.print("Null");
+        } else if (type == Opcodes.UNINITIALIZED_THIS) {
+            pw.print("UninitializedThis");
+        } else if (type instanceof Label) {
+            pw.print("Uninitialized ");
+            print((Label) type);
+        } else {
+            pw.print("Object ");
+            pw.print(type);
+        }
+    }
+}
diff -uNr asm-3.1.orig/examples/jasmin/test/JasminifierClassAdapterTest.java asm-3.1/examples/jasmin/test/JasminifierClassAdapterTest.java
--- asm-3.1.orig/examples/jasmin/test/JasminifierClassAdapterTest.java	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/examples/jasmin/test/JasminifierClassAdapterTest.java	2009-01-27 12:44:22.000000000 +0900
@@ -0,0 +1,316 @@
+/***
+ * ASM tests
+ * Copyright (c) 2002-2005 France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+import jas.jasError;
+import jasmin.ClassFile;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.PrintWriter;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.ByteVector;
+import org.objectweb.asm.ClassAdapter;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.util.TraceClassVisitor;
+
+class ClassFilter extends ClassAdapter {
+
+    public ClassFilter() {
+        super(null);
+    }
+
+    public void setNext(final ClassVisitor cv) {
+        this.cv = cv;
+    }
+}
+
+class Comment extends Attribute {
+
+    public Comment() {
+        super("Comment");
+    }
+
+    public boolean isUnknown() {
+        return false;
+    }
+
+    protected Attribute read(
+        final ClassReader cr,
+        final int off,
+        final int len,
+        final char[] buf,
+        final int codeOff,
+        final Label[] labels)
+    {
+
+        return new Comment();
+    }
+
+    protected ByteVector write(
+        final ClassWriter cw,
+        final byte[] code,
+        final int len,
+        final int maxStack,
+        final int maxLocals)
+    {
+        return new ByteVector();
+    }
+}
+
+class CodeComment extends Attribute {
+
+    public CodeComment() {
+        super("CodeComment");
+    }
+
+    public boolean isUnknown() {
+        return false;
+    }
+
+    public boolean isCodeAttribute() {
+        return true;
+    }
+
+    protected Attribute read(
+        final ClassReader cr,
+        final int off,
+        final int len,
+        final char[] buf,
+        final int codeOff,
+        final Label[] labels)
+    {
+        return new CodeComment();
+    }
+
+    protected ByteVector write(
+        final ClassWriter cw,
+        final byte[] code,
+        final int len,
+        final int maxStack,
+        final int maxLocals)
+    {
+        return new ByteVector();
+    }
+
+    protected Label[] getLabels() {
+        super.getLabels();
+        return new Label[] { new Label() };
+    }
+}
+
+/**
+ * JasminifierAdapterTest tests.
+ *
+ * @author Eric Bruneton
+ */
+public class JasminifierClassAdapterTest extends TestCase {
+
+    protected String n;
+
+    protected InputStream is;
+
+    public static TestSuite suite() throws Exception {
+        return new JasminifierClassAdapterTest().getSuite();
+    }
+
+    public JasminifierClassAdapterTest() {
+        super("test");
+    }
+
+    protected void init(final String n, final InputStream is) {
+        this.n = n;
+        this.is = is;
+    }
+
+    protected TestSuite getSuite() throws Exception {
+        TestSuite suite = new TestSuite(getClass().getName());
+        String files = System.getProperty("asm.test") + ",";
+        String clazz = System.getProperty("asm.test.class");
+        String partcount = System.getProperty("parts");
+        String partid = System.getProperty("part");
+        int parts = partcount == null ? 1 : Integer.parseInt(partcount);
+        int part = partid == null ? 0 : Integer.parseInt(partid);
+        int id = 0;
+        while (files.indexOf(',') != -1) {
+            String file = files.substring(0, files.indexOf(','));
+            files = files.substring(files.indexOf(',') + 1);
+            File f = new File(file);
+            if (f.isDirectory()) {
+                scanDirectory("", f, suite, clazz);
+            } else {
+                ZipFile zip = new ZipFile(file);
+                Enumeration entries = zip.entries();
+                while (entries.hasMoreElements()) {
+                    ZipEntry e = (ZipEntry) entries.nextElement();
+                    String n = e.getName();
+                    String p = n.replace('/', '.');
+                System.out.println(n+" "+clazz);
+                    if (n.endsWith(".class") && (clazz == null || p.indexOf(clazz) != -1)) {
+                        n = p.substring(0, p.length() - 6);
+                        if (id % parts == part) {
+                            JasminifierClassAdapterTest t;
+                            InputStream is = zip.getInputStream(e);
+                            t = new JasminifierClassAdapterTest();
+                            t.init(n, is);
+                            suite.addTest(t);
+                        }
+                        ++id;
+                    }
+                }
+            }
+        }
+        return suite;
+    }
+
+    private void scanDirectory(
+        final String path,
+        final File f,
+        final TestSuite suite,
+        final String clazz) throws Exception
+    {
+        File[] fs = f.listFiles();
+        for (int i = 0; i < fs.length; ++i) {
+            String n = fs[i].getName();
+            String qn = path.length() == 0 ? n : path + "." + n;
+            if (fs[i].isDirectory()) {
+                scanDirectory(qn,
+                        fs[i],
+                        suite,
+                        clazz);
+            } else if (qn.endsWith(".class") && (clazz == null || qn.indexOf(clazz) != -1))
+            {
+                qn = qn.substring(0, qn.length() - 6);
+                InputStream is = new FileInputStream(fs[i]);
+                JasminifierClassAdapterTest t;
+                t = new JasminifierClassAdapterTest();
+                t.init(qn, is);
+                suite.addTest(t);
+            }
+        }
+    }
+
+    public void assertEquals(final ClassReader cr1, final ClassReader cr2)
+            throws Exception
+    {
+        assertEquals(cr1, cr2, null, null);
+    }
+
+    public void assertEquals(
+        final ClassReader cr1,
+        final ClassReader cr2,
+        final ClassFilter filter1,
+        final ClassFilter filter2) throws Exception
+    {
+        if (!Arrays.equals(cr1.b, cr2.b)) {
+            StringWriter sw1 = new StringWriter();
+            StringWriter sw2 = new StringWriter();
+            ClassVisitor cv1 = new TraceClassVisitor(new PrintWriter(sw1));
+            ClassVisitor cv2 = new TraceClassVisitor(new PrintWriter(sw2));
+            if (filter1 != null) {
+                filter1.setNext(cv1);
+            }
+            if (filter2 != null) {
+                filter2.setNext(cv2);
+            }
+            cr1.accept(filter1 == null ? cv1 : filter1, 0);
+            cr2.accept(filter2 == null ? cv2 : filter2, 0);
+            String s1 = sw1.toString();
+            String s2 = sw2.toString();
+            assertEquals("different data", s1, s2);
+        }
+    }
+
+    public String getName() {
+        return super.getName() + ": " + n;
+    }
+
+    public void test() throws Exception {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        ClassReader cr = new ClassReader(is);
+        ClassWriter cw = new ClassWriter(0);
+        ClassVisitor cv = new JasminifierClassAdapter(pw, cw);
+        cr.accept(cv,
+                new Attribute[] { new Comment(), new CodeComment() },
+                ClassReader.EXPAND_FRAMES);
+        pw.close();
+        String jasmin = sw.toString();
+
+        ClassFile cf = new ClassFile();
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        cf.readJasmin(new StringReader(jasmin), "test", false);
+        if (cf.errorCount() != 0) {
+            throw new jasError();
+        }
+        cf.write(bos);
+        bos.close();
+
+        assertEquals(cr,
+                new ClassReader(bos.toByteArray()),
+                new ClassFilter() {
+
+                    @Override
+                    public void visit(
+                        int version,
+                        int access,
+                        String name,
+                        String signature,
+                        String superName,
+                        String[] interfaces)
+                    {
+                        access |= Opcodes.ACC_SUPER; // Jasmin bug workaround
+                        super.visit(version,
+                                access,
+                                name,
+                                signature,
+                                superName,
+                                interfaces);
+                    }
+
+                },
+                null);
+    }
+}
diff -uNr asm-3.1.orig/examples/jasmin/test/build.xml asm-3.1/examples/jasmin/test/build.xml
--- asm-3.1.orig/examples/jasmin/test/build.xml	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/examples/jasmin/test/build.xml	2009-01-27 12:44:22.000000000 +0900
@@ -0,0 +1,44 @@
+<project name="jasmin" default="test">
+
+  <condition property="asm.test" value="${java.home}/lib/rt.jar">
+    <not><isset property="asm.test"/></not>
+  </condition>
+
+  <condition property="asm.test.class" value="">
+    <not><isset property="asm.test.class"/></not>
+  </condition>
+
+  <path id="classpath">
+    <fileset dir="${basedir}/../../../lib">
+      <include name="*.jar"/>
+    </fileset>
+    <pathelement location="${basedir}/jasmin.jar"/>
+    <pathelement location="${basedir}/../build"/>
+  </path>
+
+  <target name="compile">
+    <javac srcdir="${basedir}" destdir="${basedir}" debug="on">
+      <classpath refid="classpath"/>
+      <include name="*.java"/>
+    </javac>
+  </target>
+
+  <target name="test" depends="compile">
+    <junit fork="yes" 
+           printsummary="yes"
+           errorproperty="test.failed"
+           failureproperty="test.failed">
+      <batchtest fork="yes" todir="${basedir}">
+        <fileset dir="${basedir}">
+          <include name="JasminifierClassAdapterTest.java"/>
+          <include name="JasminifierClassAdapterUnitTest.java"/>
+        </fileset>
+      </batchtest>
+      <formatter type="xml"/>
+      <classpath refid="classpath"/>
+      <jvmarg value="-Dasm.test=${asm.test}"/>
+      <jvmarg value="-Dasm.test.class=${asm.test.class}"/>
+    </junit>  
+  </target>
+
+</project>
diff -uNr asm-3.1.orig/findbugsExclude.xml asm-3.1/findbugsExclude.xml
--- asm-3.1.orig/findbugsExclude.xml	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/findbugsExclude.xml	2009-01-27 13:02:31.000000000 +0900
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<FindBugsFilter>
+  <Match>
+    <Bug pattern="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"/>
+  </Match>
+  <Match>
+    <Bug category="MALICIOUS_CODE"/>
+  </Match>
+  <Match>
+    <BugCode name="Se"/>
+  </Match>
+  <!-- we can exclude tests too, but bug may appear also in the test code...
+  <Match>
+    <Class name="~.*Test.*"/>
+  </Match>
+  -->
+  <Match>
+    <Class name="Adapt"/>
+  </Match>
+  <Match>
+    <Class name="Analysis"/>
+  </Match>
+  <Match>
+    <Class name="jbfc"/>
+  </Match>
+</FindBugsFilter>
diff -uNr asm-3.1.orig/jdoc/user.xml asm-3.1/jdoc/user.xml
--- asm-3.1.orig/jdoc/user.xml	2006-10-28 03:50:41.000000000 +0900
+++ asm-3.1/jdoc/user.xml	2009-01-27 12:44:23.000000000 +0900
@@ -14,7 +14,8 @@
     <mkdir dir="${jdoc.dir}"/>
     <javadoc destdir="${jdoc.dir}"
              windowtitle="ASM ${product.version} Documentation"
-             doctitle="ASM ${product.version} Documentation">
+             doctitle="ASM ${product.version} Documentation"
+             use="true">
 
       <sourcepath path="${src}"/>
       <package name="org.objectweb.asm"/>
diff -uNr asm-3.1.orig/src/org/objectweb/asm/Frame.java asm-3.1/src/org/objectweb/asm/Frame.java
--- asm-3.1.orig/src/org/objectweb/asm/Frame.java	2007-10-27 19:32:44.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/Frame.java	2009-01-27 12:44:26.000000000 +0900
@@ -115,9 +115,18 @@
     static final int KIND = 0xF000000;
 
     /**
+     * Flag used for LOCAL and STACK types. Indicates that if this type happens
+     * to be a long or double type (during the computations of input frames), 
+     * then it must be set to TOP because the second word of this value has
+     * been reused to store other data in the basic block. Hence the first word 
+     * no longer stores a valid long or double value.
+     */
+    static final int TOP_IF_LONG_OR_DOUBLE = 0x8FFFFF;
+
+    /**
      * Mask to get the value of a frame type.
      */
-    static final int VALUE = 0xFFFFFF;
+    static final int VALUE = 0x7FFFFF;
 
     /**
      * Mask to get the kind of base types.
@@ -710,7 +719,7 @@
     private void pop(final String desc) {
         char c = desc.charAt(0);
         if (c == '(') {
-            pop((MethodWriter.getArgumentsAndReturnSizes(desc) >> 2) - 1);
+            pop((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
         } else if (c == 'J' || c == 'D') {
             pop(2);
         } else {
@@ -936,6 +945,8 @@
                     // if t2 is of kind STACK or LOCAL we cannot know its size!
                     if (t2 == LONG || t2 == DOUBLE) {
                         set(arg - 1, TOP);
+                    } else if ((t2 & KIND) != BASE) {
+                        set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
                     }
                 }
                 break;
@@ -950,6 +961,8 @@
                     // if t2 is of kind STACK or LOCAL we cannot know its size!
                     if (t2 == LONG || t2 == DOUBLE) {
                         set(arg - 1, TOP);
+                    } else if ((t2 & KIND) != BASE) {
+                        set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
                     }
                 }
                 break;
@@ -1263,12 +1276,17 @@
                 } else {
                     dim = s & DIM;
                     kind = s & KIND;
-                    if (kind == LOCAL) {
-                        t = dim + inputLocals[s & VALUE];
-                    } else if (kind == STACK) {
-                        t = dim + inputStack[nStack - (s & VALUE)];
-                    } else {
+                    if (kind == BASE) {
                         t = s;
+                    } else {
+                        if (kind == LOCAL) {
+                            t = dim + inputLocals[s & VALUE];
+                        } else {
+                            t = dim + inputStack[nStack - (s & VALUE)];
+                        }
+                        if ((s & TOP_IF_LONG_OR_DOUBLE) != 0 && (t == LONG || t == DOUBLE)) {
+                            t = TOP;
+                        }
                     }
                 }
             } else {
@@ -1310,12 +1328,17 @@
             s = outputStack[i];
             dim = s & DIM;
             kind = s & KIND;
-            if (kind == LOCAL) {
-                t = dim + inputLocals[s & VALUE];
-            } else if (kind == STACK) {
-                t = dim + inputStack[nStack - (s & VALUE)];
-            } else {
+            if (kind == BASE) {
                 t = s;
+            } else {
+                if (kind == LOCAL) {
+                    t = dim + inputLocals[s & VALUE];
+                } else {
+                    t = dim + inputStack[nStack - (s & VALUE)];
+                }
+                if ((s & TOP_IF_LONG_OR_DOUBLE) != 0 && (t == LONG || t == DOUBLE)) {
+                    t = TOP;
+                }
             }
             if (initializations != null) {
                 t = init(cw, t);
diff -uNr asm-3.1.orig/src/org/objectweb/asm/Label.java asm-3.1/src/org/objectweb/asm/Label.java
--- asm-3.1.orig/src/org/objectweb/asm/Label.java	2007-10-27 19:32:44.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/Label.java	2009-01-27 12:44:26.000000000 +0900
@@ -31,7 +31,10 @@
 
 /**
  * A label represents a position in the bytecode of a method. Labels are used
- * for jump, goto, and switch instructions, and for try catch blocks.
+ * for jump, goto, and switch instructions, and for try catch blocks. A label
+ * designates the <i>instruction</i> that is just after. Note however that
+ * there can be other elements between a label and the instruction it 
+ * designates (such as other labels, stack map frames, line numbers, etc.).
  * 
  * @author Eric Bruneton
  */
@@ -228,7 +231,8 @@
     /**
      * The next basic block in the basic block stack. This stack is used in the
      * main loop of the fix point algorithm used in the second step of the
-     * control flow analysis algorithms.
+     * control flow analysis algorithms. It is also used in 
+     * {@link #visitSubroutine} to avoid using a recursive method.
      * 
      * @see MethodWriter#visitMaxs
      */
@@ -463,9 +467,9 @@
     
     /**
      * Finds the basic blocks that belong to a given subroutine, and marks these
-     * blocks as belonging to this subroutine. This recursive method follows the
-     * control flow graph to find all the blocks that are reachable from the
-     * current block WITHOUT following any JSR target.
+     * blocks as belonging to this subroutine. This method follows the control
+     * flow graph to find all the blocks that are reachable from the current
+     * block WITHOUT following any JSR target.
      * 
      * @param JSR a JSR block that jumps to this subroutine. If this JSR is not
      *        null it is added to the successor of the RET blocks found in the
@@ -475,39 +479,53 @@
      */
     void visitSubroutine(final Label JSR, final long id, final int nbSubroutines)
     {
-        if (JSR != null) {
-            if ((status & VISITED) != 0) {
-                return;
-            }
-            status |= VISITED;
-            // adds JSR to the successors of this block, if it is a RET block
-            if ((status & RET) != 0) {
-                if (!inSameSubroutine(JSR)) {
-                    Edge e = new Edge();
-                    e.info = inputStackTop;
-                    e.successor = JSR.successors.successor;
-                    e.next = successors;
-                    successors = e;
+        // user managed stack of labels, to avoid using a recursive method
+        // (recursivity can lead to stack overflow with very large methods)
+        Label stack = this;
+        while (stack != null) {
+            // removes a label l from the stack
+            Label l = stack;
+            stack = l.next;
+            l.next = null;
+            
+            if (JSR != null) {
+                if ((l.status & VISITED) != 0) {
+                    continue;
                 }
+                l.status |= VISITED;
+                // adds JSR to the successors of l, if it is a RET block
+                if ((l.status & RET) != 0) {
+                    if (!l.inSameSubroutine(JSR)) {
+                        Edge e = new Edge();
+                        e.info = l.inputStackTop;
+                        e.successor = JSR.successors.successor;
+                        e.next = l.successors;
+                        l.successors = e;
+                    }
+                }
+            } else {
+                // if the l block already belongs to subroutine 'id', continue
+                if (l.inSubroutine(id)) {
+                    continue;
+                }
+                // marks the l block as belonging to subroutine 'id'
+                l.addToSubroutine(id, nbSubroutines);            
             }
-        } else {
-            // if this block already belongs to subroutine 'id', returns
-            if (inSubroutine(id)) {
-                return;
-            }
-            // marks this block as belonging to subroutine 'id'
-            addToSubroutine(id, nbSubroutines);            
-        }
-        // calls this method recursively on each successor, except JSR targets
-        Edge e = successors;
-        while (e != null) {
-            // if this block is a JSR block, then 'successors.next' leads
-            // to the JSR target (see {@link #visitJumpInsn}) and must therefore
-            // not be followed
-            if ((status & Label.JSR) == 0 || e != successors.next) {
-                e.successor.visitSubroutine(JSR, id, nbSubroutines);
+            // pushes each successor of l on the stack, except JSR targets
+            Edge e = l.successors;
+            while (e != null) {
+                // if the l block is a JSR block, then 'l.successors.next' leads
+                // to the JSR target (see {@link #visitJumpInsn}) and must 
+                // therefore not be followed
+                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {
+                    // pushes e.successor on the stack if it not already added
+                    if (e.successor.next == null) {
+                        e.successor.next = stack;
+                        stack = e.successor;
+                    }
+                }
+                e = e.next;
             }
-            e = e.next;
         }
     }
 
diff -uNr asm-3.1.orig/src/org/objectweb/asm/MethodWriter.java asm-3.1/src/org/objectweb/asm/MethodWriter.java
--- asm-3.1.orig/src/org/objectweb/asm/MethodWriter.java	2007-10-27 19:32:44.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/MethodWriter.java	2009-01-27 12:44:27.000000000 +0900
@@ -445,7 +445,7 @@
                 this.access |= ACC_CONSTRUCTOR;
             }
             // updates maxLocals
-            int size = getArgumentsAndReturnSizes(descriptor) >> 2;
+            int size = Type.getArgumentsAndReturnSizes(descriptor) >> 2;
             if ((access & Opcodes.ACC_STATIC) != 0) {
                 --size;
             }
@@ -823,7 +823,7 @@
                 if (argSize == 0) {
                     // the above sizes have not been computed yet,
                     // so we compute them...
-                    argSize = getArgumentsAndReturnSizes(desc);
+                    argSize = Type.getArgumentsAndReturnSizes(desc);
                     // ... and we save them in order
                     // not to recompute them in the future
                     i.intVal = argSize;
@@ -844,7 +844,7 @@
         // adds the instruction to the bytecode of the method
         if (itf) {
             if (argSize == 0) {
-                argSize = getArgumentsAndReturnSizes(desc);
+                argSize = Type.getArgumentsAndReturnSizes(desc);
                 i.intVal = argSize;
             }
             code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
@@ -1252,11 +1252,11 @@
                 changed = changed.next;
                 l.next = null;
                 f = l.frame;
-                // a reacheable jump target must be stored in the stack map
+                // a reachable jump target must be stored in the stack map
                 if ((l.status & Label.TARGET) != 0) {
                     l.status |= Label.STORE;
                 }
-                // all visited labels are reacheable, by definition
+                // all visited labels are reachable, by definition
                 l.status |= Label.REACHABLE;
                 // updates the (absolute) maximum stack size
                 int blockMax = f.inputStack.length + l.outputStackMax;
@@ -1277,7 +1277,6 @@
                     e = e.next;
                 }
             }
-            this.maxStack = max;
 
             // visits all the frames that must be stored in the stack map
             Label l = labels;
@@ -1293,6 +1292,7 @@
                     int end = (k == null ? code.length : k.position) - 1;
                     // if non empty basic block
                     if (end >= start) {
+                        max = Math.max(max, 1);
                         // replaces instructions with NOP ... NOP ATHROW
                         for (int i = start; i < end; ++i) {
                             code.data[i] = Opcodes.NOP;
@@ -1307,6 +1307,8 @@
                 }
                 l = l.successor;
             }
+            
+            this.maxStack = max;
         } else if (compute == MAXS) {
             // completes the control flow graph with exception handler blocks
             Handler handler = firstHandler;
@@ -1438,44 +1440,6 @@
     // ------------------------------------------------------------------------
 
     /**
-     * Computes the size of the arguments and of the return value of a method.
-     * 
-     * @param desc the descriptor of a method.
-     * @return the size of the arguments of the method (plus one for the
-     *         implicit this argument), argSize, and the size of its return
-     *         value, retSize, packed into a single int i =
-     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal
-     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).
-     */
-    static int getArgumentsAndReturnSizes(final String desc) {
-        int n = 1;
-        int c = 1;
-        while (true) {
-            char car = desc.charAt(c++);
-            if (car == ')') {
-                car = desc.charAt(c);
-                return n << 2
-                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
-            } else if (car == 'L') {
-                while (desc.charAt(c++) != ';') {
-                }
-                n += 1;
-            } else if (car == '[') {
-                while ((car = desc.charAt(c)) == '[') {
-                    ++c;
-                }
-                if (car == 'D' || car == 'J') {
-                    n -= 1;
-                }
-            } else if (car == 'D' || car == 'J') {
-                n += 2;
-            } else {
-                n += 1;
-            }
-        }
-    }
-
-    /**
      * Adds a successor to the {@link #currentBlock currentBlock} block.
      * 
      * @param info information about the control flow edge to be added.
diff -uNr asm-3.1.orig/src/org/objectweb/asm/Type.java asm-3.1/src/org/objectweb/asm/Type.java
--- asm-3.1.orig/src/org/objectweb/asm/Type.java	2007-10-27 19:32:44.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/Type.java	2009-01-27 12:44:26.000000000 +0900
@@ -328,6 +328,44 @@
     }
 
     /**
+     * Computes the size of the arguments and of the return value of a method.
+     * 
+     * @param desc the descriptor of a method.
+     * @return the size of the arguments of the method (plus one for the
+     *         implicit this argument), argSize, and the size of its return
+     *         value, retSize, packed into a single int i =
+     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal
+     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).
+     */
+    public static int getArgumentsAndReturnSizes(final String desc) {
+        int n = 1;
+        int c = 1;
+        while (true) {
+            char car = desc.charAt(c++);
+            if (car == ')') {
+                car = desc.charAt(c);
+                return n << 2
+                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
+            } else if (car == 'L') {
+                while (desc.charAt(c++) != ';') {
+                }
+                n += 1;
+            } else if (car == '[') {
+                while ((car = desc.charAt(c)) == '[') {
+                    ++c;
+                }
+                if (car == 'D' || car == 'J') {
+                    n -= 1;
+                }
+            } else if (car == 'D' || car == 'J') {
+                n += 2;
+            } else {
+                n += 1;
+            }
+        }
+    }
+
+    /**
      * Returns the Java type corresponding to the given type descriptor.
      * 
      * @param buf a buffer containing a type descriptor.
diff -uNr asm-3.1.orig/src/org/objectweb/asm/commons/GeneratorAdapter.java asm-3.1/src/org/objectweb/asm/commons/GeneratorAdapter.java
--- asm-3.1.orig/src/org/objectweb/asm/commons/GeneratorAdapter.java	2007-10-27 19:32:45.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/commons/GeneratorAdapter.java	2009-01-27 12:44:26.000000000 +0900
@@ -407,7 +407,7 @@
                     break;
                 case Type.CHAR:
                     mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Char",
+                            "java/lang/Character",
                             "TYPE",
                             CLDESC);
                     break;
@@ -834,6 +834,28 @@
     // Instructions to do boxing and unboxing operations
     // ------------------------------------------------------------------------
 
+    private static Type getBoxedType(final Type type) {
+        switch (type.getSort()) {
+            case Type.BYTE:
+                return BYTE_TYPE;
+            case Type.BOOLEAN:
+                return BOOLEAN_TYPE;
+            case Type.SHORT:
+                return SHORT_TYPE;
+            case Type.CHAR:
+                return CHARACTER_TYPE;
+            case Type.INT:
+                return INTEGER_TYPE;
+            case Type.FLOAT:
+                return FLOAT_TYPE;
+            case Type.LONG:
+                return LONG_TYPE;
+            case Type.DOUBLE:
+                return DOUBLE_TYPE;
+        }
+        return type;
+    }
+    
     /**
      * Generates the instructions to box the top stack value. This value is
      * replaced by its boxed equivalent on top of the stack.
@@ -847,33 +869,7 @@
         if (type == Type.VOID_TYPE) {
             push((String) null);
         } else {
-            Type boxed = type;
-            switch (type.getSort()) {
-                case Type.BYTE:
-                    boxed = BYTE_TYPE;
-                    break;
-                case Type.BOOLEAN:
-                    boxed = BOOLEAN_TYPE;
-                    break;
-                case Type.SHORT:
-                    boxed = SHORT_TYPE;
-                    break;
-                case Type.CHAR:
-                    boxed = CHARACTER_TYPE;
-                    break;
-                case Type.INT:
-                    boxed = INTEGER_TYPE;
-                    break;
-                case Type.FLOAT:
-                    boxed = FLOAT_TYPE;
-                    break;
-                case Type.LONG:
-                    boxed = LONG_TYPE;
-                    break;
-                case Type.DOUBLE:
-                    boxed = DOUBLE_TYPE;
-                    break;
-            }
+            Type boxed = getBoxedType(type);
             newInstance(boxed);
             if (type.getSize() == 2) {
                 // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o
@@ -892,6 +888,28 @@
     }
 
     /**
+     * Generates the instructions to box the top stack value using Java 5's
+     * valueOf() method. This value is replaced by its boxed equivalent on top
+     * of the stack.
+     * 
+     * @param type the type of the top stack value.
+     * @author Prashant Deva
+     */
+    public void valueOf(final Type type) {
+        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
+            return;
+        }
+        if (type == Type.VOID_TYPE) {
+            push((String) null);
+        } else {
+            Type boxed = getBoxedType(type);
+            invokeStatic(boxed, new Method("valueOf",
+                    boxed,
+                    new Type[] { type }));
+        }
+    }
+    
+    /**
      * Generates the instructions to unbox the top stack value. This value is
      * replaced by its unboxed equivalent on top of the stack.
      * 
@@ -976,16 +994,15 @@
      * @param label where to jump if the comparison result is <tt>true</tt>.
      */
     public void ifCmp(final Type type, final int mode, final Label label) {
-        int intOp = -1;
         switch (type.getSort()) {
             case Type.LONG:
                 mv.visitInsn(Opcodes.LCMP);
                 break;
             case Type.DOUBLE:
-                mv.visitInsn(Opcodes.DCMPG);
+                mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPG : Opcodes.DCMPL);
                 break;
             case Type.FLOAT:
-                mv.visitInsn(Opcodes.FCMPG);
+                mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPG : Opcodes.FCMPL);
                 break;
             case Type.ARRAY:
             case Type.OBJECT:
@@ -1000,6 +1017,7 @@
                 throw new IllegalArgumentException("Bad comparison for type "
                         + type);
             default:
+                int intOp = -1;
                 switch (mode) {
                     case EQ:
                         intOp = Opcodes.IF_ICMPEQ;
@@ -1023,16 +1041,7 @@
                 mv.visitJumpInsn(intOp, label);
                 return;
         }
-        int jumpMode = mode;
-        switch (mode) {
-            case GE:
-                jumpMode = LT;
-                break;
-            case LE:
-                jumpMode = GT;
-                break;
-        }
-        mv.visitJumpInsn(jumpMode, label);
+        mv.visitJumpInsn(mode, label);
     }
 
     /**
@@ -1477,6 +1486,10 @@
         final Label end,
         final Type exception)
     {
-        mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());
+        if (exception == null) {
+            mv.visitTryCatchBlock(start, end, mark(), null);            
+        } else {
+            mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());
+        }
     }
 }
diff -uNr asm-3.1.orig/src/org/objectweb/asm/commons/Method.java asm-3.1/src/org/objectweb/asm/commons/Method.java
--- asm-3.1.orig/src/org/objectweb/asm/commons/Method.java	2007-10-27 19:32:45.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/commons/Method.java	2009-01-27 12:44:26.000000000 +0900
@@ -96,8 +96,30 @@
     {
         this(name, Type.getMethodDescriptor(returnType, argumentTypes));
     }
+    
+    /**
+     * Creates a new {@link Method}.
+     * 
+     * @param m a java.lang.reflect method descriptor
+     * @return a {@link Method} corresponding to the given Java method
+     *         declaration.
+     */
+    public static Method getMethod(java.lang.reflect.Method m) {
+        return new Method(m.getName(), Type.getMethodDescriptor(m));
+    }
 
     /**
+     * Creates a new {@link Method}.
+     * 
+     * @param c a java.lang.reflect constructor descriptor
+     * @return a {@link Method} corresponding to the given Java constructor
+     *         declaration.
+     */
+    public static Method getMethod(java.lang.reflect.Constructor c) {
+        return new Method("<init>", Type.getConstructorDescriptor(c));
+    }
+    
+    /**
      * Returns a {@link Method} corresponding to the given Java method
      * declaration.
      * 
diff -uNr asm-3.1.orig/src/org/objectweb/asm/optimizer/shrink.properties asm-3.1/src/org/objectweb/asm/optimizer/shrink.properties
--- asm-3.1.orig/src/org/objectweb/asm/optimizer/shrink.properties	2007-10-27 19:32:45.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/optimizer/shrink.properties	2009-01-27 12:44:27.000000000 +0900
@@ -253,7 +253,6 @@
 
 org/objectweb/asm/MethodWriter.visitSwitchInsn(Lorg/objectweb/asm/Label;[Lorg/objectweb/asm/Label;)V=a
 org/objectweb/asm/MethodWriter.addSuccessor(ILorg/objectweb/asm/Label;)V=a
-org/objectweb/asm/MethodWriter.getArgumentsAndReturnSizes(Ljava/lang/String;)I=a
 org/objectweb/asm/MethodWriter.getNewOffset([I[III)I=a
 org/objectweb/asm/MethodWriter.getSize()I=a
 org/objectweb/asm/MethodWriter.put(Lorg/objectweb/asm/ByteVector;)V=a
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/MethodNode.java asm-3.1/src/org/objectweb/asm/tree/MethodNode.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/MethodNode.java	2007-10-27 18:51:36.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/MethodNode.java	2009-01-27 12:44:26.000000000 +0900
@@ -472,7 +472,8 @@
         if (instructions.size() > 0) {
             mv.visitCode();
             // visits try catch blocks
-            for (i = 0; i < tryCatchBlocks.size(); ++i) {
+            n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();
+            for (i = 0; i < n; ++i) {
                 ((TryCatchBlockNode) tryCatchBlocks.get(i)).accept(mv);
             }
             // visits instructions
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Analyzer.java asm-3.1/src/org/objectweb/asm/tree/analysis/Analyzer.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Analyzer.java	2007-10-27 19:32:46.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/Analyzer.java	2009-01-27 12:44:26.000000000 +0900
@@ -151,6 +151,7 @@
         // initializes the data structures for the control flow analysis
         Frame current = newFrame(m.maxLocals, m.maxStack);
         Frame handler = newFrame(m.maxLocals, m.maxStack);
+        current.setReturn(interpreter.newValue(Type.getReturnType(m.desc)));
         Type[] args = Type.getArgumentTypes(m.desc);
         int local = 0;
         if ((m.access & ACC_STATIC) == 0) {
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/BasicInterpreter.java asm-3.1/src/org/objectweb/asm/tree/analysis/BasicInterpreter.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/BasicInterpreter.java	2007-10-27 18:51:36.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/BasicInterpreter.java	2009-01-27 12:44:26.000000000 +0900
@@ -76,7 +76,9 @@
         }
     }
 
-    public Value newOperation(final AbstractInsnNode insn) {
+    public Value newOperation(final AbstractInsnNode insn)
+            throws AnalyzerException
+    {
         switch (insn.getOpcode()) {
             case ACONST_NULL:
                 return newValue(Type.getObjectType("null"));
@@ -312,6 +314,13 @@
         }
     }
 
+    public void returnOperation(
+        final AbstractInsnNode insn,
+        final Value value,
+        final Value expected) throws AnalyzerException
+    {
+    }
+    
     public Value merge(final Value v, final Value w) {
         if (!v.equals(w)) {
             return BasicValue.UNINITIALIZED_VALUE;
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/BasicVerifier.java asm-3.1/src/org/objectweb/asm/tree/analysis/BasicVerifier.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/BasicVerifier.java	2007-10-27 19:32:46.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/BasicVerifier.java	2009-01-27 12:44:26.000000000 +0900
@@ -407,6 +407,18 @@
         return super.naryOperation(insn, values);
     }
 
+    public void returnOperation(
+        final AbstractInsnNode insn,
+        final Value value,
+        final Value expected) throws AnalyzerException
+    {
+        if (!isSubTypeOf(value, expected)) {
+            throw new AnalyzerException("Incompatible return type",
+                    expected,
+                    value);
+        }
+    }
+
     protected boolean isArrayValue(final Value value) {
         return ((BasicValue) value).isReference();
     }
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Frame.java asm-3.1/src/org/objectweb/asm/tree/analysis/Frame.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Frame.java	2007-10-27 18:51:36.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/Frame.java	2009-01-27 12:44:26.000000000 +0900
@@ -51,6 +51,12 @@
 public class Frame {
 
     /**
+     * The expected return type of the analyzed method, or <tt>null</tt> if the
+     * method returns void.
+     */
+    private Value returnValue;
+
+    /**
      * The local variables and operand stack of this frame.
      */
     private Value[] values;
@@ -93,12 +99,23 @@
      * @return this frame.
      */
     public Frame init(final Frame src) {
+        returnValue = src.returnValue;
         System.arraycopy(src.values, 0, values, 0, values.length);
         top = src.top;
         return this;
     }
 
     /**
+     * Sets the expected return type of the analyzed method.
+     * 
+     * @param v the expected return type of the analyzed method, or
+     *        <tt>null</tt> if the method returns void.
+     */
+    public void setReturn(final Value v) {
+        returnValue = v;
+    }
+    
+    /**
      * Returns the maximum number of local variables of this frame.
      * 
      * @return the maximum number of local variables of this frame.
@@ -291,7 +308,7 @@
                 if (value1.getSize() != 1) {
                     throw new AnalyzerException("Illegal use of DUP");
                 }
-                push(interpreter.copyOperation(insn, value1));
+                push(value1);
                 push(interpreter.copyOperation(insn, value1));
                 break;
             case Opcodes.DUP_X1:
@@ -301,8 +318,8 @@
                     throw new AnalyzerException("Illegal use of DUP_X1");
                 }
                 push(interpreter.copyOperation(insn, value1));
-                push(interpreter.copyOperation(insn, value2));
-                push(interpreter.copyOperation(insn, value1));
+                push(value2);
+                push(value1);
                 break;
             case Opcodes.DUP_X2:
                 value1 = pop();
@@ -312,15 +329,15 @@
                         value3 = pop();
                         if (value3.getSize() == 1) {
                             push(interpreter.copyOperation(insn, value1));
-                            push(interpreter.copyOperation(insn, value3));
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
+                            push(value3);
+                            push(value2);
+                            push(value1);
                             break;
                         }
                     } else {
                         push(interpreter.copyOperation(insn, value1));
-                        push(interpreter.copyOperation(insn, value2));
-                        push(interpreter.copyOperation(insn, value1));
+                        push(value2);
+                        push(value1);
                         break;
                     }
                 }
@@ -330,14 +347,14 @@
                 if (value1.getSize() == 1) {
                     value2 = pop();
                     if (value2.getSize() == 1) {
-                        push(interpreter.copyOperation(insn, value2));
-                        push(interpreter.copyOperation(insn, value1));
+                        push(value2);
+                        push(value1);
                         push(interpreter.copyOperation(insn, value2));
                         push(interpreter.copyOperation(insn, value1));
                         break;
                     }
                 } else {
-                    push(interpreter.copyOperation(insn, value1));
+                    push(value1);
                     push(interpreter.copyOperation(insn, value1));
                     break;
                 }
@@ -351,9 +368,9 @@
                         if (value3.getSize() == 1) {
                             push(interpreter.copyOperation(insn, value2));
                             push(interpreter.copyOperation(insn, value1));
-                            push(interpreter.copyOperation(insn, value3));
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
+                            push(value3);
+                            push(value2);
+                            push(value1);
                             break;
                         }
                     }
@@ -361,8 +378,8 @@
                     value2 = pop();
                     if (value2.getSize() == 1) {
                         push(interpreter.copyOperation(insn, value1));
-                        push(interpreter.copyOperation(insn, value2));
-                        push(interpreter.copyOperation(insn, value1));
+                        push(value2);
+                        push(value1);
                         break;
                     }
                 }
@@ -378,18 +395,18 @@
                             if (value4.getSize() == 1) {
                                 push(interpreter.copyOperation(insn, value2));
                                 push(interpreter.copyOperation(insn, value1));
-                                push(interpreter.copyOperation(insn, value4));
-                                push(interpreter.copyOperation(insn, value3));
-                                push(interpreter.copyOperation(insn, value2));
-                                push(interpreter.copyOperation(insn, value1));
+                                push(value4);
+                                push(value3);
+                                push(value2);
+                                push(value1);
                                 break;
                             }
                         } else {
                             push(interpreter.copyOperation(insn, value2));
                             push(interpreter.copyOperation(insn, value1));
-                            push(interpreter.copyOperation(insn, value3));
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
+                            push(value3);
+                            push(value2);
+                            push(value1);
                             break;
                         }
                     }
@@ -399,15 +416,15 @@
                         value3 = pop();
                         if (value3.getSize() == 1) {
                             push(interpreter.copyOperation(insn, value1));
-                            push(interpreter.copyOperation(insn, value3));
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
+                            push(value3);
+                            push(value2);
+                            push(value1);
                             break;
                         }
                     } else {
                         push(interpreter.copyOperation(insn, value1));
-                        push(interpreter.copyOperation(insn, value2));
-                        push(interpreter.copyOperation(insn, value1));
+                        push(value2);
+                        push(value1);
                         break;
                     }
                 }
@@ -526,14 +543,21 @@
                 break;
             case Opcodes.TABLESWITCH:
             case Opcodes.LOOKUPSWITCH:
+                interpreter.unaryOperation(insn, pop());
+                break;
             case Opcodes.IRETURN:
             case Opcodes.LRETURN:
             case Opcodes.FRETURN:
             case Opcodes.DRETURN:
             case Opcodes.ARETURN:
-                interpreter.unaryOperation(insn, pop());
+                value1 = pop();
+                interpreter.unaryOperation(insn, value1);
+                interpreter.returnOperation(insn, value1, returnValue);
                 break;
             case Opcodes.RETURN:
+                if (returnValue != null) {
+                    throw new AnalyzerException("Incompatible return type");
+                }
                 break;
             case Opcodes.GETSTATIC:
                 push(interpreter.newOperation(insn));
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Interpreter.java asm-3.1/src/org/objectweb/asm/tree/analysis/Interpreter.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/Interpreter.java	2007-10-27 18:51:36.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/Interpreter.java	2009-01-27 12:44:26.000000000 +0900
@@ -163,6 +163,20 @@
             throws AnalyzerException;
 
     /**
+     * Interprets a bytecode return instruction. This method is called for the 
+     * following opcodes:
+     * 
+     * IRETURN, LRETURN, FRETURN, DRETURN, ARETURN
+     * 
+     * @param insn the bytecode instruction to be interpreted.
+     * @param value the argument of the instruction to be interpreted.
+     * @param expected the expected return type of the analyzed method.
+     * @throws AnalyzerException if an error occured during the interpretation.
+     */
+    void returnOperation(AbstractInsnNode insn, Value value, Value expected)
+            throws AnalyzerException;
+    
+    /**
      * Merges two values. The merge operation must return a value that
      * represents both values (for instance, if the two values are two types,
      * the merged value must be a common super type of the two types. If the two
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/SimpleVerifier.java asm-3.1/src/org/objectweb/asm/tree/analysis/SimpleVerifier.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/SimpleVerifier.java	2007-10-27 19:32:46.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/SimpleVerifier.java	2009-01-27 12:44:26.000000000 +0900
@@ -64,6 +64,11 @@
     private final boolean isInterface;
 
     /**
+     * The loader to use for referenced classes.
+     */
+    private ClassLoader loader = getClass().getClassLoader();
+
+    /**
      * Constructs a new {@link SimpleVerifier}.
      */
     public SimpleVerifier() {
@@ -108,6 +113,17 @@
         this.isInterface = isInterface;
     }
 
+    /**
+     * Set the <code>ClassLoader</code> which will be used to load referenced
+     * classes. This is useful if you are verifying multiple interdependent
+     * classes.
+     * 
+     * @param loader a <code>ClassLoader</code> to use
+     */
+    public void setClassLoader(final ClassLoader loader) {
+        this.loader = loader;
+    }
+
     public Value newValue(final Type type) {
         if (type == null) {
             return BasicValue.UNINITIALIZED_VALUE;
@@ -274,9 +290,11 @@
     protected Class getClass(final Type t) {
         try {
             if (t.getSort() == Type.ARRAY) {
-                return Class.forName(t.getDescriptor().replace('/', '.'));
+                return Class.forName(t.getDescriptor().replace('/', '.'),
+                        false,
+                        loader);
             }
-            return Class.forName(t.getClassName());
+            return Class.forName(t.getClassName(), false, loader);
         } catch (ClassNotFoundException e) {
             throw new RuntimeException(e.toString());
         }
diff -uNr asm-3.1.orig/src/org/objectweb/asm/tree/analysis/SourceInterpreter.java asm-3.1/src/org/objectweb/asm/tree/analysis/SourceInterpreter.java
--- asm-3.1.orig/src/org/objectweb/asm/tree/analysis/SourceInterpreter.java	2007-10-27 18:51:36.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/tree/analysis/SourceInterpreter.java	2009-01-27 12:44:26.000000000 +0900
@@ -48,6 +48,9 @@
 public class SourceInterpreter implements Opcodes, Interpreter {
 
     public Value newValue(final Type type) {
+        if (type == Type.VOID_TYPE) {
+            return null;
+        }
         return new SourceValue(type == null ? 1 : type.getSize());
     }
 
@@ -152,6 +155,13 @@
         return new SourceValue(size, insn);
     }
 
+    public void returnOperation(
+        final AbstractInsnNode insn,
+        final Value value,
+        final Value expected)
+    {
+    }
+
     public Value merge(final Value v, final Value w) {
         SourceValue dv = (SourceValue) v;
         SourceValue dw = (SourceValue) w;
diff -uNr asm-3.1.orig/src/org/objectweb/asm/util/CheckClassAdapter.java asm-3.1/src/org/objectweb/asm/util/CheckClassAdapter.java
--- asm-3.1.orig/src/org/objectweb/asm/util/CheckClassAdapter.java	2007-10-27 19:32:46.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/util/CheckClassAdapter.java	2009-01-27 12:44:26.000000000 +0900
@@ -31,7 +31,11 @@
 
 import java.io.FileInputStream;
 import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import org.objectweb.asm.AnnotationVisitor;
 import org.objectweb.asm.FieldVisitor;
@@ -137,8 +141,19 @@
      * <tt>true</tt> if the visitEnd method has been called.
      */
     private boolean end;
+    
+    /**
+     * The already visited labels. This map associate Integer values to Label
+     * keys.
+     */
+    private Map labels;
 
     /**
+     * <tt>true</tt> if the method code must be checked with a BasicVerifier.
+     */
+    private boolean checkDataFlow;
+    
+    /**
      * Checks a given class. <p> Usage: CheckClassAdapter &lt;fully qualified
      * class name or class file name&gt;
      * 
@@ -169,27 +184,42 @@
      * 
      * @param cr a <code>ClassReader</code> that contains bytecode for the
      *        analysis.
+     * @param loader a <code>ClassLoader</code> which will be used to load
+     *        referenced classes. This is useful if you are verifiying multiple
+     *        interdependent classes.
      * @param dump true if bytecode should be printed out not only when errors
      *        are found.
      * @param pw write where results going to be printed
      */
     public static void verify(
         final ClassReader cr,
+        final ClassLoader loader,
         final boolean dump,
         final PrintWriter pw)
     {
         ClassNode cn = new ClassNode();
-        cr.accept(new CheckClassAdapter(cn), ClassReader.SKIP_DEBUG);
+        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);
 
         Type syperType = cn.superName == null
                 ? null
                 : Type.getObjectType(cn.superName);
         List methods = cn.methods;
+
+        List interfaces = new ArrayList();
+        for (Iterator i = cn.interfaces.iterator(); i.hasNext();) {
+            interfaces.add(Type.getObjectType(i.next().toString()));
+        }
+
         for (int i = 0; i < methods.size(); ++i) {
             MethodNode method = (MethodNode) methods.get(i);
-            Analyzer a = new Analyzer(new SimpleVerifier(Type.getObjectType(cn.name),
+            SimpleVerifier verifier = new SimpleVerifier(Type.getObjectType(cn.name),
                     syperType,
-                    false));
+                    interfaces,
+                    false);
+            Analyzer a = new Analyzer(verifier);
+            if (loader != null) {
+                verifier.setClassLoader(loader);
+            }
             try {
                 a.analyze(cn.name, method);
                 if (!dump) {
@@ -198,42 +228,66 @@
             } catch (Exception e) {
                 e.printStackTrace(pw);
             }
-            Frame[] frames = a.getFrames();
-
-            TraceMethodVisitor mv = new TraceMethodVisitor();
+            printAnalyzerResult(method, a, pw);
+        }
+        pw.flush();
+    }
+    
+    /**
+     * Checks a given class
+     * 
+     * @param cr a <code>ClassReader</code> that contains bytecode for the
+     *        analysis.
+     * @param dump true if bytecode should be printed out not only when errors
+     *        are found.
+     * @param pw write where results going to be printed
+     */
+    public static void verify(
+        final ClassReader cr,
+        final boolean dump,
+        final PrintWriter pw)
+    {
+        verify(cr, null, dump, pw);
+    }
+    
+    static void printAnalyzerResult(
+        MethodNode method,
+        Analyzer a,
+        final PrintWriter pw)
+    {
+        Frame[] frames = a.getFrames();
+        TraceMethodVisitor mv = new TraceMethodVisitor();
 
-            pw.println(method.name + method.desc);
-            for (int j = 0; j < method.instructions.size(); ++j) {
-                method.instructions.get(j).accept(mv);
-
-                StringBuffer s = new StringBuffer();
-                Frame f = frames[j];
-                if (f == null) {
-                    s.append('?');
-                } else {
-                    for (int k = 0; k < f.getLocals(); ++k) {
-                        s.append(getShortName(f.getLocal(k).toString()))
-                                .append(' ');
-                    }
-                    s.append(" : ");
-                    for (int k = 0; k < f.getStackSize(); ++k) {
-                        s.append(getShortName(f.getStack(k).toString()))
-                                .append(' ');
-                    }
+        pw.println(method.name + method.desc);
+        for (int j = 0; j < method.instructions.size(); ++j) {
+            method.instructions.get(j).accept(mv);
+
+            StringBuffer s = new StringBuffer();
+            Frame f = frames[j];
+            if (f == null) {
+                s.append('?');
+            } else {
+                for (int k = 0; k < f.getLocals(); ++k) {
+                    s.append(getShortName(f.getLocal(k).toString()))
+                            .append(' ');
                 }
-                while (s.length() < method.maxStack + method.maxLocals + 1) {
-                    s.append(' ');
+                s.append(" : ");
+                for (int k = 0; k < f.getStackSize(); ++k) {
+                    s.append(getShortName(f.getStack(k).toString()))
+                            .append(' ');
                 }
-                pw.print(Integer.toString(j + 100000).substring(1));
-                pw.print(" " + s + " : " + mv.buf); // mv.text.get(j));
             }
-            for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
-                ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
-                pw.print(" " + mv.buf);
+            while (s.length() < method.maxStack + method.maxLocals + 1) {
+                s.append(' ');
             }
-            pw.println();
+            pw.print(Integer.toString(j + 100000).substring(1));
+            pw.print(" " + s + " : " + mv.buf); // mv.text.get(j));
         }
-        pw.flush();
+        for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
+            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
+            pw.print(" " + mv.buf);
+        }
+        pw.println();
     }
 
     private static String getShortName(final String name) {
@@ -251,7 +305,21 @@
      * @param cv the class visitor to which this adapter must delegate calls.
      */
     public CheckClassAdapter(final ClassVisitor cv) {
+        this(cv, true);
+    }
+
+    /**
+     * Constructs a new {@link CheckClassAdapter}.
+     * 
+     * @param cv the class visitor to which this adapter must delegate calls.
+     * @param checkDataFlow <tt>true</tt> to perform basic data flow checks, or
+     *        <tt>false</tt> to not perform any data flow check (see
+     *        {@link CheckMethodAdapter}).
+     */
+    public CheckClassAdapter(final ClassVisitor cv, boolean checkDataFlow) {
         super(cv);
+        this.labels = new HashMap();
+        this.checkDataFlow = checkDataFlow;
     }
 
     // ------------------------------------------------------------------------
@@ -403,11 +471,19 @@
                         "exception name at index " + i);
             }
         }
-        return new CheckMethodAdapter(cv.visitMethod(access,
-                name,
-                desc,
-                signature,
-                exceptions));
+        if (checkDataFlow) {
+            return new CheckMethodAdapter(access,
+                    name,
+                    desc,
+                    cv.visitMethod(access, name, desc, signature, exceptions),
+                    labels);
+        } else {
+            return new CheckMethodAdapter(cv.visitMethod(access,
+                    name,
+                    desc,
+                    signature,
+                    exceptions), labels);
+        }
     }
 
     public AnnotationVisitor visitAnnotation(
diff -uNr asm-3.1.orig/src/org/objectweb/asm/util/CheckMethodAdapter.java asm-3.1/src/org/objectweb/asm/util/CheckMethodAdapter.java
--- asm-3.1.orig/src/org/objectweb/asm/util/CheckMethodAdapter.java	2007-10-27 19:32:46.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/util/CheckMethodAdapter.java	2009-01-27 12:44:26.000000000 +0900
@@ -36,19 +36,29 @@
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Attribute;
 import org.objectweb.asm.Type;
-
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.tree.analysis.Analyzer;
+import org.objectweb.asm.tree.analysis.BasicVerifier;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * A {@link MethodAdapter} that checks that its methods are properly used. More
- * precisely this code adapter checks each instruction individually (i.e., each
- * visit method checks some preconditions based <i>only</i> on its arguments -
- * such as the fact that the given opcode is correct for a given visit method),
- * but does <i>not</i> check the <i>sequence</i> of instructions. For example,
- * in a method whose signature is <tt>void m ()</tt>, the invalid instruction
- * IRETURN, or the invalid sequence IADD L2I will <i>not</i> be detected by
- * this code adapter.
+ * precisely this method adapter checks each instruction individually, i.e.,
+ * each visit method checks some preconditions based <i>only</i> on its
+ * arguments - such as the fact that the given opcode is correct for a given
+ * visit method. This adapter can also perform some basic data flow checks (more
+ * precisely those that can be performed without the full class hierarchy - see
+ * {@link org.objectweb.asm.tree.analysis.BasicVerifier}). For instance in a
+ * method whose signature is <tt>void m ()</tt>, the invalid instruction
+ * IRETURN, or the invalid sequence IADD L2I will be detected if the data flow
+ * checks are enabled. These checks are enabled by using the {@link 
+ * CheckMethodAdapter(int,String,String,MethodVisitor,Map)} constructor. They
+ * are not performed if any other constructor is used.
  * 
  * @author Eric Bruneton
  */
@@ -79,6 +89,11 @@
      * Code of the visit method to be used for each opcode.
      */
     private static final int[] TYPE;
+    
+    /**
+     * The Label.status field.
+     */
+    private static Field labelStatusField;
 
     static {
         String s = "BBBBBBBBBBBBBBBBCCIAADDDDDAAAAAAAAAAAAAAAAAAAABBBBBBBBDD"
@@ -304,15 +319,66 @@
     // }
 
     /**
-     * Constructs a new {@link CheckMethodAdapter} object.
+     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
+     * will not perform any data flow check (see {@link 
+     * CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
+     * 
+     * @param mv the method visitor to which this adapter must delegate calls.
+     */
+    public CheckMethodAdapter(final MethodVisitor mv) {
+        this(mv, new HashMap());
+    }
+
+    /**
+     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
+     * will not perform any data flow check (see {@link 
+     * CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
      * 
-     * @param cv the code visitor to which this adapter must delegate calls.
+     * @param mv the method visitor to which this adapter must delegate calls.
+     * @param labels a map of already visited labels (in other methods).
      */
-    public CheckMethodAdapter(final MethodVisitor cv) {
-        super(cv);
-        this.labels = new HashMap();
+    public CheckMethodAdapter(final MethodVisitor mv, final Map labels) {
+        super(mv);
+        this.labels = labels;
     }
 
+    /**
+     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
+     * will perform basic data flow checks. For instance in a method whose
+     * signature is <tt>void m ()</tt>, the invalid instruction IRETURN, or
+     * the invalid sequence IADD L2I will be detected.
+     * 
+     * @param access the method's access flags.
+     * @param name the method's name.
+     * @param desc the method's descriptor (see {@link Type Type}).
+     * @param mv the method visitor to which this adapter must delegate calls.
+     * @param labels a map of already visited labels (in other methods).
+     */
+    public CheckMethodAdapter(
+        final int access,
+        final String name,
+        final String desc,
+        final MethodVisitor mv,
+        final Map labels)
+    {
+        this(new MethodNode(access, name, desc, null, null) {
+            public void visitEnd() {
+                Analyzer a = new Analyzer(new BasicVerifier());
+                try {
+                    a.analyze("dummy", this);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    StringWriter sw = new StringWriter();
+                    PrintWriter pw = new PrintWriter(sw, true);
+                    CheckClassAdapter.printAnalyzerResult(this, a, pw);
+                    pw.close();
+                    throw new RuntimeException(e.getMessage() + sw.toString());
+                }
+                accept(mv);
+            }
+        }, labels);
+    }
+    
     public AnnotationVisitor visitAnnotation(
         final String desc,
         final boolean visible)
@@ -498,6 +564,7 @@
         checkEndCode();
         checkOpcode(opcode, 6);
         checkLabel(label, false, "label");
+        checkNonDebugLabel(label);
         mv.visitJumpInsn(opcode, label);
     }
 
@@ -542,11 +609,13 @@
                     + " must be greater than or equal to min = " + min);
         }
         checkLabel(dflt, false, "default label");
+        checkNonDebugLabel(dflt);
         if (labels == null || labels.length != max - min + 1) {
             throw new IllegalArgumentException("There must be max - min + 1 labels");
         }
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
+            checkNonDebugLabel(labels[i]);
         }
         mv.visitTableSwitchInsn(min, max, dflt, labels);
     }
@@ -559,11 +628,13 @@
         checkEndCode();
         checkStartCode();
         checkLabel(dflt, false, "default label");
+        checkNonDebugLabel(dflt);
         if (keys == null || labels == null || keys.length != labels.length) {
             throw new IllegalArgumentException("There must be the same number of keys and labels");
         }
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
+            checkNonDebugLabel(labels[i]);
         }
         mv.visitLookupSwitchInsn(dflt, keys, labels);
     }
@@ -595,6 +666,15 @@
     {
         checkStartCode();
         checkEndCode();
+        checkLabel(start, false, "start label");
+        checkLabel(end, false, "end label");
+        checkLabel(handler, false, "handler label");
+        checkNonDebugLabel(start);
+        checkNonDebugLabel(end);
+        checkNonDebugLabel(handler);
+        if (labels.get(start) != null || labels.get(end) != null || labels.get(handler) != null) {
+            throw new IllegalStateException("Try catch blocks must be visited before their labels");
+        }
         if (type != null) {
             checkInternalName(type, "type");
         }
@@ -1325,4 +1405,51 @@
                     + " (must be visited first)");
         }
     }
+
+    /**
+     * Checks that the given lavel is not a label used only for debug purposes.
+     * 
+     * @param label the label to be checked.
+     */
+    private static void checkNonDebugLabel(final Label label) {
+        Field f = getLabelStatusField();
+        int status = 0;
+        try {
+            status = f == null ? 0 : ((Integer) f.get(label)).intValue();
+        } catch (IllegalAccessException e) { throw new Error("Internal error"); }
+        if ((status & 0x01) != 0) {
+            throw new IllegalArgumentException("Labels used for debug info cannot be reused for control flow");
+        }
+    }
+    
+    /**
+     * Returns the Field object corresponding to the Label.status field.
+     * 
+     * @return the Field object corresponding to the Label.status field.
+     */
+    private static Field getLabelStatusField() {
+        if (labelStatusField == null) {
+            labelStatusField = getLabelField("a");
+            if (labelStatusField == null) {
+                labelStatusField = getLabelField("status");
+            }
+        }
+        return labelStatusField;
+    }
+    
+    /**
+     * Returns the field of the Label class whose name is given.
+     * 
+     * @param name a field name.
+     * @return the field of the Label class whose name is given, or null.
+     */
+    private static Field getLabelField(final String name) {
+        try {
+            Field f = Label.class.getDeclaredField(name);
+            f.setAccessible(true);
+            return f;
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+    }
 }
diff -uNr asm-3.1.orig/src/org/objectweb/asm/xml/asm-xml.dtd asm-3.1/src/org/objectweb/asm/xml/asm-xml.dtd
--- asm-3.1.orig/src/org/objectweb/asm/xml/asm-xml.dtd	2006-10-28 03:50:41.000000000 +0900
+++ asm-3.1/src/org/objectweb/asm/xml/asm-xml.dtd	2009-01-27 13:07:25.000000000 +0900
@@ -1,340 +1,340 @@
-<!--
-  ASM XML Adapter
-  Copyright (c) 2004, Eugene Kuleshov
-  All rights reserved.
-  
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-  1. Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-  2. Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-  3. Neither the name of the copyright holders nor the names of its
-     contributors may be used to endorse or promote products derived from
-     this software without specific prior written permission.
-  
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
--->
-
-<!--
-  This DTD must be used to create XML documents to be processed by
-  org.objectweb.asm.xml.ASMContentHandler
--->
-
-<!--
-  Root element used to aggregate multiple classes into single document.
--->
-<!ELEMENT classes ( class+ )>
-
-<!--
-  Root element for a single class.
--->
-<!ELEMENT class ( interfaces, ( field | innerclass | method )*)>
-<!ATTLIST class access CDATA #REQUIRED>
-<!ATTLIST class name CDATA #REQUIRED>
-<!ATTLIST class parent CDATA #REQUIRED>
-<!ATTLIST class major CDATA #REQUIRED>
-<!ATTLIST class minor CDATA #REQUIRED>
-<!ATTLIST class source CDATA #IMPLIED>
-
-<!ELEMENT interfaces ( interface* )>
-<!ELEMENT interface EMPTY>
-<!ATTLIST interface name CDATA #REQUIRED>
-
-<!ELEMENT field EMPTY>
-<!ATTLIST field access CDATA #REQUIRED>
-<!ATTLIST field desc CDATA #REQUIRED>
-<!ATTLIST field name CDATA #REQUIRED>
-<!--
-  All characters out of interval 0x20 to 0x7f (inclusive) must
-  be encoded (\uXXXX) and character '\' must be replaced by "\\"
--->
-<!ATTLIST field value CDATA #IMPLIED>
-
-<!ELEMENT innerclass EMPTY>
-<!ATTLIST innerclass access CDATA #REQUIRED>
-<!ATTLIST innerclass innerName CDATA #IMPLIED>
-<!ATTLIST innerclass name CDATA #REQUIRED>
-<!ATTLIST innerclass outerName CDATA #IMPLIED>
-
-<!--
-  Root element for method definition.
--->
-<!ELEMENT method ( exceptions, code? )>
-<!ATTLIST method access CDATA #REQUIRED>
-<!ATTLIST method desc CDATA #REQUIRED>
-<!ATTLIST method name CDATA #REQUIRED>
-
-<!ELEMENT exceptions ( exception* )>
-<!ELEMENT exception EMPTY>
-<!ATTLIST exception name CDATA #REQUIRED>
-
-<!--
-  code element contains bytecode instructions and definitions for labels, line numbers, try/catch and max
--->
-<!ELEMENT code (( AALOAD | AASTORE | ACONST_NULL | ALOAD | ANEWARRAY | ARETURN | ARRAYLENGTH | ASTORE | ATHROW | BALOAD | BASTORE | BIPUSH | CALOAD | CASTORE | CHECKCAST | D2F | D2I | D2L | DADD | DALOAD | DASTORE | DCMPG | DCMPL | DCONST_0 | DCONST_1 | DDIV | DLOAD | DMUL | DNEG | DREM | DRETURN | DSTORE | DSUB | DUP | DUP2 | DUP2_X1 | DUP2_X2 | DUP_X1 | DUP_X2 | F2D | F2I | F2L | FADD | FALOAD | FASTORE | FCMPG | FCMPL | FCONST_0 | FCONST_1 | FCONST_2 | FDIV | FLOAD | FMUL | FNEG | FRETURN | FSTORE | FSUB | GETFIELD | GETSTATIC | GOTO | I2B | I2C | I2D | I2F | I2L | I2S | IADD | IALOAD | IAND | IASTORE | ICONST_0 | ICONST_1 | ICONST_2 | ICONST_3 | ICONST_4 | ICONST_5 | ICONST_M1 | IDIV | IFEQ | IFGE | IFGT | IFLE | IFLT | IFNE | IFNONNULL | IFNULL | IF_ACMPEQ | IF_ACMPNE | IF_ICMPEQ | IF_ICMPGE | IF_ICMPGT | IF_ICMPLE | IF_ICMPLT | IF_ICMPNE | IINC | ILOAD | IMUL | INEG | INSTANCEOF | INVOKEINTERFACE | INVOKESPECIAL | INVOKESTATIC | INVOKEVIRTUAL | IOR | IREM | IRETURN | ISHL | ISHR | ISTORE | ISUB | IUSHR | IXOR | JSR | L2D | L2F | L2I | LADD | LALOAD | LAND | LASTORE | LCMP | LCONST_0 | LCONST_1 | LDC | LDIV | LLOAD | LMUL | LNEG | LOOKUPSWITCH | LOR | LREM | LRETURN | LSHL | LSHR | LSTORE | LSUB | LUSHR | LXOR | MONITORENTER | MONITOREXIT | MULTIANEWARRAY | NEW | NEWARRAY | NOP | POP | POP2 | PUTFIELD | PUTSTATIC | RET | RETURN | SALOAD | SASTORE | SIPUSH | TABLESWITCH | Label | LineNumber | TryCatch )*, Max)>
-
-<!ELEMENT Label EMPTY>
-<!ATTLIST Label name CDATA #REQUIRED>
-
-<!ELEMENT TryCatch EMPTY>
-<!ATTLIST TryCatch end CDATA #REQUIRED>
-<!ATTLIST TryCatch handler CDATA #REQUIRED>
-<!ATTLIST TryCatch start CDATA #REQUIRED>
-<!ATTLIST TryCatch type CDATA #IMPLIED>
-
-<!ELEMENT LineNumber EMPTY>
-<!ATTLIST LineNumber line CDATA #REQUIRED>
-<!ATTLIST LineNumber start CDATA #REQUIRED>
-
-<!ELEMENT Max EMPTY>
-<!ATTLIST Max maxLocals CDATA #REQUIRED>
-<!ATTLIST Max maxStack CDATA #REQUIRED>
-
-<!ELEMENT AALOAD EMPTY>
-<!ELEMENT AASTORE EMPTY>
-<!ELEMENT ACONST_NULL EMPTY>
-<!ELEMENT ALOAD EMPTY>
-<!ATTLIST ALOAD var CDATA #REQUIRED>
-<!ELEMENT ANEWARRAY EMPTY>
-<!ATTLIST ANEWARRAY desc CDATA #REQUIRED>
-<!ELEMENT ARETURN EMPTY>
-<!ELEMENT ARRAYLENGTH EMPTY>
-<!ELEMENT ASTORE EMPTY>
-<!ATTLIST ASTORE var CDATA #REQUIRED>
-<!ELEMENT ATHROW EMPTY>
-<!ELEMENT BALOAD EMPTY>
-<!ELEMENT BASTORE EMPTY>
-<!ELEMENT BIPUSH EMPTY>
-<!ATTLIST BIPUSH value CDATA #REQUIRED>
-<!ELEMENT CALOAD EMPTY>
-<!ELEMENT CASTORE EMPTY>
-<!ELEMENT CHECKCAST EMPTY>
-<!ATTLIST CHECKCAST desc CDATA #REQUIRED>
-<!ELEMENT D2F EMPTY>
-<!ELEMENT D2I EMPTY>
-<!ELEMENT D2L EMPTY>
-<!ELEMENT DADD EMPTY>
-<!ELEMENT DALOAD EMPTY>
-<!ELEMENT DASTORE EMPTY>
-<!ELEMENT DCMPG EMPTY>
-<!ELEMENT DCMPL EMPTY>
-<!ELEMENT DCONST_0 EMPTY>
-<!ELEMENT DCONST_1 EMPTY>
-<!ELEMENT DDIV EMPTY>
-<!ELEMENT DLOAD EMPTY>
-<!ATTLIST DLOAD var CDATA #REQUIRED>
-<!ELEMENT DMUL EMPTY>
-<!ELEMENT DNEG EMPTY>
-<!ELEMENT DREM EMPTY>
-<!ELEMENT DRETURN EMPTY>
-<!ELEMENT DSTORE EMPTY>
-<!ATTLIST DSTORE var CDATA #REQUIRED>
-<!ELEMENT DSUB EMPTY>
-<!ELEMENT DUP EMPTY>
-<!ELEMENT DUP2 EMPTY>
-<!ELEMENT DUP2_X1 EMPTY>
-<!ELEMENT DUP2_X2 EMPTY>
-<!ELEMENT DUP_X1 EMPTY>
-<!ELEMENT DUP_X2 EMPTY>
-<!ELEMENT F2D EMPTY>
-<!ELEMENT F2I EMPTY>
-<!ELEMENT F2L EMPTY>
-<!ELEMENT FADD EMPTY>
-<!ELEMENT FALOAD EMPTY>
-<!ELEMENT FASTORE EMPTY>
-<!ELEMENT FCMPG EMPTY>
-<!ELEMENT FCMPL EMPTY>
-<!ELEMENT FCONST_0 EMPTY>
-<!ELEMENT FCONST_1 EMPTY>
-<!ELEMENT FCONST_2 EMPTY>
-<!ELEMENT FDIV EMPTY>
-<!ELEMENT FLOAD EMPTY>
-<!ATTLIST FLOAD var CDATA #REQUIRED>
-<!ELEMENT FMUL EMPTY>
-<!ELEMENT FNEG EMPTY>
-<!ELEMENT FRETURN EMPTY>
-<!ELEMENT FSTORE EMPTY>
-<!ATTLIST FSTORE var CDATA #REQUIRED>
-<!ELEMENT FSUB EMPTY>
-<!ELEMENT GETFIELD EMPTY>
-<!ATTLIST GETFIELD desc CDATA #REQUIRED>
-<!ATTLIST GETFIELD name CDATA #REQUIRED>
-<!ATTLIST GETFIELD owner CDATA #REQUIRED>
-<!ELEMENT GETSTATIC EMPTY>
-<!ATTLIST GETSTATIC desc CDATA #REQUIRED>
-<!ATTLIST GETSTATIC name CDATA #REQUIRED>
-<!ATTLIST GETSTATIC owner CDATA #REQUIRED>
-<!ELEMENT GOTO EMPTY>
-<!ATTLIST GOTO label CDATA #REQUIRED>
-<!ELEMENT I2B EMPTY>
-<!ELEMENT I2C EMPTY>
-<!ELEMENT I2D EMPTY>
-<!ELEMENT I2F EMPTY>
-<!ELEMENT I2L EMPTY>
-<!ELEMENT I2S EMPTY>
-<!ELEMENT IADD EMPTY>
-<!ELEMENT IALOAD EMPTY>
-<!ELEMENT IAND EMPTY>
-<!ELEMENT IASTORE EMPTY>
-<!ELEMENT ICONST_0 EMPTY>
-<!ELEMENT ICONST_1 EMPTY>
-<!ELEMENT ICONST_2 EMPTY>
-<!ELEMENT ICONST_3 EMPTY>
-<!ELEMENT ICONST_4 EMPTY>
-<!ELEMENT ICONST_5 EMPTY>
-<!ELEMENT ICONST_M1 EMPTY>
-<!ELEMENT IDIV EMPTY>
-<!ELEMENT IFEQ EMPTY>
-<!ATTLIST IFEQ label CDATA #REQUIRED>
-<!ELEMENT IFGE EMPTY>
-<!ATTLIST IFGE label CDATA #REQUIRED>
-<!ELEMENT IFGT EMPTY>
-<!ATTLIST IFGT label CDATA #REQUIRED>
-<!ELEMENT IFLE EMPTY>
-<!ATTLIST IFLE label CDATA #REQUIRED>
-<!ELEMENT IFLT EMPTY>
-<!ATTLIST IFLT label CDATA #REQUIRED>
-<!ELEMENT IFNE EMPTY>
-<!ATTLIST IFNE label CDATA #REQUIRED>
-<!ELEMENT IFNONNULL EMPTY>
-<!ATTLIST IFNONNULL label CDATA #REQUIRED>
-<!ELEMENT IFNULL EMPTY>
-<!ATTLIST IFNULL label CDATA #REQUIRED>
-<!ELEMENT IF_ACMPEQ EMPTY>
-<!ATTLIST IF_ACMPEQ label CDATA #REQUIRED>
-<!ELEMENT IF_ACMPNE EMPTY>
-<!ATTLIST IF_ACMPNE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPEQ EMPTY>
-<!ATTLIST IF_ICMPEQ label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPGE EMPTY>
-<!ATTLIST IF_ICMPGE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPGT EMPTY>
-<!ATTLIST IF_ICMPGT label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPLE EMPTY>
-<!ATTLIST IF_ICMPLE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPLT EMPTY>
-<!ATTLIST IF_ICMPLT label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPNE EMPTY>
-<!ATTLIST IF_ICMPNE label CDATA #REQUIRED>
-<!ELEMENT IINC EMPTY>
-<!ATTLIST IINC inc CDATA #REQUIRED>
-<!ATTLIST IINC var CDATA #REQUIRED>
-<!ELEMENT ILOAD EMPTY>
-<!ATTLIST ILOAD var CDATA #REQUIRED>
-<!ELEMENT IMUL EMPTY>
-<!ELEMENT INEG EMPTY>
-<!ELEMENT INSTANCEOF EMPTY>
-<!ATTLIST INSTANCEOF desc CDATA #REQUIRED>
-<!ELEMENT INVOKEINTERFACE EMPTY>
-<!ATTLIST INVOKEINTERFACE desc CDATA #REQUIRED>
-<!ATTLIST INVOKEINTERFACE name CDATA #REQUIRED>
-<!ATTLIST INVOKEINTERFACE owner CDATA #REQUIRED>
-<!ELEMENT INVOKESPECIAL EMPTY>
-<!ATTLIST INVOKESPECIAL desc CDATA #REQUIRED>
-<!ATTLIST INVOKESPECIAL name CDATA #REQUIRED>
-<!ATTLIST INVOKESPECIAL owner CDATA #REQUIRED>
-<!ELEMENT INVOKESTATIC EMPTY>
-<!ATTLIST INVOKESTATIC desc CDATA #REQUIRED>
-<!ATTLIST INVOKESTATIC name CDATA #REQUIRED>
-<!ATTLIST INVOKESTATIC owner CDATA #REQUIRED>
-<!ELEMENT INVOKEVIRTUAL EMPTY>
-<!ATTLIST INVOKEVIRTUAL desc CDATA #REQUIRED>
-<!ATTLIST INVOKEVIRTUAL name CDATA #REQUIRED>
-<!ATTLIST INVOKEVIRTUAL owner CDATA #REQUIRED>
-<!ELEMENT IOR EMPTY>
-<!ELEMENT IREM EMPTY>
-<!ELEMENT IRETURN EMPTY>
-<!ELEMENT ISHL EMPTY>
-<!ELEMENT ISHR EMPTY>
-<!ELEMENT ISTORE EMPTY>
-<!ATTLIST ISTORE var CDATA #REQUIRED>
-<!ELEMENT ISUB EMPTY>
-<!ELEMENT IUSHR EMPTY>
-<!ELEMENT IXOR EMPTY>
-<!ELEMENT JSR EMPTY>
-<!ATTLIST JSR label CDATA #REQUIRED>
-<!ELEMENT L2D EMPTY>
-<!ELEMENT L2F EMPTY>
-<!ELEMENT L2I EMPTY>
-<!ELEMENT LADD EMPTY>
-<!ELEMENT LALOAD EMPTY>
-<!ELEMENT LAND EMPTY>
-<!ELEMENT LASTORE EMPTY>
-<!ELEMENT LCMP EMPTY>
-<!ELEMENT LCONST_0 EMPTY>
-<!ELEMENT LCONST_1 EMPTY>
-<!ELEMENT LDC EMPTY>
-<!--
-  All characters out of interval 0x20 to 0x7f (inclusive) must
-  be encoded (\uXXXX) and character '\' must be replaced by "\\"
--->
-<!ATTLIST LDC cst CDATA #REQUIRED>
-<!ATTLIST LDC desc CDATA #REQUIRED>
-<!ELEMENT LDIV EMPTY>
-<!ELEMENT LLOAD EMPTY>
-<!ATTLIST LLOAD var CDATA #REQUIRED>
-<!ELEMENT LMUL EMPTY>
-<!ELEMENT LNEG EMPTY>
-<!ELEMENT LOR EMPTY>
-<!ELEMENT LREM EMPTY>
-<!ELEMENT LRETURN EMPTY>
-<!ELEMENT LSHL EMPTY>
-<!ELEMENT LSHR EMPTY>
-<!ELEMENT LSTORE EMPTY>
-<!ATTLIST LSTORE var CDATA #REQUIRED>
-<!ELEMENT LSUB EMPTY>
-<!ELEMENT LUSHR EMPTY>
-<!ELEMENT LXOR EMPTY>
-<!ELEMENT MONITORENTER EMPTY>
-<!ELEMENT MONITOREXIT EMPTY>
-<!ELEMENT MULTIANEWARRAY EMPTY>
-<!ATTLIST MULTIANEWARRAY desc CDATA #REQUIRED>
-<!ATTLIST MULTIANEWARRAY dims CDATA #REQUIRED>
-<!ELEMENT NEW EMPTY>
-<!ATTLIST NEW desc CDATA #REQUIRED>
-<!ELEMENT NEWARRAY EMPTY>
-<!ATTLIST NEWARRAY value CDATA #REQUIRED>
-<!ELEMENT NOP EMPTY>
-<!ELEMENT POP EMPTY>
-<!ELEMENT POP2 EMPTY>
-<!ELEMENT PUTFIELD EMPTY>
-<!ATTLIST PUTFIELD desc CDATA #REQUIRED>
-<!ATTLIST PUTFIELD name CDATA #REQUIRED>
-<!ATTLIST PUTFIELD owner CDATA #REQUIRED>
-<!ELEMENT PUTSTATIC EMPTY>
-<!ATTLIST PUTSTATIC desc CDATA #REQUIRED>
-<!ATTLIST PUTSTATIC name CDATA #REQUIRED>
-<!ATTLIST PUTSTATIC owner CDATA #REQUIRED>
-<!ELEMENT RET EMPTY>
-<!ATTLIST RET var CDATA #REQUIRED>
-<!ELEMENT RETURN EMPTY>
-<!ELEMENT SALOAD EMPTY>
-<!ELEMENT SASTORE EMPTY>
-<!ELEMENT SIPUSH EMPTY>
-<!ATTLIST SIPUSH value CDATA #REQUIRED>
-
-<!ELEMENT LOOKUPSWITCH ( label+ )>
-<!ATTLIST LOOKUPSWITCH dflt CDATA #REQUIRED>
-
-<!ELEMENT TABLESWITCH ( label+ )>
-<!ATTLIST TABLESWITCH dflt CDATA #REQUIRED>
-<!ATTLIST TABLESWITCH max CDATA #REQUIRED>
-<!ATTLIST TABLESWITCH min CDATA #REQUIRED>
-
-<!ELEMENT label EMPTY>
-<!ATTLIST label key CDATA #IMPLIED>
-<!ATTLIST label name CDATA #REQUIRED>
-
+<!--
+  ASM XML Adapter
+  Copyright (c) 2004, Eugene Kuleshov
+  All rights reserved.
+  
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  3. Neither the name of the copyright holders nor the names of its
+     contributors may be used to endorse or promote products derived from
+     this software without specific prior written permission.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<!--
+  This DTD must be used to create XML documents to be processed by
+  org.objectweb.asm.xml.ASMContentHandler
+-->
+
+<!--
+  Root element used to aggregate multiple classes into single document.
+-->
+<!ELEMENT classes ( class+ )>
+
+<!--
+  Root element for a single class.
+-->
+<!ELEMENT class ( interfaces, ( field | innerclass | method )*)>
+<!ATTLIST class access CDATA #REQUIRED>
+<!ATTLIST class name CDATA #REQUIRED>
+<!ATTLIST class parent CDATA #REQUIRED>
+<!ATTLIST class major CDATA #REQUIRED>
+<!ATTLIST class minor CDATA #REQUIRED>
+<!ATTLIST class source CDATA #IMPLIED>
+
+<!ELEMENT interfaces ( interface* )>
+<!ELEMENT interface EMPTY>
+<!ATTLIST interface name CDATA #REQUIRED>
+
+<!ELEMENT field EMPTY>
+<!ATTLIST field access CDATA #REQUIRED>
+<!ATTLIST field desc CDATA #REQUIRED>
+<!ATTLIST field name CDATA #REQUIRED>
+<!--
+  All characters out of interval 0x20 to 0x7f (inclusive) must
+  be encoded (\uXXXX) and character '\' must be replaced by "\\"
+-->
+<!ATTLIST field value CDATA #IMPLIED>
+
+<!ELEMENT innerclass EMPTY>
+<!ATTLIST innerclass access CDATA #REQUIRED>
+<!ATTLIST innerclass innerName CDATA #IMPLIED>
+<!ATTLIST innerclass name CDATA #REQUIRED>
+<!ATTLIST innerclass outerName CDATA #IMPLIED>
+
+<!--
+  Root element for method definition.
+-->
+<!ELEMENT method ( exceptions, code? )>
+<!ATTLIST method access CDATA #REQUIRED>
+<!ATTLIST method desc CDATA #REQUIRED>
+<!ATTLIST method name CDATA #REQUIRED>
+
+<!ELEMENT exceptions ( exception* )>
+<!ELEMENT exception EMPTY>
+<!ATTLIST exception name CDATA #REQUIRED>
+
+<!--
+  code element contains bytecode instructions and definitions for labels, line numbers, try/catch and max
+-->
+<!ELEMENT code (( AALOAD | AASTORE | ACONST_NULL | ALOAD | ANEWARRAY | ARETURN | ARRAYLENGTH | ASTORE | ATHROW | BALOAD | BASTORE | BIPUSH | CALOAD | CASTORE | CHECKCAST | D2F | D2I | D2L | DADD | DALOAD | DASTORE | DCMPG | DCMPL | DCONST_0 | DCONST_1 | DDIV | DLOAD | DMUL | DNEG | DREM | DRETURN | DSTORE | DSUB | DUP | DUP2 | DUP2_X1 | DUP2_X2 | DUP_X1 | DUP_X2 | F2D | F2I | F2L | FADD | FALOAD | FASTORE | FCMPG | FCMPL | FCONST_0 | FCONST_1 | FCONST_2 | FDIV | FLOAD | FMUL | FNEG | FRETURN | FSTORE | FSUB | GETFIELD | GETSTATIC | GOTO | I2B | I2C | I2D | I2F | I2L | I2S | IADD | IALOAD | IAND | IASTORE | ICONST_0 | ICONST_1 | ICONST_2 | ICONST_3 | ICONST_4 | ICONST_5 | ICONST_M1 | IDIV | IFEQ | IFGE | IFGT | IFLE | IFLT | IFNE | IFNONNULL | IFNULL | IF_ACMPEQ | IF_ACMPNE | IF_ICMPEQ | IF_ICMPGE | IF_ICMPGT | IF_ICMPLE | IF_ICMPLT | IF_ICMPNE | IINC | ILOAD | IMUL | INEG | INSTANCEOF | INVOKEINTERFACE | INVOKESPECIAL | INVOKESTATIC | INVOKEVIRTUAL | IOR | IREM | IRETURN | ISHL | ISHR | ISTORE | ISUB | IUSHR | IXOR | JSR | L2D | L2F | L2I | LADD | LALOAD | LAND | LASTORE | LCMP | LCONST_0 | LCONST_1 | LDC | LDIV | LLOAD | LMUL | LNEG | LOOKUPSWITCH | LOR | LREM | LRETURN | LSHL | LSHR | LSTORE | LSUB | LUSHR | LXOR | MONITORENTER | MONITOREXIT | MULTIANEWARRAY | NEW | NEWARRAY | NOP | POP | POP2 | PUTFIELD | PUTSTATIC | RET | RETURN | SALOAD | SASTORE | SIPUSH | TABLESWITCH | Label | LineNumber | TryCatch )*, Max)>
+
+<!ELEMENT Label EMPTY>
+<!ATTLIST Label name CDATA #REQUIRED>
+
+<!ELEMENT TryCatch EMPTY>
+<!ATTLIST TryCatch end CDATA #REQUIRED>
+<!ATTLIST TryCatch handler CDATA #REQUIRED>
+<!ATTLIST TryCatch start CDATA #REQUIRED>
+<!ATTLIST TryCatch type CDATA #IMPLIED>
+
+<!ELEMENT LineNumber EMPTY>
+<!ATTLIST LineNumber line CDATA #REQUIRED>
+<!ATTLIST LineNumber start CDATA #REQUIRED>
+
+<!ELEMENT Max EMPTY>
+<!ATTLIST Max maxLocals CDATA #REQUIRED>
+<!ATTLIST Max maxStack CDATA #REQUIRED>
+
+<!ELEMENT AALOAD EMPTY>
+<!ELEMENT AASTORE EMPTY>
+<!ELEMENT ACONST_NULL EMPTY>
+<!ELEMENT ALOAD EMPTY>
+<!ATTLIST ALOAD var CDATA #REQUIRED>
+<!ELEMENT ANEWARRAY EMPTY>
+<!ATTLIST ANEWARRAY desc CDATA #REQUIRED>
+<!ELEMENT ARETURN EMPTY>
+<!ELEMENT ARRAYLENGTH EMPTY>
+<!ELEMENT ASTORE EMPTY>
+<!ATTLIST ASTORE var CDATA #REQUIRED>
+<!ELEMENT ATHROW EMPTY>
+<!ELEMENT BALOAD EMPTY>
+<!ELEMENT BASTORE EMPTY>
+<!ELEMENT BIPUSH EMPTY>
+<!ATTLIST BIPUSH value CDATA #REQUIRED>
+<!ELEMENT CALOAD EMPTY>
+<!ELEMENT CASTORE EMPTY>
+<!ELEMENT CHECKCAST EMPTY>
+<!ATTLIST CHECKCAST desc CDATA #REQUIRED>
+<!ELEMENT D2F EMPTY>
+<!ELEMENT D2I EMPTY>
+<!ELEMENT D2L EMPTY>
+<!ELEMENT DADD EMPTY>
+<!ELEMENT DALOAD EMPTY>
+<!ELEMENT DASTORE EMPTY>
+<!ELEMENT DCMPG EMPTY>
+<!ELEMENT DCMPL EMPTY>
+<!ELEMENT DCONST_0 EMPTY>
+<!ELEMENT DCONST_1 EMPTY>
+<!ELEMENT DDIV EMPTY>
+<!ELEMENT DLOAD EMPTY>
+<!ATTLIST DLOAD var CDATA #REQUIRED>
+<!ELEMENT DMUL EMPTY>
+<!ELEMENT DNEG EMPTY>
+<!ELEMENT DREM EMPTY>
+<!ELEMENT DRETURN EMPTY>
+<!ELEMENT DSTORE EMPTY>
+<!ATTLIST DSTORE var CDATA #REQUIRED>
+<!ELEMENT DSUB EMPTY>
+<!ELEMENT DUP EMPTY>
+<!ELEMENT DUP2 EMPTY>
+<!ELEMENT DUP2_X1 EMPTY>
+<!ELEMENT DUP2_X2 EMPTY>
+<!ELEMENT DUP_X1 EMPTY>
+<!ELEMENT DUP_X2 EMPTY>
+<!ELEMENT F2D EMPTY>
+<!ELEMENT F2I EMPTY>
+<!ELEMENT F2L EMPTY>
+<!ELEMENT FADD EMPTY>
+<!ELEMENT FALOAD EMPTY>
+<!ELEMENT FASTORE EMPTY>
+<!ELEMENT FCMPG EMPTY>
+<!ELEMENT FCMPL EMPTY>
+<!ELEMENT FCONST_0 EMPTY>
+<!ELEMENT FCONST_1 EMPTY>
+<!ELEMENT FCONST_2 EMPTY>
+<!ELEMENT FDIV EMPTY>
+<!ELEMENT FLOAD EMPTY>
+<!ATTLIST FLOAD var CDATA #REQUIRED>
+<!ELEMENT FMUL EMPTY>
+<!ELEMENT FNEG EMPTY>
+<!ELEMENT FRETURN EMPTY>
+<!ELEMENT FSTORE EMPTY>
+<!ATTLIST FSTORE var CDATA #REQUIRED>
+<!ELEMENT FSUB EMPTY>
+<!ELEMENT GETFIELD EMPTY>
+<!ATTLIST GETFIELD desc CDATA #REQUIRED>
+<!ATTLIST GETFIELD name CDATA #REQUIRED>
+<!ATTLIST GETFIELD owner CDATA #REQUIRED>
+<!ELEMENT GETSTATIC EMPTY>
+<!ATTLIST GETSTATIC desc CDATA #REQUIRED>
+<!ATTLIST GETSTATIC name CDATA #REQUIRED>
+<!ATTLIST GETSTATIC owner CDATA #REQUIRED>
+<!ELEMENT GOTO EMPTY>
+<!ATTLIST GOTO label CDATA #REQUIRED>
+<!ELEMENT I2B EMPTY>
+<!ELEMENT I2C EMPTY>
+<!ELEMENT I2D EMPTY>
+<!ELEMENT I2F EMPTY>
+<!ELEMENT I2L EMPTY>
+<!ELEMENT I2S EMPTY>
+<!ELEMENT IADD EMPTY>
+<!ELEMENT IALOAD EMPTY>
+<!ELEMENT IAND EMPTY>
+<!ELEMENT IASTORE EMPTY>
+<!ELEMENT ICONST_0 EMPTY>
+<!ELEMENT ICONST_1 EMPTY>
+<!ELEMENT ICONST_2 EMPTY>
+<!ELEMENT ICONST_3 EMPTY>
+<!ELEMENT ICONST_4 EMPTY>
+<!ELEMENT ICONST_5 EMPTY>
+<!ELEMENT ICONST_M1 EMPTY>
+<!ELEMENT IDIV EMPTY>
+<!ELEMENT IFEQ EMPTY>
+<!ATTLIST IFEQ label CDATA #REQUIRED>
+<!ELEMENT IFGE EMPTY>
+<!ATTLIST IFGE label CDATA #REQUIRED>
+<!ELEMENT IFGT EMPTY>
+<!ATTLIST IFGT label CDATA #REQUIRED>
+<!ELEMENT IFLE EMPTY>
+<!ATTLIST IFLE label CDATA #REQUIRED>
+<!ELEMENT IFLT EMPTY>
+<!ATTLIST IFLT label CDATA #REQUIRED>
+<!ELEMENT IFNE EMPTY>
+<!ATTLIST IFNE label CDATA #REQUIRED>
+<!ELEMENT IFNONNULL EMPTY>
+<!ATTLIST IFNONNULL label CDATA #REQUIRED>
+<!ELEMENT IFNULL EMPTY>
+<!ATTLIST IFNULL label CDATA #REQUIRED>
+<!ELEMENT IF_ACMPEQ EMPTY>
+<!ATTLIST IF_ACMPEQ label CDATA #REQUIRED>
+<!ELEMENT IF_ACMPNE EMPTY>
+<!ATTLIST IF_ACMPNE label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPEQ EMPTY>
+<!ATTLIST IF_ICMPEQ label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPGE EMPTY>
+<!ATTLIST IF_ICMPGE label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPGT EMPTY>
+<!ATTLIST IF_ICMPGT label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPLE EMPTY>
+<!ATTLIST IF_ICMPLE label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPLT EMPTY>
+<!ATTLIST IF_ICMPLT label CDATA #REQUIRED>
+<!ELEMENT IF_ICMPNE EMPTY>
+<!ATTLIST IF_ICMPNE label CDATA #REQUIRED>
+<!ELEMENT IINC EMPTY>
+<!ATTLIST IINC inc CDATA #REQUIRED>
+<!ATTLIST IINC var CDATA #REQUIRED>
+<!ELEMENT ILOAD EMPTY>
+<!ATTLIST ILOAD var CDATA #REQUIRED>
+<!ELEMENT IMUL EMPTY>
+<!ELEMENT INEG EMPTY>
+<!ELEMENT INSTANCEOF EMPTY>
+<!ATTLIST INSTANCEOF desc CDATA #REQUIRED>
+<!ELEMENT INVOKEINTERFACE EMPTY>
+<!ATTLIST INVOKEINTERFACE desc CDATA #REQUIRED>
+<!ATTLIST INVOKEINTERFACE name CDATA #REQUIRED>
+<!ATTLIST INVOKEINTERFACE owner CDATA #REQUIRED>
+<!ELEMENT INVOKESPECIAL EMPTY>
+<!ATTLIST INVOKESPECIAL desc CDATA #REQUIRED>
+<!ATTLIST INVOKESPECIAL name CDATA #REQUIRED>
+<!ATTLIST INVOKESPECIAL owner CDATA #REQUIRED>
+<!ELEMENT INVOKESTATIC EMPTY>
+<!ATTLIST INVOKESTATIC desc CDATA #REQUIRED>
+<!ATTLIST INVOKESTATIC name CDATA #REQUIRED>
+<!ATTLIST INVOKESTATIC owner CDATA #REQUIRED>
+<!ELEMENT INVOKEVIRTUAL EMPTY>
+<!ATTLIST INVOKEVIRTUAL desc CDATA #REQUIRED>
+<!ATTLIST INVOKEVIRTUAL name CDATA #REQUIRED>
+<!ATTLIST INVOKEVIRTUAL owner CDATA #REQUIRED>
+<!ELEMENT IOR EMPTY>
+<!ELEMENT IREM EMPTY>
+<!ELEMENT IRETURN EMPTY>
+<!ELEMENT ISHL EMPTY>
+<!ELEMENT ISHR EMPTY>
+<!ELEMENT ISTORE EMPTY>
+<!ATTLIST ISTORE var CDATA #REQUIRED>
+<!ELEMENT ISUB EMPTY>
+<!ELEMENT IUSHR EMPTY>
+<!ELEMENT IXOR EMPTY>
+<!ELEMENT JSR EMPTY>
+<!ATTLIST JSR label CDATA #REQUIRED>
+<!ELEMENT L2D EMPTY>
+<!ELEMENT L2F EMPTY>
+<!ELEMENT L2I EMPTY>
+<!ELEMENT LADD EMPTY>
+<!ELEMENT LALOAD EMPTY>
+<!ELEMENT LAND EMPTY>
+<!ELEMENT LASTORE EMPTY>
+<!ELEMENT LCMP EMPTY>
+<!ELEMENT LCONST_0 EMPTY>
+<!ELEMENT LCONST_1 EMPTY>
+<!ELEMENT LDC EMPTY>
+<!--
+  All characters out of interval 0x20 to 0x7f (inclusive) must
+  be encoded (\uXXXX) and character '\' must be replaced by "\\"
+-->
+<!ATTLIST LDC cst CDATA #REQUIRED>
+<!ATTLIST LDC desc CDATA #REQUIRED>
+<!ELEMENT LDIV EMPTY>
+<!ELEMENT LLOAD EMPTY>
+<!ATTLIST LLOAD var CDATA #REQUIRED>
+<!ELEMENT LMUL EMPTY>
+<!ELEMENT LNEG EMPTY>
+<!ELEMENT LOR EMPTY>
+<!ELEMENT LREM EMPTY>
+<!ELEMENT LRETURN EMPTY>
+<!ELEMENT LSHL EMPTY>
+<!ELEMENT LSHR EMPTY>
+<!ELEMENT LSTORE EMPTY>
+<!ATTLIST LSTORE var CDATA #REQUIRED>
+<!ELEMENT LSUB EMPTY>
+<!ELEMENT LUSHR EMPTY>
+<!ELEMENT LXOR EMPTY>
+<!ELEMENT MONITORENTER EMPTY>
+<!ELEMENT MONITOREXIT EMPTY>
+<!ELEMENT MULTIANEWARRAY EMPTY>
+<!ATTLIST MULTIANEWARRAY desc CDATA #REQUIRED>
+<!ATTLIST MULTIANEWARRAY dims CDATA #REQUIRED>
+<!ELEMENT NEW EMPTY>
+<!ATTLIST NEW desc CDATA #REQUIRED>
+<!ELEMENT NEWARRAY EMPTY>
+<!ATTLIST NEWARRAY value CDATA #REQUIRED>
+<!ELEMENT NOP EMPTY>
+<!ELEMENT POP EMPTY>
+<!ELEMENT POP2 EMPTY>
+<!ELEMENT PUTFIELD EMPTY>
+<!ATTLIST PUTFIELD desc CDATA #REQUIRED>
+<!ATTLIST PUTFIELD name CDATA #REQUIRED>
+<!ATTLIST PUTFIELD owner CDATA #REQUIRED>
+<!ELEMENT PUTSTATIC EMPTY>
+<!ATTLIST PUTSTATIC desc CDATA #REQUIRED>
+<!ATTLIST PUTSTATIC name CDATA #REQUIRED>
+<!ATTLIST PUTSTATIC owner CDATA #REQUIRED>
+<!ELEMENT RET EMPTY>
+<!ATTLIST RET var CDATA #REQUIRED>
+<!ELEMENT RETURN EMPTY>
+<!ELEMENT SALOAD EMPTY>
+<!ELEMENT SASTORE EMPTY>
+<!ELEMENT SIPUSH EMPTY>
+<!ATTLIST SIPUSH value CDATA #REQUIRED>
+
+<!ELEMENT LOOKUPSWITCH ( label+ )>
+<!ATTLIST LOOKUPSWITCH dflt CDATA #REQUIRED>
+
+<!ELEMENT TABLESWITCH ( label+ )>
+<!ATTLIST TABLESWITCH dflt CDATA #REQUIRED>
+<!ATTLIST TABLESWITCH max CDATA #REQUIRED>
+<!ATTLIST TABLESWITCH min CDATA #REQUIRED>
+
+<!ELEMENT label EMPTY>
+<!ATTLIST label key CDATA #IMPLIED>
+<!ATTLIST label name CDATA #REQUIRED>
+
diff -uNr asm-3.1.orig/test/build.xml asm-3.1/test/build.xml
--- asm-3.1.orig/test/build.xml	2006-10-28 03:50:41.000000000 +0900
+++ asm-3.1/test/build.xml	2009-01-27 12:44:23.000000000 +0900
@@ -35,9 +35,6 @@
   <!-- ==================================== -->
 
   <property name="test.conform"   value="${test}/conform"/>
-  <property name="test.deviance"  value="${test}/deviance"/>
-  <property name="test.thread"    value="${test}/thread"/>
-  <property name="test.stress"    value="${test}/stress"/>
   <property name="test.perf"      value="${test}/perf"/>
 
   <target name="properties">
@@ -48,35 +45,28 @@
     <condition property="java5">
       <available classname="java.lang.annotation.Annotation"/> 
     </condition>
-      
-    <condition property="test.conform.exist">
-      <available file="${test.conform}"/>
-    </condition>
-
-    <condition property="test.deviance.exist">
-      <available file="${test.deviance}"/>
-    </condition>
-
-    <condition property="test.thread.exist">
-      <available file="${test.thread}"/>
-    </condition>
-
-    <condition property="test.stress.exist">
-      <available file="${test.stress}"/>
-    </condition>
-
-    <condition property="test.perf.exist">
-      <available file="${test.perf}"/>
-    </condition>
     
-    <condition property="test.all">
+    <condition property="test-all">
       <and>
         <not><isset property="test.type"/></not>
         <not><isset property="test.group"/></not>
-        <not><isset property="test.name"/></not>
       </and>
     </condition>
 
+    <condition property="test-conform">
+      <or>
+        <equals arg1="${test.type}" arg2="conform"/>
+        <isset property="test-all"/>
+      </or>  
+    </condition>
+
+    <condition property="test-perf">
+      <or>
+        <equals arg1="${test.type}" arg2="perf"/>
+        <isset property="test-all"/>
+      </or>  
+    </condition>
+
     <condition property="test.paths.configured">
       <and>
         <isset property="bcel.path"/>
@@ -86,6 +76,13 @@
         <isset property="janino.path"/>
         <isset property="cobertura.path"/>
         <isset property="cobertura.runtime.path"/>
+        <isset property="kawa.runtime.path"/>
+        <isset property="csg-bytecode.runtime.path"/>
+        <isset property="cojen.runtime.path"/>
+        <isset property="jbet.runtime.path"/>
+        <isset property="jclasslib.runtime.path"/>
+        <isset property="jiapi.runtime.path"/>
+        <isset property="rhino.runtime.path"/>
       </and>
     </condition>
   </target>
@@ -112,6 +109,13 @@
       <pathelement path="${javassist.path}"/>
       <pathelement path="${janino.path}"/>
       <pathelement path="${cobertura.runtime.path}"/>
+      <pathelement path="${kawa.runtime.path}"/>
+      <pathelement path="${csg-bytecode.runtime.path}"/>
+      <pathelement path="${cojen.runtime.path}"/>
+      <pathelement path="${jbet.runtime.path}"/>
+      <pathelement path="${jclasslib.runtime.path}"/>
+      <pathelement path="${jiapi.runtime.path}"/>
+      <pathelement path="${rhino.runtime.path}"/>
     </path>
   </target>
   
@@ -119,7 +123,7 @@
   <!-- =========== COMPILATION ============ -->
   <!-- ==================================== -->
 
-  <target name="compile.test.conform" depends="init" if="test.conform.exist">
+  <target name="compile.test.conform" depends="init">
     <javac srcdir="${test.conform}" destdir="${out.test}" 
         debug="on" debuglevel="lines,vars,source">
       <classpath refid="test.classpath"/>
@@ -135,28 +139,7 @@
     </java>
   </target>
 
-  <target name="compile.test.deviance" depends="init" if="test.deviance.exist">
-    <javac srcdir="${test.deviance}" destdir="${out.test}" debug="on" source="1.3" target="1.2">
-      <classpath refid="test.classpath"/>
-      <include name="**/*.java"/>
-    </javac>
-  </target>
-
-  <target name="compile.test.thread" depends="init" if="test.thread.exist">
-    <javac srcdir="${test.thread}" destdir="${out.test}" debug="on" source="1.3" target="1.2">
-      <classpath refid="test.classpath"/>
-      <include name="**/*.java"/>
-    </javac>
-  </target>
-
-  <target name="compile.test.stress" depends="init" if="test.stress.exist">
-    <javac srcdir="${test.stress}" destdir="${out.test}" debug="on" source="1.3" target="1.2">
-      <classpath refid="test.classpath"/>
-      <include name="**/*.java"/>
-    </javac>
-  </target>
-
-  <target name="compile.test.perf" depends="init" if="test.perf.exist">
+  <target name="compile.test.perf" depends="init">
     <javac srcdir="${test.perf}" destdir="${out.test}" debug="on" source="1.3" target="1.2">
       <classpath refid="test.classpath"/>
       <include name="**/*.java"/>
@@ -164,37 +147,56 @@
     </javac>
   </target>
 
-  <target name="compile" depends="compile.test.conform,compile.test.deviance,compile.test.thread,compile.test.stress,compile.test.perf"/>
+  <target name="compile" depends="compile.test.conform,compile.test.perf"/>
 
   <!-- ============================= -->
   <!-- =========== TEST ============ -->
   <!-- ============================= -->
 
-  <target name="testAll" depends="compile" if="test.all">
-    <multipleAnt dir="${test.conform}" inheritRefs="true"/>
-    <!--multipleAnt dir="${test.deviance}" inheritRefs="true"/>
-    <multipleAnt dir="${test.thread}" inheritRefs="true"/>
-    <multipleAnt dir="${test.stress}" inheritRefs="true"/-->
-    <multipleAnt dir="${test.perf}" inheritRefs="true"/>
-  </target>
-
-  <target name="testType" depends="compile" if="test.type">
-    <multipleAnt dir="${test}/${test.type}" inheritRefs="true"/>
+  <target name="testConform" depends="compile" if="test-conform">
+    <ant antfile="${test.conform}/adviceadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/analyzeradapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/annotations.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/asmifier.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/basicinterpreter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/basicverifier.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/checkclassadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/checksignatureadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classnode.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classreader.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classwriter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classwritercomputeframes.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classwritercomputemaxs.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classwritercopypool.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/classwriterresizeinsns.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/codesizeevaluator.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/gasmifier.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/jsrinlineradapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/localvariablessorter2.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/localvariablessorter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/remappingadapter2.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/remappingadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/saxadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/signaturewriter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/sourceinterpreter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/staticinitmerger.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/svuidadder.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/traceclassadapter.xml" inheritRefs="true"/>
+    <ant antfile="${test.conform}/unit.xml" inheritRefs="true"/>
+  </target>
+
+  <target name="testPerf" depends="compile" if="test-perf">
+    <ant antfile="${test.perf}/all.xml" inheritRefs="true"/>
+    <ant antfile="${test.perf}/gen.xml" inheritRefs="true"/>
+    <ant antfile="${test.perf}/mem.xml" inheritRefs="true"/>
   </target>
 
   <target name="testGroup" depends="compile" if="test.group">
     <ant antfile="test/${test.group}.xml" inheritRefs="true"/>
   </target>
 
-  <target name="testName" depends="compile" if="test.name">
-    <multipleAnt dir="${test.conform}" target="${test.name}" inheritRefs="true"/>
-    <!--multipleAnt dir="${test.deviance}" target="${test.name}" inheritRefs="true"/>
-    <multipleAnt dir="${test.thread}" target="${test.name}" inheritRefs="true"/>
-    <multipleAnt dir="${test.stress}" target="${test.name}" inheritRefs="true"/-->
-    <multipleAnt dir="${test.perf}" target="${test.name}" inheritRefs="true"/>
-  </target>
-
-  <target name="test" depends="testAll,testType,testGroup,testName">
+  <target name="test" depends="testConform,testPerf,testGroup">
     <!--junitreport todir="${out.test}/reports">
       <fileset dir="${out.test}/reports">
         <include name="TEST-*.xml"/>
diff -uNr asm-3.1.orig/test/conform/org/objectweb/asm/util/CheckClassAdapterUnitTest.java asm-3.1/test/conform/org/objectweb/asm/util/CheckClassAdapterUnitTest.java
--- asm-3.1.orig/test/conform/org/objectweb/asm/util/CheckClassAdapterUnitTest.java	2007-05-12 18:02:34.000000000 +0900
+++ asm-3.1/test/conform/org/objectweb/asm/util/CheckClassAdapterUnitTest.java	2009-01-27 12:44:26.000000000 +0900
@@ -29,16 +29,20 @@
  */
 package org.objectweb.asm.util;
 
+import java.io.IOException;
 import java.io.PrintWriter;
+import java.util.HashMap;
 
 import junit.framework.TestCase;
 
 import org.objectweb.asm.AnnotationVisitor;
+import org.objectweb.asm.ClassAdapter;
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.FieldVisitor;
 import org.objectweb.asm.Label;
+import org.objectweb.asm.MethodAdapter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.attrs.Comment;
@@ -469,6 +473,55 @@
         } catch (Exception e) {
         }
     }
+    
+    public void testIllegalDebugLabelUse() throws IOException {
+        ClassReader cr = new ClassReader("java.lang.Object");
+        ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
+        ClassVisitor cv = new ClassAdapter(cw) {
+            public MethodVisitor visitMethod(
+                int access,
+                String name,
+                String desc,
+                String signature,
+                String[] exceptions)
+            {
+                final MethodVisitor next = cv.visitMethod(access,
+                        name,
+                        desc,
+                        signature,
+                        exceptions);
+                if (next == null) {
+                    return next;
+                }
+                return new MethodAdapter(new CheckMethodAdapter(next)) {
+                    private Label entryLabel = null;
+
+                    public void visitLabel(Label label) {
+                        if (entryLabel == null) {
+                            entryLabel = label;
+                        }
+                        mv.visitLabel(label);
+                    }
+
+                    public void visitMaxs(int maxStack, int maxLocals) {
+                        Label unwindhandler = new Label();
+                        mv.visitLabel(unwindhandler);
+                        mv.visitInsn(Opcodes.ATHROW); // rethrow
+                        mv.visitTryCatchBlock(entryLabel,
+                                unwindhandler,
+                                unwindhandler,
+                                null);
+                        mv.visitMaxs(maxStack, maxLocals);
+                    }
+                };
+            }
+        };
+        try {
+            cr.accept(cv, ClassReader.EXPAND_FRAMES);
+            fail();
+        } catch (Exception e) {
+        }
+    }
 
     public void testIllegalTableSwitchParameters1() {
         MethodVisitor mv = new CheckMethodAdapter(new EmptyVisitor());
@@ -761,6 +814,62 @@
         }
     }
 
+    public void testIllegalTryCatchBlock() {
+        MethodVisitor mv = new CheckMethodAdapter(new EmptyVisitor());
+        mv.visitCode();
+        Label m = new Label();
+        Label n = new Label();
+        mv.visitLabel(m);
+        try {
+            mv.visitTryCatchBlock(m, n, n, null);
+            fail();
+        } catch (Exception e) {
+        }        
+        try {
+            mv.visitTryCatchBlock(n, m, n, null);
+            fail();
+        } catch (Exception e) {
+        }        
+        try {
+            mv.visitTryCatchBlock(n, n, m, null);
+            fail();
+        } catch (Exception e) {
+        }        
+    }
+    
+    public void testIllegalDataflow() {
+        MethodVisitor mv = new CheckMethodAdapter(ACC_PUBLIC,
+                "m",
+                "(I)V",
+                new EmptyVisitor(),
+                new HashMap());
+        mv.visitCode();
+        mv.visitVarInsn(ILOAD, 1);
+        mv.visitInsn(IRETURN);
+        mv.visitMaxs(1, 2);
+        try {
+            mv.visitEnd();
+            fail();
+        } catch (Exception e) {
+        }
+    }
+    
+    public void testIllegalDataflow2() {
+        MethodVisitor mv = new CheckMethodAdapter(ACC_PUBLIC,
+                "m",
+                "(I)I",
+                new EmptyVisitor(),
+                new HashMap());
+        mv.visitCode();
+        mv.visitInsn(RETURN);
+        mv.visitMaxs(0, 2);
+        try {
+            mv.visitEnd();
+            fail();
+        } catch (Exception e) {
+        }
+    }
+
     public void testIllegalLocalVariableLabels() {
         MethodVisitor mv = new CheckMethodAdapter(new EmptyVisitor());
         mv.visitCode();
diff -uNr asm-3.1.orig/test/perf/all.xml asm-3.1/test/perf/all.xml
--- asm-3.1.orig/test/perf/all.xml	2006-10-28 03:50:42.000000000 +0900
+++ asm-3.1/test/perf/all.xml	2009-01-27 12:44:23.000000000 +0900
@@ -5,10 +5,10 @@
         <pathelement location="${out.build}"/>
         <pathelement location="${out.test}"/>
         <fileset dir="${test}">
-          <include name="lib/bcel-5.1.jar"/>
-          <include name="lib/aspectjweaver.jar"/>
-          <include name="lib/serp.jar"/>
-          <include name="lib/javassist.jar"/>
+          <include name="lib/bcel-5.2.jar"/>
+          <include name="lib/aspectjweaver-1.5.3.jar"/>
+          <include name="lib/serp-1.14.2.jar"/>
+          <include name="lib/javassist.3.6.GA.jar"/>
           <!-- xslt engines -->
           <include name="lib/jd.xslt-1.5.5.jar"/>
           <include name="lib/saxon7.jar"/>
@@ -16,6 +16,7 @@
         </fileset>
       </classpath>
       <jvmarg value="-Dasm.test.class=${asm.test.class}" /> 
+      <jvmarg value="-Xmx512M" /> 
     </java>
   </target>
 </project>
diff -uNr asm-3.1.orig/test/perf/gen.xml asm-3.1/test/perf/gen.xml
--- asm-3.1.orig/test/perf/gen.xml	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/test/perf/gen.xml	2009-01-27 12:44:23.000000000 +0900
@@ -0,0 +1,22 @@
+<project name="perf" default="test">
+  <target name="test">
+    <java classname="org.objectweb.asm.GenPerfTest" fork="yes">
+      <classpath>
+        <pathelement location="${out.build}"/>
+        <pathelement location="${out.test}"/>
+        <fileset dir="${test}">
+          <include name="lib/csg-bytecode.jar"/>
+          <include name="lib/kawa-1.9.1.jar"/>
+          <include name="lib/cojen-2.0.jar"/>
+          <include name="lib/jbet3-R1.jar"/>
+          <include name="lib/jclasslib.jar"/>
+          <include name="lib/jiapi.jar"/>
+          <include name="lib/log4j-1.2.9.jar"/>
+          <include name="lib/rhino1_7R1.jar"/>
+          <include name="lib/bcel-5.2.jar"/>
+          <include name="lib/aspectjweaver-1.5.3.jar"/>
+        </fileset>
+      </classpath>
+    </java>
+  </target>
+</project>
diff -uNr asm-3.1.orig/test/perf/org/apache/bcel/classfile/Signature.java asm-3.1/test/perf/org/apache/bcel/classfile/Signature.java
--- asm-3.1.orig/test/perf/org/apache/bcel/classfile/Signature.java	2006-10-28 03:50:40.000000000 +0900
+++ asm-3.1/test/perf/org/apache/bcel/classfile/Signature.java	1970-01-01 09:00:00.000000000 +0900
@@ -1,340 +0,0 @@
-package org.apache.bcel.classfile;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache BCEL" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache BCEL", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import org.apache.bcel.Constants;
-import java.io.*;
-
-/**
- * This class is derived from <em>Attribute</em> and represents a reference to
- * a <href="http://wwwipd.ira.uka.de/~pizza/gj/">GJ</a> attribute.
- * 
- * @version $Id: Signature.java,v 1.2 2006/07/05 15:22:56 ebruneton Exp $
- * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
- * @see Attribute
- */
-public final class Signature extends Attribute {
-    private int signature_index;
-
-    /**
-     * Initialize from another object. Note that both objects use the same
-     * references (shallow copy). Use clone() for a physical copy.
-     * 
-     * @param c
-     */
-    public Signature(final Signature c) {
-        this(c.getNameIndex(),
-                c.getLength(),
-                c.getSignatureIndex(),
-                c.getConstantPool());
-    }
-
-    /**
-     * Construct object from file stream.
-     * 
-     * @param name_index Index in constant pool to CONSTANT_Utf8
-     * @param length Content length in bytes
-     * @param file Input stream
-     * @param constant_pool Array of constants
-     * @throws IOException
-     */
-    Signature(
-        final int name_index,
-        final int length,
-        final DataInputStream file,
-        final ConstantPool constant_pool) throws IOException
-    {
-        this(name_index, length, file.readUnsignedShort(), constant_pool);
-    }
-
-    /**
-     * @param name_index Index in constant pool to CONSTANT_Utf8
-     * @param length Content length in bytes
-     * @param constant_pool Array of constants
-     * @param signature_index Index in constant pool to CONSTANT_Utf8
-     */
-    public Signature(
-        final int name_index,
-        final int length,
-        final int signature_index,
-        final ConstantPool constant_pool)
-    {
-        super(Constants.ATTR_SIGNATURE, name_index, length, constant_pool);
-        this.signature_index = signature_index;
-    }
-
-    /**
-     * Called by objects that are traversing the nodes of the tree implicitely
-     * defined by the contents of a Java class. I.e., the hierarchy of methods,
-     * fields, attributes, etc. spawns a tree of objects.
-     * 
-     * @param v Visitor object
-     */
-    public void accept(final Visitor v) {
-        // System.err.println("Visiting non-standard Signature object");
-        // v.visitSignature(this);
-    }
-
-    /**
-     * Dump source file attribute to file stream in binary format.
-     * 
-     * @param file Output file stream
-     * @throws IOException
-     */
-    public final void dump(final DataOutputStream file) throws IOException {
-        super.dump(file);
-        file.writeShort(signature_index);
-    }
-
-    /**
-     * @return Index in constant pool of source file name.
-     */
-    public final int getSignatureIndex() {
-        return signature_index;
-    }
-
-    /**
-     * @param signature_index
-     */
-    public final void setSignatureIndex(final int signature_index) {
-        this.signature_index = signature_index;
-    }
-
-    /**
-     * @return GJ signature.
-     */
-    public final String getSignature() {
-        ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(signature_index,
-                Constants.CONSTANT_Utf8);
-        return c.getBytes();
-    }
-
-    /**
-     * Extends ByteArrayInputStream to make 'unreading' chars possible.
-     */
-    private static final class MyByteArrayInputStream extends
-            ByteArrayInputStream
-    {
-        MyByteArrayInputStream(final String data) {
-            super(data.getBytes());
-        }
-
-        final int mark() {
-            return pos;
-        }
-
-        final String getData() {
-            return new String(buf);
-        }
-
-        final void reset(final int p) {
-            pos = p;
-        }
-
-        final void unread() {
-            if (pos > 0) {
-                pos--;
-            }
-        }
-    }
-
-    private static boolean identStart(final int ch) {
-        return ch == 'T' || ch == 'L';
-    }
-
-    // private static boolean identPart(int ch) {
-    // return ch == '/' || ch == ';';
-    // }
-
-    private static final void matchIdent(
-        final MyByteArrayInputStream in,
-        final StringBuffer buf)
-    {
-        int ch;
-
-        if ((ch = in.read()) == -1) {
-            throw new RuntimeException("Illegal signature: " + in.getData()
-                    + " no ident, reaching EOF");
-        }
-
-        // System.out.println("return from ident:" + (char)ch);
-
-        if (!identStart(ch)) {
-            StringBuffer buf2 = new StringBuffer();
-
-            int count = 1;
-            while (Character.isJavaIdentifierPart((char) ch)) {
-                buf2.append((char) ch);
-                count++;
-                ch = in.read();
-            }
-
-            if (ch == ':') { // Ok, formal parameter
-                in.skip("Ljava/lang/Object".length());
-                buf.append(buf2);
-
-                ch = in.read();
-                in.unread();
-                // System.out.println("so far:" + buf2 + ":next:" +(char)ch);
-            } else {
-                for (int i = 0; i < count; i++) {
-                    in.unread();
-                }
-            }
-
-            return;
-        }
-
-        StringBuffer buf2 = new StringBuffer();
-        ch = in.read();
-
-        do {
-            buf2.append((char) ch);
-            ch = in.read();
-            // System.out.println("within ident:"+ (char)ch);
-
-        } while (ch != -1
-                && (Character.isJavaIdentifierPart((char) ch) || ch == '/'));
-
-        buf.append(buf2.toString().replace('/', '.'));
-
-        // System.out.println("regular return ident:"+ (char)ch + ":" + buf2);
-
-        if (ch != -1) {
-            in.unread();
-        }
-    }
-
-    private static final void matchGJIdent(
-        final MyByteArrayInputStream in,
-        final StringBuffer buf)
-    {
-        int ch;
-
-        matchIdent(in, buf);
-
-        ch = in.read();
-        if (ch == '<' || ch == '(') { // Parameterized or method
-            // System.out.println("Enter <");
-            buf.append((char) ch);
-            matchGJIdent(in, buf);
-
-            while ((ch = in.read()) != '>' && ch != ')') { // List of
-                // parameters
-                if (ch == -1) {
-                    throw new RuntimeException("Illegal signature: "
-                            + in.getData() + " reaching EOF");
-                }
-
-                // System.out.println("Still no >");
-                buf.append(", ");
-                in.unread();
-                matchGJIdent(in, buf); // Recursive call
-            }
-
-            // System.out.println("Exit >");
-
-            buf.append((char) ch);
-        } else {
-            in.unread();
-        }
-
-        ch = in.read();
-        if (identStart(ch)) {
-            in.unread();
-            matchGJIdent(in, buf);
-        } else if (ch == ')') {
-            in.unread();
-            return;
-        } else if (ch != ';') {
-            throw new RuntimeException("Illegal signature: " + in.getData()
-                    + " read " + (char) ch);
-        }
-    }
-
-    public static String translate(final String s) {
-        // System.out.println("Sig:" + s);
-        StringBuffer buf = new StringBuffer();
-
-        matchGJIdent(new MyByteArrayInputStream(s), buf);
-
-        return buf.toString();
-    }
-
-    public static final boolean isFormalParameterList(final String s) {
-        return s.startsWith("<") && s.indexOf(':') > 0;
-    }
-
-    public static final boolean isActualParameterList(final String s) {
-        return s.startsWith("L") && s.endsWith(">;");
-    }
-
-    /**
-     * @return String representation
-     */
-    public final String toString() {
-        String s = getSignature();
-
-        return "Signature(" + s + ")";
-    }
-
-    /**
-     * @param constant_pool
-     * @return deep copy of this attribute
-     */
-    public Attribute copy(final ConstantPool constant_pool) {
-        return (Signature) clone();
-    }
-}
diff -uNr asm-3.1.orig/test/perf/org/apache/bcel/verifier/statics/StringRepresentation.java asm-3.1/test/perf/org/apache/bcel/verifier/statics/StringRepresentation.java
--- asm-3.1.orig/test/perf/org/apache/bcel/verifier/statics/StringRepresentation.java	2006-10-28 03:50:42.000000000 +0900
+++ asm-3.1/test/perf/org/apache/bcel/verifier/statics/StringRepresentation.java	1970-01-01 09:00:00.000000000 +0900
@@ -1,286 +0,0 @@
-package org.apache.bcel.verifier.statics;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache BCEL" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache BCEL", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import org.apache.bcel.classfile.*;
-import org.apache.bcel.classfile.Deprecated;
-
-/**
- * BCEL's Node classes (those from the classfile API that <B>accept()</B>
- * Visitor instances) have <B>toString()</B> methods that were not designed to
- * be robust, this gap is closed by this class. When performing class file
- * verification, it may be useful to output which entity (e.g. a <B>Code</B>
- * instance) is not satisfying the verifier's constraints, but in this case it
- * could be possible for the <B>toString()</B> method to throw a
- * RuntimeException. A (new StringRepresentation(Node n)).toString() never
- * throws any exception. Note that this class also serves as a placeholder for
- * more sophisticated message handling in future versions of JustIce.
- * 
- * @version $Id: StringRepresentation.java,v 1.1.2.1 2005/09/16 07:19:39
- *          ebruneton Exp $
- * @author <A HREF="http://www.inf.fu-berlin.de/~ehaase"/>Enver Haase</A>
- */
-public class StringRepresentation extends
-        org.apache.bcel.classfile.EmptyVisitor implements Visitor
-{
-    /**
-     * The string representation, created by a visitXXX() method, output by
-     * toString().
-     */
-    private String tostring;
-
-    /**
-     * The node we ask for its string representation. Not really needed; only
-     * for debug output.
-     */
-    // private Node n;
-    /**
-     * Creates a new StringRepresentation object which is the representation of
-     * n.
-     * 
-     * @param n
-     * 
-     * @see #toString()
-     */
-    public StringRepresentation(final Node n) {
-        // this.n = n;
-        n.accept(this); // assign a string representation to field 'tostring' if
-        // we know n's class.
-    }
-
-    /**
-     * Returns the String representation.
-     * 
-     * @return TODO
-     */
-    public String toString() {
-        // The run-time check below is needed because we don't want to omit
-        // inheritance
-        // of "EmptyVisitor" and provide a thousand empty methods.
-        // However, in terms of performance this would be a better idea.
-        // If some new "Node" is defined in BCEL (such as some concrete
-        // "Attribute"), we
-        // want to know that this class has also to be adapted.
-        if (tostring == null) {
-            tostring = "";// throw new AssertionViolatedException("Please
-            // adapt '"+getClass()+"' to deal with objects of
-            // class '"+n.getClass()+"'.");
-        }
-        return tostring;
-    }
-
-    /**
-     * Returns the String representation of the Node object obj; this is
-     * obj.toString() if it does not throw any RuntimeException, or else it is a
-     * string derived only from obj's class name.
-     * 
-     * @param obj
-     * @return TODO
-     */
-    private String toString(final Node obj) {
-        String ret;
-        try {
-            ret = obj.toString();
-        } catch (RuntimeException e) {
-            String s = obj.getClass().getName();
-            s = s.substring(s.lastIndexOf(".") + 1);
-            ret = "<<" + s + ">>";
-        } catch (ClassFormatError e) { /*
-                                         * BCEL can be harsh e.g. trying to
-                                         * convert the "signature" of a
-                                         * ReturnaddressType LocalVariable
-                                         * (shouldn't occur, but people do crazy
-                                         * things)
-                                         */
-            String s = obj.getClass().getName();
-            s = s.substring(s.lastIndexOf(".") + 1);
-            ret = "<<" + s + ">>";
-        }
-        return ret;
-    }
-
-    // //////////////////////////////
-    // Visitor methods start here //
-    // //////////////////////////////
-    // We don't of course need to call some default implementation:
-    // e.g. we could also simply output "Code" instead of a possibly
-    // lengthy Code attribute's toString().
-    public void visitCode(final Code obj) {
-        // tostring = toString(obj);
-        tostring = "<CODE>"; // We don't need real code outputs.
-    }
-
-    public void visitCodeException(final CodeException obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantClass(final ConstantClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantDouble(final ConstantDouble obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantFieldref(final ConstantFieldref obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantFloat(final ConstantFloat obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantInteger(final ConstantInteger obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantInterfaceMethodref(
-        final ConstantInterfaceMethodref obj)
-    {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantLong(final ConstantLong obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantMethodref(final ConstantMethodref obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantNameAndType(final ConstantNameAndType obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantPool(final ConstantPool obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantString(final ConstantString obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantUtf8(final ConstantUtf8 obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantValue(final ConstantValue obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitDeprecated(final Deprecated obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitExceptionTable(final ExceptionTable obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitField(final Field obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitInnerClass(final InnerClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitInnerClasses(final InnerClasses obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitJavaClass(final JavaClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLineNumber(final LineNumber obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLineNumberTable(final LineNumberTable obj) {
-        tostring = "<LineNumberTable: " + toString(obj) + ">";
-    }
-
-    public void visitLocalVariable(final LocalVariable obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLocalVariableTable(final LocalVariableTable obj) {
-        tostring = "<LocalVariableTable: " + toString(obj) + ">";
-    }
-
-    public void visitMethod(final Method obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSignature(final Signature obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSourceFile(final SourceFile obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitStackMap(final StackMap obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSynthetic(final Synthetic obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitUnknown(final Unknown obj) {
-        tostring = toString(obj);
-    }
-}
diff -uNr asm-3.1.orig/test/perf/org/apache/bcel/verifier/structurals/ModifiedPass3bVerifier.java asm-3.1/test/perf/org/apache/bcel/verifier/structurals/ModifiedPass3bVerifier.java
--- asm-3.1.orig/test/perf/org/apache/bcel/verifier/structurals/ModifiedPass3bVerifier.java	2006-10-28 03:50:42.000000000 +0900
+++ asm-3.1/test/perf/org/apache/bcel/verifier/structurals/ModifiedPass3bVerifier.java	2009-01-27 12:44:23.000000000 +0900
@@ -13,102 +13,94 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License. 
  *
- */
+ */ 
 package org.apache.bcel.verifier.structurals;
 
+
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 import java.util.Vector;
+
 import org.apache.bcel.Constants;
+import org.apache.bcel.Repository;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Method;
 import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.GETFIELD;
+import org.apache.bcel.generic.InstructionHandle;
+import org.apache.bcel.generic.InvokeInstruction;
 import org.apache.bcel.generic.JsrInstruction;
+import org.apache.bcel.generic.LoadInstruction;
 import org.apache.bcel.generic.MethodGen;
 import org.apache.bcel.generic.ObjectType;
 import org.apache.bcel.generic.RET;
+import org.apache.bcel.generic.ReturnInstruction;
 import org.apache.bcel.generic.ReturnaddressType;
 import org.apache.bcel.generic.Type;
+import org.apache.bcel.verifier.PassVerifier;
 import org.apache.bcel.verifier.VerificationResult;
+import org.apache.bcel.verifier.Verifier;
 import org.apache.bcel.verifier.exc.AssertionViolatedException;
+import org.apache.bcel.verifier.exc.StructuralCodeConstraintException;
 import org.apache.bcel.verifier.exc.VerifierConstraintViolatedException;
-import org.apache.bcel.verifier.structurals.ControlFlowGraph;
-import org.apache.bcel.verifier.structurals.ExceptionHandler;
-import org.apache.bcel.verifier.structurals.ExecutionVisitor;
-import org.apache.bcel.verifier.structurals.Frame;
-import org.apache.bcel.verifier.structurals.InstConstraintVisitor;
-import org.apache.bcel.verifier.structurals.InstructionContext;
-import org.apache.bcel.verifier.structurals.OperandStack;
-import org.apache.bcel.verifier.structurals.UninitializedObjectType;
 
 /**
  * This PassVerifier verifies a method of class file according to pass 3,
  * so-called structural verification as described in The Java Virtual Machine
- * Specification, 2nd edition. More detailed information is to be found at the
- * do_verify() method's documentation.
- * 
- * @version $Id: ModifiedPass3bVerifier.java,v 1.1.2.2 2005/09/16 07:19:39
- *          ebruneton Exp $
- * @author <A HREF="http://www.inf.fu-berlin.de/~ehaase"/>Enver Haase</A>
+ * Specification, 2nd edition.
+ * More detailed information is to be found at the do_verify() method's
+ * documentation. 
+ *
+ * @version $Id: ModifiedPass3bVerifier.java,v 1.3 2007-11-08 17:22:56 ebruneton Exp $
+ * @author Enver Haase
  * @see #do_verify()
  */
 
-public final class ModifiedPass3bVerifier {
-    /*
-     * TODO: Throughout pass 3b, upper halves of LONG and DOUBLE are represented
-     * by Type.UNKNOWN. This should be changed in favour of LONG_Upper and
-     * DOUBLE_Upper as in pass 2.
-     */
+public final class ModifiedPass3bVerifier extends PassVerifier{
+    /* TODO:    Throughout pass 3b, upper halves of LONG and DOUBLE
+                        are represented by Type.UNKNOWN. This should be changed
+                        in favour of LONG_Upper and DOUBLE_Upper as in pass 2. */
 
     /**
      * An InstructionContextQueue is a utility class that holds
-     * (InstructionContext, ArrayList) pairs in a Queue data structure. This is
-     * used to hold information about InstructionContext objects externally ---
-     * i.e. that information is not saved inside the InstructionContext object
-     * itself. This is useful to save the execution path of the symbolic
-     * execution of the Pass3bVerifier - this is not information that belongs
-     * into the InstructionContext object itself. Only at "execute()"ing time,
-     * an InstructionContext object will get the current information we have
-     * about its symbolic execution predecessors.
+     * (InstructionContext, ArrayList) pairs in a Queue data structure.
+     * This is used to hold information about InstructionContext objects
+     * externally --- i.e. that information is not saved inside the
+     * InstructionContext object itself. This is useful to save the
+     * execution path of the symbolic execution of the
+     * Pass3bVerifier - this is not information
+     * that belongs into the InstructionContext object itself.
+     * Only at "execute()"ing
+     * time, an InstructionContext object will get the current information
+     * we have about its symbolic execution predecessors.
      */
-    private static final class InstructionContextQueue {
-        private final Vector ics = new Vector(); // Type: InstructionContext
-        private final Vector ecs = new Vector(); // Type: ArrayList (of
-
-        // InstructionContext)
-
-        public void add(
-            final InstructionContext ic,
-            final ArrayList executionChain)
-        {
+    private static final class InstructionContextQueue{
+        private List ics = new Vector(); // Type: InstructionContext
+        private List ecs = new Vector(); // Type: ArrayList (of InstructionContext)
+        public void add(InstructionContext ic, ArrayList executionChain){
             ics.add(ic);
             ecs.add(executionChain);
         }
-
-        public boolean isEmpty() {
+        public boolean isEmpty(){
             return ics.isEmpty();
         }
-
-        public void remove() {
+        public void remove(){
             this.remove(0);
         }
-
-        public void remove(final int i) {
+        public void remove(int i){
             ics.remove(i);
             ecs.remove(i);
         }
-
-        public InstructionContext getIC(final int i) {
+        public InstructionContext getIC(int i){
             return (InstructionContext) ics.get(i);
         }
-
-        public ArrayList getEC(final int i) {
+        public ArrayList getEC(int i){
             return (ArrayList) ecs.get(i);
         }
-
-        public int size() {
+        public int size(){
             return ics.size();
         }
     } // end Inner Class InstructionContextQueue
@@ -116,7 +108,6 @@
     /** In DEBUG mode, the verification algorithm is not randomized. */
     private static final boolean DEBUG = true;
 
-    /** The Verifier that created this. */
     private JavaClass jc;
 
     /** The method number to verify. */
@@ -124,129 +115,97 @@
 
     /**
      * This class should only be instantiated by a Verifier.
-     * 
-     * @param jc
-     * @param method_no
-     * 
+     *
      * @see org.apache.bcel.verifier.Verifier
      */
-    public ModifiedPass3bVerifier(final JavaClass jc, final int method_no) {
+    public ModifiedPass3bVerifier(JavaClass jc, int method_no){
         this.jc = jc;
         this.method_no = method_no;
     }
 
     /**
-     * Whenever the outgoing frame situation of an InstructionContext changes,
-     * all its successors are put [back] into the queue [as if they were
-     * unvisited]. The proof of termination is about the existence of a fix
-     * point of frame merging.
-     * 
-     * @param cfg
-     * @param start
-     * @param vanillaFrame
-     * @param icv
-     * @param ev
+     * Whenever the outgoing frame
+     * situation of an InstructionContext changes, all its successors are
+     * put [back] into the queue [as if they were unvisited].
+   * The proof of termination is about the existence of a
+   * fix point of frame merging.
      */
-    private void circulationPump(
-        final ControlFlowGraph cfg,
-        final InstructionContext start,
-        final Frame vanillaFrame,
-        final InstConstraintVisitor icv,
-        final ExecutionVisitor ev)
-    {
+    private void circulationPump(MethodGen m,ControlFlowGraph cfg, InstructionContext start, Frame vanillaFrame, InstConstraintVisitor icv, ExecutionVisitor ev){
         final Random random = new Random();
         InstructionContextQueue icq = new InstructionContextQueue();
-
-        start.execute(vanillaFrame, new ArrayList(), icv, ev); // new
-        // ArrayList()
-        // <=> no
-        // Instruction
-        // was executed
-        // before
-        // => Top-Level routine (no jsr call before)
+        
+        start.execute(vanillaFrame, new ArrayList(), icv, ev);  // new ArrayList() <=>  no Instruction was executed before
+                                                                                                    //                                  => Top-Level routine (no jsr call before)
         icq.add(start, new ArrayList());
 
         // LOOP!
-        while (!icq.isEmpty()) {
+        while (!icq.isEmpty()){
             InstructionContext u;
             ArrayList ec;
-            if (!DEBUG) {
+            if (!DEBUG){
                 int r = random.nextInt(icq.size());
                 u = icq.getIC(r);
                 ec = icq.getEC(r);
                 icq.remove(r);
-            } else {
-                u = icq.getIC(0);
+            }
+            else{
+                u  = icq.getIC(0);
                 ec = icq.getEC(0);
                 icq.remove(0);
             }
-
-            ArrayList oldchain = (ArrayList) ec.clone();
-            ArrayList newchain = (ArrayList) ec.clone();
+            
+            ArrayList oldchain = (ArrayList) (ec.clone());
+            ArrayList newchain = (ArrayList) (ec.clone());
             newchain.add(u);
 
-            if (u.getInstruction().getInstruction() instanceof RET) {
-                // System.err.println(u);
+            if ((u.getInstruction().getInstruction()) instanceof RET){
+//System.err.println(u);
                 // We can only follow _one_ successor, the one after the
                 // JSR that was recently executed.
-                RET ret = (RET) u.getInstruction().getInstruction();
-                ReturnaddressType t = (ReturnaddressType) u.getOutFrame(oldchain)
-                        .getLocals()
-                        .get(ret.getIndex());
+                RET ret = (RET) (u.getInstruction().getInstruction());
+                ReturnaddressType t = (ReturnaddressType) u.getOutFrame(oldchain).getLocals().get(ret.getIndex());
                 InstructionContext theSuccessor = cfg.contextOf(t.getTarget());
 
                 // Sanity check
                 InstructionContext lastJSR = null;
                 int skip_jsr = 0;
-                for (int ss = oldchain.size() - 1; ss >= 0; ss--) {
-                    if (skip_jsr < 0) {
+                for (int ss=oldchain.size()-1; ss >= 0; ss--){
+                    if (skip_jsr < 0){
                         throw new AssertionViolatedException("More RET than JSR in execution chain?!");
                     }
-                    // System.err.println("+"+oldchain.get(ss));
-                    if (((InstructionContext) oldchain.get(ss)).getInstruction()
-                            .getInstruction() instanceof JsrInstruction)
-                    {
-                        if (skip_jsr == 0) {
+//System.err.println("+"+oldchain.get(ss));
+                    if (((InstructionContext) oldchain.get(ss)).getInstruction().getInstruction() instanceof JsrInstruction){
+                        if (skip_jsr == 0){
                             lastJSR = (InstructionContext) oldchain.get(ss);
                             break;
-                        } else {
+                        }
+                        else{
                             skip_jsr--;
                         }
                     }
-                    if (((InstructionContext) oldchain.get(ss)).getInstruction()
-                            .getInstruction() instanceof RET)
-                    {
+                    if (((InstructionContext) oldchain.get(ss)).getInstruction().getInstruction() instanceof RET){
                         skip_jsr++;
                     }
                 }
-                if (lastJSR == null) {
-                    throw new AssertionViolatedException("RET without a JSR before in ExecutionChain?! EC: '"
-                            + oldchain + "'.");
-                }
-                JsrInstruction jsr = (JsrInstruction) lastJSR.getInstruction()
-                        .getInstruction();
-                if (theSuccessor != cfg.contextOf(jsr.physicalSuccessor())) {
-                    throw new AssertionViolatedException("RET '"
-                            + u.getInstruction()
-                            + "' info inconsistent: jump back to '"
-                            + theSuccessor + "' or '"
-                            + cfg.contextOf(jsr.physicalSuccessor()) + "'?");
-                }
-
-                if (theSuccessor.execute(u.getOutFrame(oldchain),
-                        newchain,
-                        icv,
-                        ev))
-                {
+                if (lastJSR == null){
+                    throw new AssertionViolatedException("RET without a JSR before in ExecutionChain?! EC: '"+oldchain+"'.");
+                }
+                JsrInstruction jsr = (JsrInstruction) (lastJSR.getInstruction().getInstruction());
+                if ( theSuccessor != (cfg.contextOf(jsr.physicalSuccessor())) ){
+                    throw new AssertionViolatedException("RET '"+u.getInstruction()+"' info inconsistent: jump back to '"+theSuccessor+"' or '"+cfg.contextOf(jsr.physicalSuccessor())+"'?");
+                }
+                
+                if (theSuccessor.execute(u.getOutFrame(oldchain), newchain, icv, ev)){
                     icq.add(theSuccessor, (ArrayList) newchain.clone());
                 }
-            } else {// "not a ret"
-
+            }
+            else{// "not a ret"
+            
                 // Normal successors. Add them to the queue of successors.
                 InstructionContext[] succs = u.getSuccessors();
-                for (int s = 0; s < succs.length; s++) {
+                for (int s=0; s<succs.length; s++){
                     InstructionContext v = succs[s];
-                    if (v.execute(u.getOutFrame(oldchain), newchain, icv, ev)) {
+                    if (v.execute(u.getOutFrame(oldchain), newchain, icv, ev)){
                         icq.add(v, (ArrayList) newchain.clone());
                     }
                 }
@@ -255,171 +214,176 @@
             // Exception Handlers. Add them to the queue of successors.
             // [subroutines are never protected; mandated by JustIce]
             ExceptionHandler[] exc_hds = u.getExceptionHandlers();
-            for (int s = 0; s < exc_hds.length; s++) {
+            for (int s=0; s<exc_hds.length; s++){
                 InstructionContext v = cfg.contextOf(exc_hds[s].getHandlerStart());
-                // TODO: the "oldchain" and "newchain" is used to determine the
-                // subroutine
-                // we're in (by searching for the last JSR) by the
-                // InstructionContext
-                // implementation. Therefore, we should not use this chain
-                // mechanism
+                // TODO: the "oldchain" and "newchain" is used to determine the subroutine
+                // we're in (by searching for the last JSR) by the InstructionContext
+                // implementation. Therefore, we should not use this chain mechanism
                 // when dealing with exception handlers.
-                // Example: a JSR with an exception handler as its successor
-                // does not
+                // Example: a JSR with an exception handler as its successor does not
                 // mean we're in a subroutine if we go to the exception handler.
-                // We should address this problem later; by now we simply "cut"
-                // the chain
+                // We should address this problem later; by now we simply "cut" the chain
                 // by using an empty chain for the exception handlers.
-                // if (v.execute(new Frame(u.getOutFrame(oldchain).getLocals(),
-                // new OperandStack (u.getOutFrame().getStack().maxStack(),
-                // (exc_hds[s].getExceptionType()==null? Type.THROWABLE :
-                // exc_hds[s].getExceptionType())) ), newchain), icv, ev){
-                // icq.add(v, (ArrayList) newchain.clone());
-                if (v.execute(new Frame(u.getOutFrame(oldchain).getLocals(),
-                        new OperandStack(u.getOutFrame(oldchain)
-                                .getStack()
-                                .maxStack(),
-                                (exc_hds[s].getExceptionType() == null
-                                        ? Type.THROWABLE
-                                        : exc_hds[s].getExceptionType()))),
-                        new ArrayList(),
-                        icv,
-                        ev))
-                {
+                //if (v.execute(new Frame(u.getOutFrame(oldchain).getLocals(), new OperandStack (u.getOutFrame().getStack().maxStack(), (exc_hds[s].getExceptionType()==null? Type.THROWABLE : exc_hds[s].getExceptionType())) ), newchain), icv, ev){
+                    //icq.add(v, (ArrayList) newchain.clone());
+                if (v.execute(new Frame(u.getOutFrame(oldchain).getLocals(), new OperandStack (u.getOutFrame(oldchain).getStack().maxStack(), (exc_hds[s].getExceptionType()==null? Type.THROWABLE : exc_hds[s].getExceptionType())) ), new ArrayList(), icv, ev)){
                     icq.add(v, new ArrayList());
                 }
             }
 
         }// while (!icq.isEmpty()) END
-
-        // InstructionHandle ih = start.getInstruction();
-        // do{
-        // if ((ih.getInstruction() instanceof ReturnInstruction) &&
-        // (!(cfg.isDead(ih)))) {
-        // InstructionContext ic = cfg.contextOf(ih);
-        // Frame f = ic.getOutFrame(new ArrayList()); // TODO: This is buggy, we
-        // check only the top-level return instructions this way. Maybe some
-        // maniac returns from a method when in a subroutine?
-        // LocalVariables lvs = f.getLocals();
-        // for (int i=0; i<lvs.maxLocals(); i++){
-        // if (lvs.get(i) instanceof UninitializedObjectType){
-        // //this.addMessage("Warning: ReturnInstruction '"+ic+"' may leave
-        // method with an uninitialized object in the local variables array
-        // '"+lvs+"'.");
-        // }
-        // }
-        // OperandStack os = f.getStack();
-        // for (int i=0; i<os.size(); i++){
-        // if (os.peek(i) instanceof UninitializedObjectType){
-        // this.addMessage("Warning: ReturnInstruction '"+ic+"' may leave method
-        // with an uninitialized object on the operand stack '"+os+"'.");
-        // }
-        // }
-        // }
-        // }while ((ih = ih.getNext()) != null);
-
+        
+        InstructionHandle ih = start.getInstruction();
+        do{
+            if ((ih.getInstruction() instanceof ReturnInstruction) && (!(cfg.isDead(ih)))) {
+                InstructionContext ic = cfg.contextOf(ih);
+                Frame f = ic.getOutFrame(new ArrayList()); // TODO: This is buggy, we check only the top-level return instructions this way. Maybe some maniac returns from a method when in a subroutine?
+                LocalVariables lvs = f.getLocals();
+                for (int i=0; i<lvs.maxLocals(); i++){
+                    if (lvs.get(i) instanceof UninitializedObjectType){
+                        this.addMessage("Warning: ReturnInstruction '"+ic+"' may leave method with an uninitialized object in the local variables array '"+lvs+"'.");
+                    }
+                }
+                OperandStack os = f.getStack();
+                for (int i=0; i<os.size(); i++){
+                    if (os.peek(i) instanceof UninitializedObjectType){
+                        this.addMessage("Warning: ReturnInstruction '"+ic+"' may leave method with an uninitialized object on the operand stack '"+os+"'.");
+                    }
+                }
+                //see JVM $4.8.2
+                //TODO implement all based on stack 
+                Type returnedType = null;
+                if( ih.getPrev().getInstruction() instanceof InvokeInstruction )
+                {
+                    returnedType = ((InvokeInstruction)ih.getPrev().getInstruction()).getType(m.getConstantPool());
+                }
+                if( ih.getPrev().getInstruction() instanceof LoadInstruction )
+                {
+                    int index = ((LoadInstruction)ih.getPrev().getInstruction()).getIndex();
+                    returnedType = lvs.get(index);
+                }
+                if( ih.getPrev().getInstruction() instanceof GETFIELD )
+                {
+                    returnedType = ((GETFIELD)ih.getPrev().getInstruction()).getType(m.getConstantPool());
+                }
+                if( returnedType != null )
+                {
+                    if( returnedType instanceof ObjectType )
+                    {
+                        try
+                        {
+                            if( !((ObjectType)returnedType).isAssignmentCompatibleWith(m.getReturnType()) )
+                            {
+                                throw new StructuralCodeConstraintException("Returned type "+returnedType+" does not match Method's return type "+m.getReturnType());
+                            }
+                        }
+                        catch (ClassNotFoundException e)
+                        {
+                            //dont know what do do now, so raise RuntimeException
+                            throw new RuntimeException(e);
+                        }
+                    }
+                    else if( !returnedType.equals(m.getReturnType()) )
+                    {
+                        throw new StructuralCodeConstraintException("Returned type "+returnedType+" does not match Method's return type "+m.getReturnType());
+                    }
+                }
+            }
+        }while ((ih = ih.getNext()) != null);
+        
     }
 
     /**
-     * Pass 3b implements the data flow analysis as described in the Java
-     * Virtual Machine Specification, Second Edition. Later versions will use
-     * LocalVariablesInfo objects to verify if the verifier-inferred types and
-     * the class file's debug information (LocalVariables attributes) match
-     * [TODO].
-     * 
-     * @return TODO
-     * 
+     * Pass 3b implements the data flow analysis as described in the Java Virtual
+     * Machine Specification, Second Edition.
+     * Later versions will use LocalVariablesInfo objects to verify if the
+     * verifier-inferred types and the class file's debug information (LocalVariables
+     * attributes) match [TODO].
+     *
      * @see org.apache.bcel.verifier.statics.LocalVariablesInfo
      * @see org.apache.bcel.verifier.statics.Pass2Verifier#getLocalVariablesInfo(int)
      */
-    public VerificationResult do_verify() {
+    public VerificationResult do_verify(){
+        /*if (! myOwner.doPass3a(method_no).equals(VerificationResult.VR_OK)){
+            return VerificationResult.VR_NOTYET;
+        }
+
+        // Pass 3a ran before, so it's safe to assume the JavaClass object is
+        // in the BCEL repository.
+        JavaClass jc;
+        try {
+            jc = Repository.lookupClass(myOwner.getClassName());
+        } catch (ClassNotFoundException e) {
+            // FIXME: maybe not the best way to handle this
+            throw new AssertionViolatedException("Missing class: " + e.toString());
+        }*/
+
         ConstantPoolGen constantPoolGen = new ConstantPoolGen(jc.getConstantPool());
         // Init Visitors
         InstConstraintVisitor icv = new InstConstraintVisitor();
         icv.setConstantPoolGen(constantPoolGen);
-
+        
         ExecutionVisitor ev = new ExecutionVisitor();
         ev.setConstantPoolGen(constantPoolGen);
+        
+        Method[] methods = jc.getMethods(); // Method no "method_no" exists, we ran Pass3a before on it!
 
-        Method[] methods = jc.getMethods(); // Method no "method_no" exists, we
-        // ran Pass3a before on it!
+        try{
 
-        try {
-
-            MethodGen mg = new MethodGen(methods[method_no],
-                    jc.getClassName(),
-                    constantPoolGen);
+            MethodGen mg = new MethodGen(methods[method_no], jc.getClassName(), constantPoolGen);
 
             icv.setMethodGen(mg);
-
-            // //////////// DFA BEGINS HERE ////////////////
-            if (!(mg.isAbstract() || mg.isNative())) { // IF mg HAS CODE (See
-                // pass 2)
-
+                
+            ////////////// DFA BEGINS HERE ////////////////
+            if (! (mg.isAbstract() || mg.isNative()) ){ // IF mg HAS CODE (See pass 2)
+                
                 ControlFlowGraph cfg = new ControlFlowGraph(mg);
 
                 // Build the initial frame situation for this method.
-                Frame f = new Frame(mg.getMaxLocals(), mg.getMaxStack());
-                if (!mg.isStatic()) {
-                    if (mg.getName().equals(Constants.CONSTRUCTOR_NAME)) {
+                Frame f = new Frame(mg.getMaxLocals(),mg.getMaxStack());
+                if ( !mg.isStatic() ){
+                    if (mg.getName().equals(Constants.CONSTRUCTOR_NAME)){
                         Frame._this = new UninitializedObjectType(new ObjectType(jc.getClassName()));
                         f.getLocals().set(0, Frame._this);
-                    } else {
+                    }
+                    else{
                         Frame._this = null;
                         f.getLocals().set(0, new ObjectType(jc.getClassName()));
                     }
                 }
                 Type[] argtypes = mg.getArgumentTypes();
                 int twoslotoffset = 0;
-                for (int j = 0; j < argtypes.length; j++) {
-                    if (argtypes[j] == Type.SHORT || argtypes[j] == Type.BYTE
-                            || argtypes[j] == Type.CHAR
-                            || argtypes[j] == Type.BOOLEAN)
-                    {
+                for (int j=0; j<argtypes.length; j++){
+                    if (argtypes[j] == Type.SHORT || argtypes[j] == Type.BYTE || argtypes[j] == Type.CHAR || argtypes[j] == Type.BOOLEAN){
                         argtypes[j] = Type.INT;
                     }
-                    f.getLocals().set(twoslotoffset + j
-                            + (mg.isStatic() ? 0 : 1),
-                            argtypes[j]);
-                    if (argtypes[j].getSize() == 2) {
+                    f.getLocals().set(twoslotoffset + j + (mg.isStatic()?0:1), argtypes[j]);
+                    if (argtypes[j].getSize() == 2){
                         twoslotoffset++;
-                        f.getLocals().set(twoslotoffset + j
-                                + (mg.isStatic() ? 0 : 1),
-                                Type.UNKNOWN);
+                        f.getLocals().set(twoslotoffset + j + (mg.isStatic()?0:1), Type.UNKNOWN);
                     }
                 }
-                circulationPump(cfg, cfg.contextOf(mg.getInstructionList()
-                        .getStart()), f, icv, ev);
+                circulationPump(mg,cfg, cfg.contextOf(mg.getInstructionList().getStart()), f, icv, ev);
             }
-        } catch (VerifierConstraintViolatedException ce) {
-            ce.extendMessage("Constraint violated in method '"
-                    + methods[method_no] + "':\n", "");
-            return new VerificationResult(VerificationResult.VERIFIED_REJECTED,
-                    ce.getMessage());
-        } catch (RuntimeException re) {
+        }
+        catch (VerifierConstraintViolatedException ce){
+            ce.extendMessage("Constraint violated in method '"+methods[method_no]+"':\n","");
+            return new VerificationResult(VerificationResult.VERIFIED_REJECTED, ce.getMessage());
+        }
+        catch (RuntimeException re){
             // These are internal errors
 
             StringWriter sw = new StringWriter();
             PrintWriter pw = new PrintWriter(sw);
             re.printStackTrace(pw);
 
-            throw new AssertionViolatedException("Some RuntimeException occured while verify()ing class '"
-                    + jc.getClassName()
-                    + "', method '"
-                    + methods[method_no]
-                    + "'. Original RuntimeException's stack trace:\n---\n"
-                    + sw
-                    + "---\n");
+            throw new AssertionViolatedException("Some RuntimeException occured while verify()ing class '"+jc.getClassName()+"', method '"+methods[method_no]+"'. Original RuntimeException's stack trace:\n---\n"+sw+"---\n");
         }
         return VerificationResult.VR_OK;
     }
 
-    /**
-     * Returns the method number as supplied when instantiating.
-     * 
-     * @return TODO
-     */
-    public int getMethodNo() {
+    /** Returns the method number as supplied when instantiating. */
+    public int getMethodNo(){
         return method_no;
     }
 }
diff -uNr asm-3.1.orig/test/perf/org/aspectj/apache/bcel/classfile/Signature.java asm-3.1/test/perf/org/aspectj/apache/bcel/classfile/Signature.java
--- asm-3.1.orig/test/perf/org/aspectj/apache/bcel/classfile/Signature.java	2006-10-28 03:50:40.000000000 +0900
+++ asm-3.1/test/perf/org/aspectj/apache/bcel/classfile/Signature.java	2009-01-27 12:44:23.000000000 +0900
@@ -61,7 +61,7 @@
  * This class is derived from <em>Attribute</em> and represents a reference to
  * a <href="http://wwwipd.ira.uka.de/~pizza/gj/">GJ</a> attribute.
  * 
- * @version $Id: Signature.java,v 1.2 2006/07/05 15:22:56 ebruneton Exp $
+ * @version $Id: Signature.java,v 1.2 2006-07-05 15:22:56 ebruneton Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * @see Attribute
  */
diff -uNr asm-3.1.orig/test/perf/org/aspectj/apache/bcel/verifier/statics/StringRepresentation.java asm-3.1/test/perf/org/aspectj/apache/bcel/verifier/statics/StringRepresentation.java
--- asm-3.1.orig/test/perf/org/aspectj/apache/bcel/verifier/statics/StringRepresentation.java	2006-10-28 03:50:40.000000000 +0900
+++ asm-3.1/test/perf/org/aspectj/apache/bcel/verifier/statics/StringRepresentation.java	1970-01-01 09:00:00.000000000 +0900
@@ -1,330 +0,0 @@
-package org.aspectj.apache.bcel.verifier.statics;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache BCEL" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache BCEL", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import org.aspectj.apache.bcel.classfile.*;
-import org.aspectj.apache.bcel.classfile.Deprecated;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeInvisibleAnnotations;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeInvisibleParameterAnnotations;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeVisibleAnnotations;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeVisibleParameterAnnotations;
-
-/**
- * BCEL's Node classes (those from the classfile API that <B>accept()</B>
- * Visitor instances) have <B>toString()</B> methods that were not designed to
- * be robust, this gap is closed by this class. When performing class file
- * verification, it may be useful to output which entity (e.g. a <B>Code</B>
- * instance) is not satisfying the verifier's constraints, but in this case it
- * could be possible for the <B>toString()</B> method to throw a
- * RuntimeException. A (new StringRepresentation(Node n)).toString() never
- * throws any exception. Note that this class also serves as a placeholder for
- * more sophisticated message handling in future versions of JustIce.
- * 
- * @version $Id: StringRepresentation.java,v 1.1.2.1 2005/09/16 07:19:39
- *          ebruneton Exp $
- * @author <A HREF="http://www.inf.fu-berlin.de/~ehaase"/>Enver Haase</A>
- */
-public class StringRepresentation extends
-        org.apache.bcel.classfile.EmptyVisitor implements Visitor
-{
-    /**
-     * The string representation, created by a visitXXX() method, output by
-     * toString().
-     */
-    private String tostring;
-
-    /**
-     * The node we ask for its string representation. Not really needed; only
-     * for debug output.
-     */
-    // private Node n;
-    /**
-     * Creates a new StringRepresentation object which is the representation of
-     * n.
-     * 
-     * @param n
-     * 
-     * @see #toString()
-     */
-    public StringRepresentation(final Node n) {
-        // this.n = n;
-        n.accept(this); // assign a string representation to field 'tostring' if
-        // we know n's class.
-    }
-
-    /**
-     * Returns the String representation.
-     * 
-     * @return TODO
-     */
-    public String toString() {
-        // The run-time check below is needed because we don't want to omit
-        // inheritance
-        // of "EmptyVisitor" and provide a thousand empty methods.
-        // However, in terms of performance this would be a better idea.
-        // If some new "Node" is defined in BCEL (such as some concrete
-        // "Attribute"), we
-        // want to know that this class has also to be adapted.
-        if (tostring == null) {
-            tostring = ""; // throw new AssertionViolatedException("Please
-            // adapt '"+getClass()+"' to deal with objects of
-            // class '"+n.getClass()+"'.");
-        }
-        return tostring;
-    }
-
-    /**
-     * Returns the String representation of the Node object obj; this is
-     * obj.toString() if it does not throw any RuntimeException, or else it is a
-     * string derived only from obj's class name.
-     * 
-     * @param obj
-     * @return TODO
-     */
-    private String toString(final Node obj) {
-        String ret;
-        try {
-            ret = obj.toString();
-        } catch (RuntimeException e) {
-            String s = obj.getClass().getName();
-            s = s.substring(s.lastIndexOf(".") + 1);
-            ret = "<<" + s + ">>";
-        } catch (ClassFormatError e) { /*
-                                         * BCEL can be harsh e.g. trying to
-                                         * convert the "signature" of a
-                                         * ReturnaddressType LocalVariable
-                                         * (shouldn't occur, but people do crazy
-                                         * things)
-                                         */
-            String s = obj.getClass().getName();
-            s = s.substring(s.lastIndexOf(".") + 1);
-            ret = "<<" + s + ">>";
-        }
-        return ret;
-    }
-
-    // //////////////////////////////
-    // Visitor methods start here //
-    // //////////////////////////////
-    // We don't of course need to call some default implementation:
-    // e.g. we could also simply output "Code" instead of a possibly
-    // lengthy Code attribute's toString().
-    public void visitCode(final Code obj) {
-        // tostring = toString(obj);
-        tostring = "<CODE>"; // We don't need real code outputs.
-    }
-
-    public void visitCodeException(final CodeException obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantClass(final ConstantClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantDouble(final ConstantDouble obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantFieldref(final ConstantFieldref obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantFloat(final ConstantFloat obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantInteger(final ConstantInteger obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantInterfaceMethodref(
-        final ConstantInterfaceMethodref obj)
-    {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantLong(final ConstantLong obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantMethodref(final ConstantMethodref obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantNameAndType(final ConstantNameAndType obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantPool(final ConstantPool obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantString(final ConstantString obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantUtf8(final ConstantUtf8 obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitConstantValue(final ConstantValue obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitDeprecated(final Deprecated obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitExceptionTable(final ExceptionTable obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitField(final Field obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitInnerClass(final InnerClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitInnerClasses(final InnerClasses obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitJavaClass(final JavaClass obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLineNumber(final LineNumber obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLineNumberTable(final LineNumberTable obj) {
-        tostring = "<LineNumberTable: " + toString(obj) + ">";
-    }
-
-    public void visitLocalVariable(final LocalVariable obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitLocalVariableTable(final LocalVariableTable obj) {
-        tostring = "<LocalVariableTable: " + toString(obj) + ">";
-    }
-
-    public void visitMethod(final Method obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSignature(final Signature obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSourceFile(final SourceFile obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitStackMap(final StackMap obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitSynthetic(final Synthetic obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitUnknown(final Unknown obj) {
-        tostring = toString(obj);
-    }
-
-    public void visitStackMapEntry(final StackMapEntry arg0) {
-        tostring = "";
-    }
-
-    public void visitEnclosingMethod(final EnclosingMethod arg0) {
-        tostring = "";
-    }
-
-    public void visitRuntimeVisibleAnnotations(
-        final RuntimeVisibleAnnotations arg0)
-    {
-        tostring = "";
-    }
-
-    public void visitRuntimeInvisibleAnnotations(
-        final RuntimeInvisibleAnnotations arg0)
-    {
-        tostring = "";
-    }
-
-    public void visitRuntimeVisibleParameterAnnotations(
-        final RuntimeVisibleParameterAnnotations arg0)
-    {
-        tostring = "";
-    }
-
-    public void visitRuntimeInvisibleParameterAnnotations(
-        final RuntimeInvisibleParameterAnnotations arg0)
-    {
-        tostring = "";
-    }
-
-    public void visitAnnotationDefault(final AnnotationDefault arg0) {
-        tostring = "";
-    }
-
-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable arg0) {
-        tostring = "";
-    }
-}
diff -uNr asm-3.1.orig/test/perf/org/objectweb/asm/ALLPerfTest.java asm-3.1/test/perf/org/objectweb/asm/ALLPerfTest.java
--- asm-3.1.orig/test/perf/org/objectweb/asm/ALLPerfTest.java	2006-10-28 03:50:40.000000000 +0900
+++ asm-3.1/test/perf/org/objectweb/asm/ALLPerfTest.java	2009-01-27 12:44:23.000000000 +0900
@@ -29,19 +29,9 @@
  */
 package org.objectweb.asm;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.List;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
 import javassist.ClassPool;
 import javassist.CtClass;
 import javassist.CtMethod;
-
 import org.apache.bcel.classfile.ClassParser;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Method;
@@ -57,16 +47,28 @@
 import org.objectweb.asm.tree.MethodNode;
 import org.objectweb.asm.tree.analysis.Analyzer;
 import org.objectweb.asm.tree.analysis.SimpleVerifier;
-
 import serp.bytecode.BCClass;
 import serp.bytecode.BCMethod;
 import serp.bytecode.Code;
 import serp.bytecode.Project;
 
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
 /**
  * @author Eric Bruneton
+ * @author Peter Lawrey
  */
-public abstract class ALLPerfTest extends ClassLoader {
+public abstract class ALLPerfTest {
 
     static boolean compute;
 
@@ -80,178 +82,250 @@
 
     static BCClass c;
 
-    public static void main(final String[] args) throws Exception {
-        String clazz = System.getProperty("asm.test.class");
-        ZipFile zip = new ZipFile(System.getProperty("java.home")
-                + "/lib/rt.jar");
-        List classes = new ArrayList();
+    static int repeats;
 
-        Enumeration entries = zip.entries();
-        while (entries.hasMoreElements()) {
-            ZipEntry e = (ZipEntry) entries.nextElement();
-            String s = e.getName();
-            if (s.endsWith(".class")) {
-                s = s.substring(0, s.length() - 6).replace('/', '.');
-                if (clazz == null || s.indexOf(clazz) != -1) {
-                    InputStream is = zip.getInputStream(e);
-                    classes.add(new ClassReader(is).b);
-                }
-            }
-        }
+    static List classes = new ArrayList();
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassReader cr = new ClassReader(b);
-                int access = cr.getAccess();
-                String className = cr.getClassName();
-                String superName = cr.getSuperName();
-                String[] interfaces = cr.getInterfaces();
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to get class info for " + classes.size()
-                    + " classes = " + t + " ms");
+    static List classNames = new ArrayList();
+
+    private static final Runnable NOTHING = new Runnable() {
+        public void run() {
         }
+    };
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                new ClassReader(b).accept(new EmptyVisitor(), 0);
+    private static final int MAX_ITERATION_SEC = Integer.getInteger("max.iteration.sec",
+            10)
+            .intValue();
+
+    public static void main(final String[] args)
+            throws IOException, InterruptedException
+    {
+        String clazz = System.getProperty("asm.test.class");
+        List jars = findFiles(System.getProperty("java.home"), ".jar");
+        jars.addAll(findJars(File.pathSeparatorChar,
+                System.getProperty("java.class.path")));
+        repeats = Integer.getInteger("repeats", 3).intValue() + 1;
+
+        Set classesFound = new HashSet();
+        for (int i = 0; i < jars.size(); i++) {
+            ZipFile zip;
+            try {
+                zip = new ZipFile((String) jars.get(i));
+            } catch (IOException e) {
+                System.err.println("Error openning " + jars.get(i));
+                e.printStackTrace();
+                continue;
+            }
+
+            Enumeration entries = zip.entries();
+            while (entries.hasMoreElements()) {
+                ZipEntry e = (ZipEntry) entries.nextElement();
+                String s = e.getName();
+                if (s.endsWith(".class")) {
+                    s = s.substring(0, s.length() - 6).replace('/', '.');
+                    if (!classesFound.add(s)) {
+                        continue;
+                    }
+                    if (clazz == null || s.indexOf(clazz) != -1) {
+                        InputStream is = zip.getInputStream(e);
+                        byte[] bytes = new ClassReader(is).b;
+                        classes.add(bytes);
+                        classNames.add(s);
+                        is.close();
+                        if (classes.size() % 2500 == 0) {
+                            System.out.println("... searching, found "
+                                    + classes.size() + " classes.");
+                        }
+                    }
+                }
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize " + classes.size()
-                    + " classes = " + t + " ms");
+            zip.close();
         }
-        
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassWriter cw = new ClassWriter(0);
-                new ClassReader(b).accept(cw, 0);
-                cw.toByteArray();
+        System.out.println("Found " + classes.size() + " classes.");
+
+        RunTest nullBCELAdapt = new RunTest() {
+            public void test(byte[] bytes, int[] errors) throws IOException {
+                nullBCELAdapt(bytes);
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes = " + t + " ms");
-        }
+        };
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassReader cr = new ClassReader(b);
-                ClassWriter cw = new ClassWriter(cr, 0);
-                cr.accept(cw, 0);
-                cw.toByteArray();
+        RunTest nullAspectjBCELAdapt = new RunTest() {
+            public void test(byte[] bytes, int[] errors) throws IOException {
+                nullAspectjBCELAdapt(bytes);
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with copyPool = " + t + " ms");
-        }
+        };
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
-                new ClassReader(b).accept(cw, 0);
-                cw.toByteArray();
+        Runnable createClassPool = new Runnable() {
+            public void run() {
+                pool = new ClassPool(null);
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with computeMaxs = " + t
-                    + " ms");
-        }
+        };
 
-        for (int i = 0; i < 10; ++i) {
-            int errors = 0;
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
-                try {
-                    new ClassReader(b).accept(cw, 0);
-                } catch (Throwable e) {
-                    ++errors;
-                }
-                cw.toByteArray();
+        RunTest nullJavassistAdapt = new RunTest() {
+            public void test(byte[] bytes, int[] errors) throws Exception {
+                nullJavassistAdapt(bytes);
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with computeFrames = " + t
-                    + " ms (" + errors + " errors)");
-        }
+        };
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassWriter cw = new ClassWriter(0);
-                new ClassReader(b).accept(new ClassAdapter(cw) {
+        Runnable createProject = new Runnable() {
+            public void run() {
+                p = new Project();
+                c = null;
+            }
+        };
 
-                    public MethodVisitor visitMethod(
-                        final int access,
-                        final String name,
-                        final String desc,
-                        final String signature,
-                        final String[] exceptions)
-                    {
-                        return new LocalVariablesSorter(access,
-                                desc,
-                                cv.visitMethod(access,
-                                        name,
-                                        desc,
-                                        signature,
-                                        exceptions));
-                    }
+        RunTest nullSERPAdapt = new RunTest() {
+            public void test(byte[] bytes, int[] errors) throws Exception {
+                nullSERPAdapt(bytes);
+            }
+        };
 
-                }, ClassReader.EXPAND_FRAMES);
-                cw.toByteArray();
+        // get class info and deserialize tests
+        
+        runTestAll("get class info", "", NOTHING, new RunTest() {
+            public void test(byte[] bytes, int[] errors) {
+                ClassReader cr = new ClassReader(bytes);
+                cr.getAccess();
+                cr.getClassName();
+                cr.getSuperName();
+                cr.getInterfaces();
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with LocalVariablesSorter = "
-                    + t + " ms");
-        }
+        });
+        
+        runTestAll("deserialize", "", NOTHING, new RunTest() {
+            public void test(byte[] bytes, int[] errors) {
+                new ClassReader(bytes).accept(new EmptyVisitor(), 0);
+            }
+        });
 
+        runTest("deserialize", "tree package", NOTHING, new RunTest() {
+            public void test(byte[] bytes, int[] errors) {
+                new ClassReader(bytes).accept(new ClassNode(), 0);
+            }
+        });
+        
         System.out.println();
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                new ClassReader(b).accept(new ClassNode(), 0);
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize " + classes.size()
-                    + " classes with tree package = " + t + " ms");
-        }
+        // deserialize and reserialize tests
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
+        runTestAll("deserialize and reserialize", "", NOTHING, new RunTest() {
+            public void test(byte[] bytes, int[] errors) {
+                ClassReader cr = new ClassReader(bytes);
                 ClassWriter cw = new ClassWriter(0);
-                ClassNode cn = new ClassNode();
-                new ClassReader(b).accept(cn, 0);
-                cn.accept(cw);
+                cr.accept(cw, 0);
                 cw.toByteArray();
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with tree package = " + t
-                    + " ms");
-        }
+        });
 
-        for (int i = 0; i < 10; ++i) {
-            int errors = 0;
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size() / 10; ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                ClassReader cr = new ClassReader(b);
+        runTestAll("deserialize and reserialize",
+                "copyPool",
+                NOTHING,
+                new RunTest() {
+                    public void test(byte[] bytes, int[] errors) {
+                        ClassReader cr = new ClassReader(bytes);
+                        ClassWriter cw = new ClassWriter(cr, 0);
+                        cr.accept(cw, 0);
+                        cw.toByteArray();
+                    }
+                });
+
+        runTest("deserialize and reserialize",
+                "tree package",
+                NOTHING,
+                new RunTest() {
+                    public void test(byte[] bytes, int[] errors) {
+                        ClassWriter cw = new ClassWriter(0);
+                        ClassNode cn = new ClassNode();
+                        new ClassReader(bytes).accept(cn, 0);
+                        cn.accept(cw);
+                        cw.toByteArray();
+                    }
+                });
+
+        compute = false;
+        computeFrames = false;
+        pool = null;
+        
+        runTest("deserialize and reserialize", "BCEL", NOTHING, nullBCELAdapt);
+
+        runTest("deserialize and reserialize",
+                "Aspectj BCEL",
+                NOTHING,
+                nullAspectjBCELAdapt);
+        
+        runTest("deserialize and reserialize",
+                "Javassist",
+                createClassPool,
+                nullJavassistAdapt);
+
+        runTest("deserialize and reserialize",
+                "SERP",
+                createProject,
+                nullSERPAdapt);
+
+        System.out.println();
+
+        // deserialize and reserialize tests with computeMaxs
+
+        runTest("deserialize and reserialize",
+                "computeMaxs",
+                NOTHING,
+                new RunTest() {
+                    public void test(byte[] bytes, int[] errors) {
+                        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
+                        new ClassReader(bytes).accept(cw, 0);
+                        cw.toByteArray();
+                    }
+                });
+
+        compute = true;
+        computeFrames = false;
+
+        runTest("deserialize and reserialize",
+                "BCEL and computeMaxs",
+                NOTHING,
+                nullBCELAdapt);
+
+        runTest("deserialize and reserialize",
+                "Aspectj BCEL and computeMaxs",
+                NOTHING,
+                nullAspectjBCELAdapt);
+        
+        // misc. tests
+
+        runTest("deserialize and reserialize",
+                "LocalVariablesSorter",
+                NOTHING,
+                new RunTest() {
+                    public void test(byte[] bytes, int[] errors) {
+                        ClassWriter cw = new ClassWriter(0);
+                        new ClassReader(bytes).accept(new ClassAdapter(cw) {
+
+                            public MethodVisitor visitMethod(
+                                final int access,
+                                final String name,
+                                final String desc,
+                                final String signature,
+                                final String[] exceptions)
+                            {
+                                return new LocalVariablesSorter(access,
+                                        desc,
+                                        cv.visitMethod(access,
+                                                name,
+                                                desc,
+                                                signature,
+                                                exceptions));
+                            }
+                        }, ClassReader.EXPAND_FRAMES);
+                        cw.toByteArray();
+                    }
+                });
+
+        // This test repeatedly tests the same classes as SimpleVerifier
+        // actually calls Class.forName() on the class which fills the PermGen
+        runTestSome("analyze", "SimpleVerifier", NOTHING, new RunTest() {
+            public void test(byte[] bytes, int[] errors) {
+                ClassReader cr = new ClassReader(bytes);
                 ClassNode cn = new ClassNode();
                 cr.accept(cn, ClassReader.SKIP_DEBUG);
                 List methods = cn.methods;
@@ -261,145 +335,200 @@
                     try {
                         a.analyze(cn.name, method);
                     } catch (Throwable th) {
-                        ++errors;
+                        // System.err.println(th);
+                        ++errors[0];
                     }
                 }
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to analyze " + classes.size() / 10
-                    + " classes with SimpleVerifier = " + t + " ms (" + errors
-                    + " errors)");
-        }
-        System.out.println();
+        });
 
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullBCELAdapt(b);
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with BCEL = " + t + " ms");
-        }
+        System.out.println();
+        
+        // deserialize and reserialize tests with computeFrames
 
-        compute = true;
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullBCELAdapt(b);
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with BCEL and computeMaxs = "
-                    + t + " ms");
-        }
+        runTest("deserialize and reserialize",
+                "computeFrames",
+                NOTHING,
+                new RunTest() {
+                    public void test(byte[] bytes, int[] errors) {
+                        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+                        new ClassReader(bytes).accept(cw, 0);
+                        cw.toByteArray();
+                    }
+                });
 
+        // the BCEL+computeFrames tests must be done only at the end, because
+        // after them other tests run very slowly, for some unknown reason 
+        // (memory usage?)
         compute = false;
         computeFrames = true;
-        for (int i = 0; i < 10; ++i) {
-            int errors = 0;
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                try {
-                    nullBCELAdapt(b);
-                } catch (Throwable e) {
-                    ++errors;
-                }
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size()
-                    + " classes with BCEL and computeFrames = " + t + " ms ("
-                    + errors + " errors)");
-        }
+        runTest("deserialize and reserialize",
+                "BCEL and computeFrames",
+                NOTHING,
+                nullBCELAdapt);
+
+        runTest("deserialize and reserialize",
+                "Aspectj BCEL and computeFrames",
+                NOTHING,
+                nullAspectjBCELAdapt);
+    }
 
-        System.out.println();
+    public static List findFiles(String directory, String suffix) {
+        List matches = new ArrayList();
+        findFiles(matches, new File(directory), suffix);
+        return matches;
+    }
 
-        compute = false;
-        computeFrames = false;
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullAspectjBCELAdapt(b);
+    static void findFiles(List matches, File directory, String suffix) {
+        File[] files = directory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            if (file.isDirectory()) {
+                findFiles(matches, file, suffix);
+            } else if (file.getName().endsWith(suffix)) {
+                matches.add(file.getAbsolutePath());
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with Aspectj BCEL = " + t
-                    + " ms");
         }
+    }
 
-        compute = true;
-        for (int i = 0; i < 10; ++i) {
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullAspectjBCELAdapt(b);
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size()
-                    + " classes with Aspectj BCEL and computeMaxs = " + t
-                    + " ms");
-        }
+    interface RunTest {
+        public void test(byte[] bytes, int[] errors) throws Exception;
+    }
 
-        compute = false;
-        computeFrames = true;
-        for (int i = 0; i < 10; ++i) {
-            int errors = 0;
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
+    static void runTestAll(
+        String testName,
+        String with,
+        Runnable init,
+        RunTest runTest) throws InterruptedException
+    {
+        runTest0(1, true, testName, with, init, runTest);
+    }
+
+    static void runTest(
+        String testName,
+        String with,
+        Runnable init,
+        RunTest runTest) throws InterruptedException
+    {
+        runTest0(repeats - 1, false, testName, with, init, runTest);
+    }
+
+    static void runTestSome(
+        String testName,
+        String with,
+        Runnable init,
+        RunTest runTest) throws InterruptedException
+    {
+        runTest0(repeats - 1, true, testName, with, init, runTest);
+    }
+
+    private static void runTest0(
+        int testSkip,
+        boolean startAtZero,
+        String testName,
+        String with,
+        Runnable init,
+        RunTest runTest) throws InterruptedException
+    {
+        if (with.length() > 0) {
+            with = " with " + with;
+        }
+        boolean skipBigClasses = with.contains("BCEL and computeFrames");
+        int totalCount = 0;
+        long totalSize = 0;
+        long totalTime = 0;
+        System.out.println("\nStarting " + testName + with + " test.");
+        for (int i = 0; i < repeats; ++i) {
+            init.run();
+            long t = System.currentTimeMillis();
+            int count = 0;
+            long size = 0;
+            int[] errors = { 0 };
+            long longest = 0;
+            int longestSize = 0;
+            int skipped = 0;
+            for (int j = startAtZero ? 0 : i; j < classes.size(); j += testSkip)
+            {
+                count++;
+                byte[] b = (byte[]) classes.get(j);
+                if (skipBigClasses && b.length > 16 * 1024) {
+                    skipped++;
+                    continue;
+                }
+                size += b.length;
                 try {
-                    nullAspectjBCELAdapt(b);
+                    long start = System.currentTimeMillis();
+                    runTest.test(b, errors);
+                    long end = System.currentTimeMillis();
+                    long time = end - start;
+                    if (longest < time) {
+                        longest = time;
+                        longestSize = b.length;
+                    }
+                    if (time > MAX_ITERATION_SEC * 1000 / 10) {
+                        System.out.println("--- time to " + testName
+                                + " the class " + classNames.get(j) + with
+                                + " took " + time + " ms. bytes=" + b.length);
+                    }
+                    if (end - t > MAX_ITERATION_SEC * 1000) {
+                        // System.out.println("Stopping iteration due to a
+                        // longer run time.");
+                        break;
+                    }
+                } catch (Exception ignored) {
+                    errors[0]++;
                 } catch (Throwable e) {
-                    ++errors;
+                    System.err.println(classNames.get(j) + ": " + e);
+                    errors[0]++;
                 }
             }
             t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size()
-                    + " classes with Aspectj BCEL and computeFrames = " + t
-                    + " ms (" + errors + " errors)");
-        }
-
-        System.out.println();
-
-        compute = false;
-        computeFrames = false;
-        for (int i = 0; i < 10; ++i) {
-            pool = new ClassPool(null);
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullJavassistAdapt(b);
-            }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with Javassist = " + t + " ms");
-        }
-
-        System.out.println();
+            String errorStr = errors[0] > 0
+                    ? " (" + errors[0] + " errors)"
+                    : "";
+            String skippedStr = skipped == 0
+                    ? ""
+                    : " ("
+                            + skipped
+                            + " skipped as BCEL/computeFrames on >16K classes is very slow)";
+            String longestStr = "";
+            if (longest > 50) {
+                longestStr = " the longest took " + longest + " ms (" + longestSize + " bytes)";
+            }
+            if (i > 0) {
+                System.out.println("- to " + testName + ' ' + count
+                        + " classes" + with + " = " + t + " ms" + errorStr
+                        + longestStr + skippedStr + '.');
+                totalCount += count;
+                totalSize += size;
+                totalTime += t;
+            }
+        }
+        System.out.println("Time to " + testName + ' ' + totalCount
+                + " classes" + with + " = " + totalTime + " ms.\n"
+                + "Processing rate = " + totalCount * 1000 / totalTime
+                + " classes per sec (" + totalSize * 1000 / totalTime / 1024
+                + " kB per sec).");
+        System.gc();
+        Thread.sleep(2500);
+    }
 
-        for (int i = 0; i < 10; ++i) {
-            p = new Project();
-            c = null;
-            long t = System.currentTimeMillis();
-            for (int j = 0; j < classes.size(); ++j) {
-                byte[] b = (byte[]) classes.get(j);
-                nullSERPAdapt(b);
+    private static List findJars(char pathSeparatorChar, String s) {
+        List ret = new ArrayList();
+        int start = 0;
+        int pos = s.indexOf(pathSeparatorChar);
+        while (pos >= 0) {
+            String name = s.substring(start, pos);
+            if (name.endsWith(".jar")) {
+                ret.add(name);
             }
-            t = System.currentTimeMillis() - t;
-            System.out.println("Time to deserialize and reserialize "
-                    + classes.size() + " classes with SERP = " + t + " ms");
+            start = pos + 1;
+            pos = s.indexOf(pathSeparatorChar, start);
         }
-
+        return ret;
     }
 
-    private static void nullBCELAdapt(final byte[] b) throws IOException {
+    static void nullBCELAdapt(final byte[] b) throws IOException {
         JavaClass jc = new ClassParser(new ByteArrayInputStream(b),
                 "class-name").parse();
         ClassGen cg = new ClassGen(jc);
@@ -437,8 +566,7 @@
         cg.getJavaClass().getBytes();
     }
 
-    private static void nullAspectjBCELAdapt(final byte[] b) throws IOException
-    {
+    static void nullAspectjBCELAdapt(final byte[] b) throws IOException {
         org.aspectj.apache.bcel.classfile.JavaClass jc = new org.aspectj.apache.bcel.classfile.ClassParser(new ByteArrayInputStream(b),
                 "class-name").parse();
         org.aspectj.apache.bcel.generic.ClassGen cg = new org.aspectj.apache.bcel.generic.ClassGen(jc);
@@ -478,7 +606,7 @@
         cg.getJavaClass().getBytes();
     }
 
-    private static void nullJavassistAdapt(final byte[] b) throws Exception {
+    static void nullJavassistAdapt(final byte[] b) throws Exception {
         CtClass cc = pool.makeClass(new ByteArrayInputStream(b));
         CtMethod[] ms = cc.getDeclaredMethods();
         for (int j = 0; j < ms.length; ++j) {
@@ -492,7 +620,7 @@
         cc.toBytecode();
     }
 
-    private static void nullSERPAdapt(final byte[] b) throws Exception {
+    static void nullSERPAdapt(final byte[] b) throws Exception {
         if (c != null) {
             p.removeClass(c);
         }
diff -uNr asm-3.1.orig/test/perf/org/objectweb/asm/GenPerfTest.java asm-3.1/test/perf/org/objectweb/asm/GenPerfTest.java
--- asm-3.1.orig/test/perf/org/objectweb/asm/GenPerfTest.java	1970-01-01 09:00:00.000000000 +0900
+++ asm-3.1/test/perf/org/objectweb/asm/GenPerfTest.java	2009-01-27 13:12:51.000000000 +0900
@@ -0,0 +1,660 @@
+/***
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2005 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.objectweb.asm;
+
+import gnu.bytecode.Access;
+import gnu.bytecode.ClassType;
+import gnu.bytecode.CodeAttr;
+import gnu.bytecode.Field;
+import gnu.bytecode.Method;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+
+import jbet.Descriptor;
+import jbet.Instruction;
+import jbet.Snippit;
+
+import org.apache.bcel.Constants;
+import org.apache.bcel.generic.ArrayType;
+import org.apache.bcel.generic.ClassGen;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.MethodGen;
+import org.apache.bcel.generic.PUSH;
+
+import org.cojen.classfile.MethodInfo;
+import org.cojen.classfile.Modifiers;
+import org.cojen.classfile.TypeDesc;
+
+import org.gjt.jclasslib.bytecode.ImmediateByteInstruction;
+import org.gjt.jclasslib.bytecode.ImmediateShortInstruction;
+import org.gjt.jclasslib.bytecode.SimpleInstruction;
+import org.gjt.jclasslib.io.ByteCodeWriter;
+import org.gjt.jclasslib.structures.AccessFlags;
+import org.gjt.jclasslib.structures.AttributeInfo;
+import org.gjt.jclasslib.structures.CPInfo;
+import org.gjt.jclasslib.structures.ConstantPoolUtil;
+import org.gjt.jclasslib.structures.InvalidByteCodeException;
+import org.gjt.jclasslib.structures.attributes.CodeAttribute;
+import org.gjt.jclasslib.structures.attributes.SourceFileAttribute;
+import org.gjt.jclasslib.structures.constants.ConstantStringInfo;
+
+import org.mozilla.classfile.ByteCode;
+import org.mozilla.classfile.ClassFileWriter;
+
+import alt.jiapi.reflect.InstructionFactory;
+import alt.jiapi.reflect.InstructionList;
+import alt.jiapi.reflect.JiapiClass;
+import alt.jiapi.reflect.JiapiMethod;
+import alt.jiapi.reflect.MethodExistsException;
+import alt.jiapi.reflect.Signature;
+
+import com.claritysys.jvm.builder.CodeBuilder;
+import com.claritysys.jvm.classfile.CfMethod;
+import com.claritysys.jvm.classfile.ClassFile;
+import com.claritysys.jvm.classfile.ConstantPool;
+import com.claritysys.jvm.classfile.JVM;
+
+/**
+ * Performance tests for frameworks that can only do bytecode generation.
+ * 
+ * @author Eric Bruneton
+ */
+public class GenPerfTest {
+
+    final static int N = 100000;
+
+    public static void main(String[] args) throws Exception {
+        for (int i = 0; i < 5; ++i) {
+            asmTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            gnuByteCodeTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            csgBytecodeTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            cojenTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            jbetTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            jClassLibTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            jiapiTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            mozillaClassFileTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            bcelTest();
+        }
+        for (int i = 0; i < 5; ++i) {
+            aspectjBcelTest();
+        }
+    }
+
+    static void asmTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            asmHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("ASM generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void gnuByteCodeTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            gnuByteCodeHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("gnu.bytecode generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void csgBytecodeTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            csgBytecodeHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("CSG bytecode generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void cojenTest() throws IOException {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            cojenHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("Cojen generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void jbetTest() throws IOException {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            jbetHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("JBET generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void jClassLibTest() throws IOException, InvalidByteCodeException {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            jClassLibHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("JClassLib generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void jiapiTest() throws MethodExistsException {
+        int N = 1000;
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            jiapiHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("Jiapi generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void mozillaClassFileTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            mozillaClassFileHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("Mozilla Class File generation time: " + ((float) t)
+                / N + " ms/class");
+    }
+
+    static void bcelTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            bcelHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("BCEL generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static void aspectjBcelTest() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < N; ++i) {
+            aspectjBcelHelloWorld();
+        }
+        t = System.currentTimeMillis() - t;
+        System.out.println("AspectJ BCEL generation time: " + ((float) t) / N
+                + " ms/class");
+    }
+
+    static byte[] asmHelloWorld() {
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
+
+        cw.visit(Opcodes.V1_1,
+                Opcodes.ACC_PUBLIC,
+                "HelloWorld",
+                null,
+                "java/lang/Object",
+                null);
+        cw.visitSource("HelloWorld.java", null);
+
+        MethodVisitor mw = cw.visitMethod(Opcodes.ACC_PUBLIC,
+                "<init>",
+                "()V",
+                null,
+                null);
+        mw.visitVarInsn(Opcodes.ALOAD, 0);
+        mw.visitMethodInsn(Opcodes.INVOKESPECIAL,
+                "java/lang/Object",
+                "<init>",
+                "()V");
+        mw.visitInsn(Opcodes.RETURN);
+        mw.visitMaxs(0, 0);
+        mw.visitEnd();
+
+        mw = cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC,
+                "main",
+                "([Ljava/lang/String;)V",
+                null,
+                null);
+        mw.visitFieldInsn(Opcodes.GETSTATIC,
+                "java/lang/System",
+                "out",
+                "Ljava/io/PrintStream;");
+        mw.visitLdcInsn("Hello world!");
+        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
+                "java/io/PrintStream",
+                "println",
+                "(Ljava/lang/String;)V");
+        mw.visitInsn(Opcodes.RETURN);
+        mw.visitMaxs(0, 0);
+        mw.visitEnd();
+
+        return cw.toByteArray();
+    }
+
+    static Method objectCtor = gnu.bytecode.Type.pointer_type.getDeclaredMethod("<init>",
+            0);
+
+    static Field outField = ClassType.make("java.lang.System").getField("out");
+
+    static Method printlnMethod = ClassType.make("java.io.PrintStream")
+            .getDeclaredMethod("println",
+                    new gnu.bytecode.Type[] { gnu.bytecode.Type.string_type });
+
+    static byte[] gnuByteCodeHelloWorld() {
+        ClassType c = new ClassType("HelloWorld");
+        c.setSuper("java.lang.Object");
+        c.setModifiers(Access.PUBLIC);
+        c.setSourceFile("HelloWorld.java");
+
+        Method m = c.addMethod("<init>", "()V", Access.PUBLIC);
+        CodeAttr code = m.startCode();
+        code.pushScope();
+        code.emitPushThis();
+        code.emitInvokeSpecial(objectCtor);
+        code.emitReturn();
+        code.popScope();
+
+        m = c.addMethod("main", "([Ljava/lang/String;)V", Access.PUBLIC
+                | Access.STATIC);
+        code = m.startCode();
+        code.pushScope();
+        code.emitGetStatic(outField);
+        code.emitPushString("Hello world!");
+        code.emitInvokeVirtual(printlnMethod);
+        code.emitReturn();
+        code.popScope();
+
+        return c.writeToArray();
+    }
+
+    static byte[] csgBytecodeHelloWorld() {
+        ClassFile cf = new ClassFile("HelloWorld",
+                "java/lang/Object",
+                "HelloWorld.java");
+        ConstantPool cp = cf.getConstantPool();
+
+        CfMethod method = cf.addMethod(JVM.ACC_PUBLIC, "<init>", "()V");
+        CodeBuilder code = new CodeBuilder(method);
+        code.add(JVM.ALOAD_0);
+        code.add(JVM.INVOKESPECIAL, cp.addMethodRef(false,
+                "java/lang/Object",
+                "<init>",
+                "()V"));
+        code.add(JVM.RETURN);
+        code.flush();
+
+        method = cf.addMethod(JVM.ACC_PUBLIC + JVM.ACC_STATIC,
+                "main",
+                "([Ljava/lang/String;)V");
+        code = new CodeBuilder(method);
+        code.add(JVM.GETSTATIC, cp.addFieldRef("java/lang/System",
+                "out",
+                "Ljava/io/PrintStream;"));
+        code.add(JVM.LDC, "Hello world!");
+        code.add(JVM.INVOKEVIRTUAL, cp.addMethodRef(false,
+                "java/io/PrintStream",
+                "println",
+                "(Ljava/lang/String;)V"));
+        code.add(JVM.RETURN);
+        code.flush();
+
+        return cf.writeToArray();
+    }
+
+    static TypeDesc printStream = TypeDesc.forClass("java.io.PrintStream");
+
+    static byte[] cojenHelloWorld() throws IOException {
+        org.cojen.classfile.ClassFile cf = new org.cojen.classfile.ClassFile("HelloWorld");
+
+        cf.setSourceFile("HelloWorld.java");
+
+        cf.addDefaultConstructor();
+
+        TypeDesc[] params = new TypeDesc[] { TypeDesc.STRING.toArrayType() };
+        MethodInfo mi = cf.addMethod(Modifiers.PUBLIC_STATIC,
+                "main",
+                null,
+                params);
+        org.cojen.classfile.CodeBuilder b = new org.cojen.classfile.CodeBuilder(mi);
+        b.loadStaticField("java.lang.System", "out", printStream);
+        b.loadConstant("Hello world!");
+        b.invokeVirtual(printStream,
+                "println",
+                null,
+                new TypeDesc[] { TypeDesc.STRING });
+        b.returnVoid();
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        cf.writeTo(bos);
+
+        return bos.toByteArray();
+    }
+
+    static Descriptor emptyDesc = new Descriptor("()V");
+
+    static Descriptor mainDesc = new Descriptor("([Ljava/lang/String;)V");
+
+    static Descriptor printlnDesc = new Descriptor("(Ljava/lang/String;)V");
+
+    static jbet.Type printStreamType = new jbet.Type("Ljava/io/PrintStream;");
+
+    static byte[] jbetHelloWorld() throws IOException {
+        jbet.ClassInfo ci = new jbet.ClassInfo(null, "HelloWorld");
+
+        ci.sourceFile = "HelloWorld.java";
+
+        jbet.MethodInfo mi = new jbet.MethodInfo("<init>",
+                emptyDesc,
+                jbet.MethodInfo.ACC_PUBLIC);
+        mi.code = new Snippit();
+        mi.code.push(new Instruction().setAload(0));
+        mi.code.push(new Instruction().setInvokeSpecial("java/lang/Object",
+                "<init>",
+                emptyDesc));
+        mi.code.push(new Instruction().setReturn());
+        mi.maxLocals = 1;
+        mi.maxStack = 1;
+        ci.addMethod(mi);
+
+        mi = new jbet.MethodInfo("main", mainDesc, jbet.MethodInfo.ACC_PUBLIC
+                | jbet.MethodInfo.ACC_STATIC);
+        mi.code = new Snippit();
+        mi.code.push(new Instruction().setGetstatic("java/lang/System",
+                "out",
+                printStreamType));
+        mi.code.push(new Instruction().setSpush("Hello world!"));
+        mi.code.push(new Instruction().setInvokeVirtual("java/io/PrintStream",
+                "println",
+                printlnDesc));
+        mi.maxLocals = 1;
+        mi.maxStack = 2;
+        ci.addMethod(mi);
+
+        ci.resolveConstants();
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        ci.writeFile(bos);
+
+        return bos.toByteArray();
+    }
+
+    static byte[] jClassLibHelloWorld()
+            throws InvalidByteCodeException, IOException
+    {
+        org.gjt.jclasslib.structures.ClassFile cf = new org.gjt.jclasslib.structures.ClassFile();
+        cf.setConstantPool(new CPInfo[0]);
+        ConstantPoolUtil.addConstantUTF8Info(cf, "", 0); // dummy constant
+        cf.setMajorVersion(45);
+        cf.setMinorVersion(3);
+        cf.setAccessFlags(AccessFlags.ACC_PUBLIC);
+        cf.setThisClass(ConstantPoolUtil.addConstantClassInfo(cf,
+                "HelloWorld",
+                0));
+        cf.setSuperClass(ConstantPoolUtil.addConstantClassInfo(cf,
+                "java/lang/Object",
+                0));
+
+        SourceFileAttribute sa = new SourceFileAttribute();
+        sa.setAttributeNameIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                SourceFileAttribute.ATTRIBUTE_NAME,
+                0));
+        sa.setSourcefileIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                "HelloWorld.java",
+                0));
+
+        org.gjt.jclasslib.structures.MethodInfo mi1 = new org.gjt.jclasslib.structures.MethodInfo();
+        mi1.setAccessFlags(AccessFlags.ACC_PUBLIC);
+        mi1.setNameIndex(ConstantPoolUtil.addConstantUTF8Info(cf, "<init>", 0));
+        mi1.setDescriptorIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                "()V",
+                0));
+        CodeAttribute ca1 = new CodeAttribute();
+        ca1.setAttributeNameIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                CodeAttribute.ATTRIBUTE_NAME,
+                0));
+        ca1.setCode(ByteCodeWriter.writeByteCode(Arrays.asList(new org.gjt.jclasslib.bytecode.AbstractInstruction[] {
+            new SimpleInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_ALOAD_0),
+            new ImmediateShortInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_INVOKESPECIAL,
+                    ConstantPoolUtil.addConstantMethodrefInfo(cf,
+                            "java/lang/Object",
+                            "<init>",
+                            "()V",
+                            0)),
+            new SimpleInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_RETURN) })));
+        ca1.setMaxStack(1);
+        ca1.setMaxLocals(1);
+        mi1.setAttributes(new AttributeInfo[] { ca1 });
+
+        ConstantStringInfo s = new ConstantStringInfo();
+        s.setStringIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                "Hello world!",
+                0));
+
+        org.gjt.jclasslib.structures.MethodInfo mi2 = new org.gjt.jclasslib.structures.MethodInfo();
+        mi2.setAccessFlags(AccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC);
+        mi2.setNameIndex(ConstantPoolUtil.addConstantUTF8Info(cf, "main", 0));
+        mi2.setDescriptorIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                "([Ljava/lang/String;)V",
+                0));
+        CodeAttribute ca2 = new CodeAttribute();
+        ca2.setAttributeNameIndex(ConstantPoolUtil.addConstantUTF8Info(cf,
+                CodeAttribute.ATTRIBUTE_NAME,
+                0));
+        ca2.setCode(ByteCodeWriter.writeByteCode(Arrays.asList(new org.gjt.jclasslib.bytecode.AbstractInstruction[] {
+            new ImmediateShortInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_GETSTATIC,
+                    ConstantPoolUtil.addConstantFieldrefInfo(cf,
+                            "java/lang/System",
+                            "out",
+                            "Ljava/io/PrintStream;",
+                            0)),
+            new ImmediateByteInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_LDC,
+                    false,
+                    ConstantPoolUtil.addConstantPoolEntry(cf, s, 0)),
+            new ImmediateShortInstruction(org.gjt.jclasslib.bytecode.Opcodes.OPCODE_INVOKEVIRTUAL,
+                    ConstantPoolUtil.addConstantMethodrefInfo(cf,
+                            "java/io/PrintStream",
+                            "println",
+                            "(Ljava/lang/String;)V",
+                            0)) })));
+        ca2.setMaxStack(2);
+        ca2.setMaxLocals(1);
+        mi2.setAttributes(new AttributeInfo[] { ca2 });
+
+        cf.setMethods(new org.gjt.jclasslib.structures.MethodInfo[] { mi1, mi2 });
+        cf.setAttributes(new AttributeInfo[] { sa });
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        DataOutputStream dos = new DataOutputStream(bos);
+        cf.write(dos);
+        dos.close();
+
+        return bos.toByteArray();
+    }
+
+    static Signature emptySig = new Signature("()V");
+
+    static Signature mainSig = new Signature("([Ljava/lang/String;)V");
+
+    static Signature printlnSig = new Signature("(Ljava/lang/String;)V");
+
+    static byte[] jiapiHelloWorld() throws MethodExistsException {
+        JiapiClass c = JiapiClass.createClass("HelloWorld");
+
+        // No API to set SourceFile!
+
+        JiapiMethod method = c.addMethod(Modifier.PUBLIC, "<init>", emptySig);
+        InstructionList il = method.getInstructionList();
+        InstructionFactory iFactory = il.getInstructionFactory();
+        il.add(iFactory.aload(0));
+        il.add(iFactory.invoke(0, "java/lang/Object", "<init>", emptySig));
+        il.add(iFactory.returnMethod(method));
+
+        method = c.addMethod(Modifier.PUBLIC | Modifier.STATIC, "main", mainSig);
+        il = method.getInstructionList();
+        iFactory = il.getInstructionFactory();
+        il.add(iFactory.getField(Modifier.STATIC,
+                "java/lang/System",
+                "out",
+                "Ljava/io/PrintStream;"));
+        il.add(iFactory.pushConstant("Hello world!"));
+        il.add(iFactory.invoke(0, "java/io/PrintStream", "println", printlnSig));
+        il.add(iFactory.returnMethod(method));
+
+        return c.getByteCode();
+    }
+
+    static byte[] mozillaClassFileHelloWorld() {
+        ClassFileWriter c = new ClassFileWriter("HelloWorld",
+                "java/lang/Object",
+                "HelloWorld.java");
+
+        c.startMethod("<init>", "()V", ClassFileWriter.ACC_PUBLIC);
+        c.addLoadThis();
+        c.addInvoke(ByteCode.INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
+        c.add(ByteCode.RETURN);
+        c.stopMethod((short) 1);
+
+        c.startMethod("main",
+                "()V",
+                (short) (ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_STATIC));
+        c.add(ByteCode.GETSTATIC,
+                "java/lang/System",
+                "out",
+                "Ljava/io/PrintStream;");
+        c.addPush("Hello world!");
+        c.addInvoke(ByteCode.INVOKEVIRTUAL,
+                "java/io/PrintStream",
+                "println",
+                "(Ljava/lang/String;)V");
+        c.add(ByteCode.RETURN);
+        c.stopMethod((short) 1);
+
+        return c.toByteArray();
+    }
+
+    static org.apache.bcel.generic.Type printStreamT = org.apache.bcel.generic.Type.getType("Ljava/io/PrintStream;");
+
+    static byte[] bcelHelloWorld() {
+        ClassGen cg = new ClassGen("HelloWorld",
+                "java/lang/Object",
+                "HelloWorld.java",
+                Constants.ACC_PUBLIC,
+                null);
+
+        cg.addEmptyConstructor(Constants.ACC_PUBLIC);
+
+        ConstantPoolGen cp = cg.getConstantPool();
+        org.apache.bcel.generic.InstructionList il = new org.apache.bcel.generic.InstructionList();
+        org.apache.bcel.generic.InstructionFactory factory = new org.apache.bcel.generic.InstructionFactory(cg);
+
+        MethodGen mg = new MethodGen(Constants.ACC_STATIC
+                | Constants.ACC_PUBLIC,
+                org.apache.bcel.generic.Type.VOID,
+                new org.apache.bcel.generic.Type[] { new ArrayType(org.apache.bcel.generic.Type.STRING,
+                        1) },
+                null,
+                "main",
+                "HelloWorld",
+                il,
+                cp);
+        il.append(factory.createGetStatic("java/lang/System",
+                "out",
+                printStreamT));
+        il.append(new PUSH(cp, "Hello world!"));
+        il.append(factory.createInvoke("java.io.PrintStream",
+                "println",
+                org.apache.bcel.generic.Type.VOID,
+                new org.apache.bcel.generic.Type[] { org.apache.bcel.generic.Type.STRING },
+                Constants.INVOKESPECIAL));
+
+        mg.setMaxStack();
+        cg.addMethod(mg.getMethod());
+
+        return cg.getJavaClass().getBytes();
+    }
+
+    static org.aspectj.apache.bcel.generic.Type printStreamAT = org.aspectj.apache.bcel.generic.Type.getType("Ljava/io/PrintStream;");
+
+    static byte[] aspectjBcelHelloWorld() {
+        org.aspectj.apache.bcel.generic.ClassGen cg = new org.aspectj.apache.bcel.generic.ClassGen("HelloWorld",
+                "java/lang/Object",
+                "HelloWorld.java",
+                Constants.ACC_PUBLIC,
+                null);
+
+        cg.addEmptyConstructor(Constants.ACC_PUBLIC);
+
+        org.aspectj.apache.bcel.generic.ConstantPoolGen cp = cg.getConstantPool();
+        org.aspectj.apache.bcel.generic.InstructionList il = new org.aspectj.apache.bcel.generic.InstructionList();
+        org.aspectj.apache.bcel.generic.InstructionFactory factory = new org.aspectj.apache.bcel.generic.InstructionFactory(cg);
+
+        org.aspectj.apache.bcel.generic.MethodGen mg = new org.aspectj.apache.bcel.generic.MethodGen(Constants.ACC_STATIC
+                | Constants.ACC_PUBLIC,
+                org.aspectj.apache.bcel.generic.Type.VOID,
+                new org.aspectj.apache.bcel.generic.Type[] { new org.aspectj.apache.bcel.generic.ArrayType(org.aspectj.apache.bcel.generic.Type.STRING,
+                        1) },
+                null,
+                "main",
+                "HelloWorld",
+                il,
+                cp);
+        il.append(factory.createGetStatic("java/lang/System",
+                "out",
+                printStreamAT));
+        il.append(new org.aspectj.apache.bcel.generic.PUSH(cp, "Hello world!"));
+        il.append(factory.createInvoke("java.io.PrintStream",
+                "println",
+                org.aspectj.apache.bcel.generic.Type.VOID,
+                new org.aspectj.apache.bcel.generic.Type[] { org.aspectj.apache.bcel.generic.Type.STRING },
+                Constants.INVOKESPECIAL));
+
+        mg.setMaxStack();
+        cg.addMethod(mg.getMethod());
+
+        return cg.getJavaClass().getBytes();
+    }
+}
