diff -uNr pdfbox.orig/src/org/pdfbox/cos/COSName.java pdfbox/src/org/pdfbox/cos/COSName.java
--- pdfbox.orig/src/org/pdfbox/cos/COSName.java	2008-08-03 00:13:49.000000000 +0900
+++ pdfbox/src/org/pdfbox/cos/COSName.java	2008-08-03 00:19:21.000000000 +0900
@@ -131,14 +131,6 @@
     /**
     * A common COSName value.
     */
-    public static final COSName CCITTFAX_DECODE = new COSName( "CCITTFaxDecode" );
-    /**
-    * A common COSName value.
-    */
-    public static final COSName CCITTFAX_DECODE_ABBREVIATION = new COSName( "CCF" );
-    /**
-    * A common COSName value.
-    */
     public static final COSName COLORSPACE = new COSName( "ColorSpace" );
     /**
     * A common COSName value.
@@ -628,4 +620,4 @@
              }
          }
      }
-}
\ No newline at end of file
+}
diff -uNr pdfbox.orig/src/org/pdfbox/examples/pdmodel/AddImageToPDF.java pdfbox/src/org/pdfbox/examples/pdmodel/AddImageToPDF.java
--- pdfbox.orig/src/org/pdfbox/examples/pdmodel/AddImageToPDF.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/examples/pdmodel/AddImageToPDF.java	2008-08-03 00:21:06.000000000 +0900
@@ -42,7 +42,6 @@
 
 import org.pdfbox.pdmodel.edit.PDPageContentStream;
 
-import org.pdfbox.pdmodel.graphics.xobject.PDCcitt;
 import org.pdfbox.pdmodel.graphics.xobject.PDJpeg;
 import org.pdfbox.pdmodel.graphics.xobject.PDXObjectImage;
 
@@ -84,10 +83,6 @@
             {
                 ximage = new PDJpeg(doc, new FileInputStream( image ) );
             }
-            else if (image.toLowerCase().endsWith(".tif") || image.toLowerCase().endsWith(".tiff")) 
-            {
-                ximage = new PDCcitt(doc, new RandomAccessFile(new File(image),"r"));
-            }
             else
             {
                 //BufferedImage awtImage = ImageIO.read( new File( image ) );
@@ -144,4 +139,4 @@
     {
         System.err.println( "usage: " + this.getClass().getName() + " <input-pdf> <image> <output-pdf>" );
     }
-}
\ No newline at end of file
+}
diff -uNr pdfbox.orig/src/org/pdfbox/examples/pdmodel/ImageToPDF.java pdfbox/src/org/pdfbox/examples/pdmodel/ImageToPDF.java
--- pdfbox.orig/src/org/pdfbox/examples/pdmodel/ImageToPDF.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/examples/pdmodel/ImageToPDF.java	2008-08-03 00:21:41.000000000 +0900
@@ -42,7 +42,6 @@
 
 import org.pdfbox.pdmodel.edit.PDPageContentStream;
 
-import org.pdfbox.pdmodel.graphics.xobject.PDCcitt;
 import org.pdfbox.pdmodel.graphics.xobject.PDJpeg;
 import org.pdfbox.pdmodel.graphics.xobject.PDXObjectImage;
 
@@ -83,10 +82,6 @@
             {
                 ximage = new PDJpeg(doc, new FileInputStream( image ) );
             }
-            else if (image.toLowerCase().endsWith(".tif") || image.toLowerCase().endsWith(".tiff")) 
-            {
-                ximage = new PDCcitt(doc, new RandomAccessFile(new File(image),"r"));
-            }
             else
             {
                 //BufferedImage awtImage = ImageIO.read( new File( image ) );
@@ -143,4 +138,4 @@
     {
         System.err.println( "usage: " + this.getClass().getName() + " <output-file> <image>" );
     }
-}
\ No newline at end of file
+}
diff -uNr pdfbox.orig/src/org/pdfbox/filter/CCITTFaxDecodeFilter.java pdfbox/src/org/pdfbox/filter/CCITTFaxDecodeFilter.java
--- pdfbox.orig/src/org/pdfbox/filter/CCITTFaxDecodeFilter.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/filter/CCITTFaxDecodeFilter.java	1970-01-01 09:00:00.000000000 +0900
@@ -1,742 +0,0 @@
-/**
- * Copyright (c) 2003-2005, www.pdfbox.org
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. Neither the name of pdfbox; nor the names of its
- *    contributors may be used to endorse or promote products derived from this
- *    software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * http://www.pdfbox.org
- *
- */
-package org.pdfbox.filter;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import org.pdfbox.cos.COSArray;
-import org.pdfbox.cos.COSBase;
-import org.pdfbox.cos.COSDictionary;
-import org.pdfbox.cos.COSName;
-
-/**
- * This is a filter for the CCITTFax Decoder.
- * 
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @author Marcel Kammer
- * @author Paul King
- * @version $Revision: 1.13 $
- */
-public class CCITTFaxDecodeFilter implements Filter
-{   
-    // Filter will write 15 TAG's
-    // If you add or remove TAG's you will have to modify this value
-    private static final int TAG_COUNT = 15;
-
-    // HEADERLENGTH(fix 8 Bytes) plus ImageLength(variable)
-    private int offset = 8;
-
-    // Bytecounter for Bytes that will be written after the TAG-DICTIONARY
-    private int tailingBytesCount = 0;
-
-    // Bytes to write after TAG-DICTIONARY
-    private final ByteArrayOutputStream tailer = new ByteArrayOutputStream();
-
-    /**
-     * Constructor.
-     */
-    public CCITTFaxDecodeFilter()
-    {
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void decode(InputStream compressedData, OutputStream result, COSDictionary options, int filterIndex) throws IOException
-    {
-        // log.warn( "Warning: CCITTFaxDecode.decode is not implemented yet,
-        // skipping this stream." );
-        
-
-        // Get ImageParams from PDF
-        COSBase baseObj = options.getDictionaryObject(new String[] {"DecodeParms","DP"});
-        COSDictionary dict = null;
-        if( baseObj instanceof COSDictionary )
-        {
-            dict = (COSDictionary)baseObj;
-        }
-        else if( baseObj instanceof COSArray )
-        {
-            COSArray paramArray = (COSArray)baseObj;
-            if( filterIndex < paramArray.size() )
-            {
-                dict = (COSDictionary)paramArray.getObject( filterIndex );
-            }
-            else
-            {
-                throw new IOException( "Error: DecodeParms cannot be null for CCITTFaxDecode" );
-            }
-        }
-        else if( baseObj == null )
-        {
-            throw new IOException( "Error: DecodeParms cannot be null for CCITTFaxDecode" );
-        }
-        else 
-        {
-            throw new IOException( "Error: Expected COSArray or COSDictionary and not " + baseObj.getClass().getName() );
-        }
-        
-        int width = options.getInt("Width");
-        int height = options.getInt("Height");
-        int length = options.getInt(COSName.LENGTH);
-        int compressionType = dict.getInt("K");
-        boolean blackIs1 = dict.getBoolean("BlackIs1", false);        
-        
-        
-        // HEADER-INFO and starting point of TAG-DICTIONARY
-        writeTagHeader(result, length);
-
-        // IMAGE-DATA
-        int i = 0;
-        //int sum = 0;
-        byte[] buffer = new byte[32768];
-        int lentoread = length;
-        
-        while ((lentoread > 0) && ((i = compressedData.read(buffer, 0, Math.min(lentoread, 32768))) != -1))
-        {
-            //sum += i;
-            result.write(buffer, 0, i);
-            lentoread = lentoread - i;        
-        }
-        
-        // If lentoread is > 0 then we need to write out some padding to equal the header
-        // We'll use what we have in the buffer it's just padding after all
-        while (lentoread > 0) 
-        {
-            result.write(buffer, 0, Math.min(lentoread, 32768));
-            lentoread = lentoread - Math.min(lentoread, 32738);
-        }
-        //System.out.println("Gelesen: " + sum);
-
-        // TAG-COUNT
-        writeTagCount(result);
-
-        // WIDTH 0x0100
-        writeTagWidth(result, width);
-
-        // HEIGHT 0x0101
-        writeTagHeight(result, height);
-
-        // BITSPERSAMPLE 0x0102
-        // Always 1 for CCITTFax
-        writeTagBitsPerSample(result, 1);
-
-        // COMPRESSION 0x0103
-        writeTagCompression(result, compressionType);
-
-        // PHOTOMETRIC 0x0106
-        writeTagPhotometric(result, blackIs1);
-
-        // STRIPOFFSET 0x0111
-        // HERE ALWAYS 8, because ImageData comes before TAG-DICTIONARY
-        writeTagStripOffset(result, 8);
-
-        // ORIENTATION 0x0112
-        writeTagOrientation(result, 1);
-
-        // SamplesPerPixel 0x0115
-        writeTagSamplesPerPixel(result, 1);
-
-        // RowsPerStrip 0x0116
-        writeTagRowsPerStrip(result, height);
-
-        // Stripcount 0x0117
-        writeTagStripByteCount(result, length);
-
-        // XRESOLUTION 0x011A
-        // HERE: 200 DPI
-        writeTagXRes(result, 200, 1);
-
-        // YRESOLITION 0x011B
-        // HERE: 200 DPI
-        writeTagYRes(result, 200, 1);
-
-        // ResolutionUnit 0x0128
-        // HERE: DPI
-        writeTagResolutionUnit(result, 2);
-
-        // SOFTWARE 0x0131
-        // minimum 4 chars
-        writeTagSoftware(result, "pdfbox".getBytes());
-
-        // DATE AND TIME 0x0132
-        writeTagDateTime(result, new Date());
-
-        // END OF TAG-DICT
-        writeTagTailer(result);        
-    }
-
-    private void writeTagHeader(OutputStream result, int length) throws IOException
-    {
-        byte[] header = { 'M', 'M', 0, '*' };// Big-endian
-        result.write(header);
-
-
-        // Add imagelength to offset
-        offset += length;
-
-        // OFFSET TAG-DICTIONARY
-        int i1 = offset/16777216;//=value/(256*256*256)
-        int i2 = (offset-i1*16777216)/65536;
-        int i3 = (offset-i1*16777216-i2*65536)/256;
-        int i4 = offset % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-    }
-
-    private void writeTagCount(OutputStream result) throws IOException
-    {
-        result.write(TAG_COUNT / 256);
-        result.write(TAG_COUNT % 256);// tagCount
-    }
-
-    private void writeTagWidth(OutputStream result, int width) throws IOException
-    {
-        // @todo width berechnen
-
-        // TAG-ID 100
-        result.write(1);
-        result.write(0);
-
-
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-
-
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-
-
-        // TAG-VALUE = width
-        result.write(width/256);
-        result.write(width%256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-    
-    }
-
-    private void writeTagHeight(OutputStream result, int height) throws IOException
-    {
-        //@todo height berechnen
-        // TAG-ID 101
-        result.write(1);
-        result.write(1);
-    
-
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-        
-
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE
-        result.write(height/256);
-        result.write(height%256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagBitsPerSample(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 102
-        result.write(1);
-        result.write(2);
-        
-
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-    
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE
-        result.write(value/256);
-        result.write(value%256);
-        result.write(0);//SHORT=0
-        result.write(0);//SHORT=0
-        
-    }
-    
-    /**
-     * Write the tag compression.
-     * 
-     * @param result The stream to write to.
-     * @param type The type to write.
-     * @throws IOException If there is an error writing to the stream.
-     */
-    public void writeTagCompression(OutputStream result, int type) throws IOException
-    {
-        // TAG-ID 103
-        result.write(1);
-        result.write(3);
-        
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-        
-
-        // TAG-LEGNTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-        // TAG-VALUE
-        //@todo typ eintragen; hier immer 4
-        result.write(0);
-        if (type < 0)
-        {
-            result.write(4);// G4
-        }
-        else if (type == 0)
-        {
-            result.write(3);// G3-1D
-        }
-        else
-        {
-            result.write(2);// G3-2D
-        }
-        result.write(0);
-        result.write(0);
-        
-    }
-
-    private void writeTagPhotometric(OutputStream result, boolean blackIs1) throws IOException
-    {
-        // TAG-ID 106
-        result.write(1);
-        result.write(6);
-        
-
-        // TAG-TYPE SHORT
-        result.write(0);
-        result.write(3);
-        
-
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE
-        result.write(0);
-        if (blackIs1)
-        {
-            result.write(1);
-        }
-        else
-        {
-            result.write(0);
-        }
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagStripOffset(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 111
-        result.write(1);
-        result.write(17);
-        
-        // TAG-TYPE LONG=4
-        result.write(0);
-        result.write(4);
-        
-
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE = 8 //VOR TAG-DICTIONARY
-        int i1 = value/16777216;//=value/(256*256*256)
-        int i2 = (value-i1*16777216)/65536;
-        int i3 = (value-i1*16777216-i2*65536)/256;
-        int i4 = value % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-    
-    }
-
-    private void writeTagSamplesPerPixel(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 115
-        result.write(1);
-        result.write(21);
-        
-
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-        
-
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE
-        result.write(value / 256);
-        result.write(value % 256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagRowsPerStrip(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 116
-        result.write(1);
-        result.write(22);
-        
-
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-    
-
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-    
-
-        // TAG-VALUE
-        result.write(value / 256);
-        result.write(value % 256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagStripByteCount(OutputStream result, int value) throws IOException
-    {
-        //@todo value auswerten
-        // TAG-ID 117
-        result.write(1);
-        result.write(23);
-    
-        // TAG-TYPE LONG=4
-        result.write(0);
-        result.write(4);
-    
-
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-        // TAG-VALUE
-        int i1 = value/16777216;//=value/(256*256*256)
-        int i2 = (value-i1*16777216)/65536;
-        int i3 = (value-i1*16777216-i2*65536)/256;
-        int i4 = value % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-        
-    }
-
-    private void writeTagXRes(OutputStream result, int value1, int value2) throws IOException
-    {
-        // TAG-ID 11A
-        result.write(1);
-        result.write(26);
-        
-        // TAG-TYPE RATIONAL=5
-        result.write(0);
-        result.write(5);
-        
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE=OFFSET TO RATIONAL
-        int valueOffset = offset + 6 + 12 * TAG_COUNT + tailer.size();
-        int i1 = valueOffset/16777216;//=value/(256*256*256)
-        int i2 = (valueOffset-i1*16777216)/65536;
-        int i3 = (valueOffset-i1*16777216-i2*65536)/256;
-        int i4 = valueOffset % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-        
-        i1 = value1 /16777216;
-        i2 = (value1-i1*16777216)/65536;
-        i3 = (value1-i1*16777216 - i2*65536)/256;
-        i4 = value1 % 256;
-        tailer.write(i1);
-        tailer.write(i2);
-        tailer.write(i3);
-        tailer.write(i4);
-        
-        i1 = value2 /16777216;
-        i2 = (value2-i1*16777216)/65536;
-        i3 = (value2-i1*16777216 - i2*65536)/256;
-        i4 = value2 % 256;
-        tailer.write(i1);
-        tailer.write(i2);
-        tailer.write(i3);
-        tailer.write(i4);
-        
-        tailingBytesCount += 8;
-    }
-
-    private void writeTagYRes(OutputStream result, int value1, int value2) throws IOException
-    {
-        // TAG-ID 11B
-        result.write(1);
-        result.write(27);
-        
-
-        // TAG-TYPE RATIONAL=5
-        result.write(0);
-        result.write(5);
-        
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-
-        // TAG-VALUE=OFFSET TO RATIONAL
-        int valueOffset = offset + 6 + 12 * TAG_COUNT + tailer.size();
-        int i1 = valueOffset/16777216;//=value/(256*256*256)
-        int i2 = (valueOffset-i1*16777216)/65536;
-        int i3 = (valueOffset-i1*16777216-i2*65536)/256;
-        int i4 = valueOffset % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-        
-        i1 = value1 /16777216;
-        i2 = (value1-i1*16777216)/65536;
-        i3 = (value1-i1*16777216 - i2*65536)/256;
-        i4 = value1 % 256;
-        tailer.write(i1);
-        tailer.write(i2);
-        tailer.write(i3);
-        tailer.write(i4);
-        
-        i1 = value2 /16777216;
-        i2 = (value2-i1*16777216)/65536;
-        i3 = (value2-i1*16777216 - i2*65536)/256;
-        i4 = value2 % 256;
-        tailer.write(i1);
-        tailer.write(i2);
-        tailer.write(i3);
-        tailer.write(i4);
-        
-        tailingBytesCount += 8;
-    }
-
-    private void writeTagResolutionUnit(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 128
-        result.write(1);
-        result.write(40);
-        
-        // TAG-TYPE SHORT=3
-        result.write(0);
-        result.write(3);
-        
-        // TAG-LENGTH = 1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-        // TAG-VALUE
-        result.write(value/256);
-        result.write(value%256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagOrientation(OutputStream result, int value) throws IOException
-    {
-        // TAG-ID 112
-        result.write(1);
-        result.write(18);
-        
-        // TAG-TYPE SHORT = 3
-        result.write(0);
-        result.write(3);
-        
-
-        // TAG-LENGTH=1
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(1);
-        
-        // TAG-VALUE
-        result.write(value / 256);
-        result.write(value % 256);
-        result.write(0);// SHORT=0
-        result.write(0);// SHORT=0
-        
-    }
-
-    private void writeTagTailer(OutputStream result) throws IOException
-    {
-        // END OF TAG-DICTIONARY
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        
-        // TAILER WITH VALUES OF RATIONALFIELD's
-        result.write(tailer.toByteArray());
-    }
-
-    private void writeTagSoftware(OutputStream result, byte[] text) throws IOException
-    {
-        // TAG-ID 131
-        result.write(1);
-        result.write(49);
-        
-        // TAG-TYPE ASCII=2
-        result.write(0);
-        result.write(2);
-        
-
-        // TAG-LENGTH=id.length+1
-        result.write(0);
-        result.write(0);
-        result.write((text.length + 1) / 256);
-        result.write((text.length + 1) % 256);
-        
-        // TAG-VALUE
-        int valueOffset = offset + 6 + 12 * TAG_COUNT + tailer.size();
-        int i1 = valueOffset/16777216;//=value/(256*256*256)
-        int i2 = (valueOffset-i1*16777216)/65536;
-        int i3 = (valueOffset-i1*16777216-i2*65536)/256;
-        int i4 = valueOffset % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-        
-
-        tailer.write(text);
-        tailer.write(0);
-        tailingBytesCount += text.length + 1;
-    }
-
-    private void writeTagDateTime(OutputStream result, Date date) throws IOException
-    {
-        // TAG-ID 132
-        result.write(1);
-        result.write(50);
-        
-
-        // TAG-TYPE ASCII=2
-        result.write(0);
-        result.write(2);
-        
-
-        // TAG-LENGTH=20
-        result.write(0);
-        result.write(0);
-        result.write(0);
-        result.write(20);
-    
-
-        // TAG-VALUE
-        int valueOffset = offset + 6 + 12 * TAG_COUNT + tailer.size();
-        int i1 = valueOffset/16777216;//=value/(256*256*256)
-        int i2 = (valueOffset-i1*16777216)/65536;
-        int i3 = (valueOffset-i1*16777216-i2*65536)/256;
-        int i4 = valueOffset % 256;
-        result.write(i1);                
-        result.write(i2);
-        result.write(i3);        
-        result.write(i4);        
-        
-        SimpleDateFormat sdf = new SimpleDateFormat("yyyy:MM:dd HH:mm:ss");
-        String datetime = sdf.format(date);
-        tailer.write(datetime.getBytes());
-        tailer.write(0);
-
-        tailingBytesCount += 20;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void encode(InputStream rawData, OutputStream result, COSDictionary options, int filterIndex ) throws IOException
-    {
-        System.err.println("Warning: CCITTFaxDecode.encode is not implemented yet, skipping this stream.");
-    }
-}
\ No newline at end of file
diff -uNr pdfbox.orig/src/org/pdfbox/filter/FilterManager.java pdfbox/src/org/pdfbox/filter/FilterManager.java
--- pdfbox.orig/src/org/pdfbox/filter/FilterManager.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/filter/FilterManager.java	2008-08-03 00:18:44.000000000 +0900
@@ -55,7 +55,6 @@
     {
         Filter flateFilter = new FlateFilter();
         Filter dctFilter = new DCTFilter();
-        Filter ccittFaxFilter = new CCITTFaxDecodeFilter();
         Filter lzwFilter = new LZWFilter();
         Filter asciiHexFilter = new ASCIIHexFilter();
         Filter ascii85Filter = new ASCII85Filter();
@@ -65,8 +64,6 @@
         addFilter( COSName.FLATE_DECODE_ABBREVIATION, flateFilter );
         addFilter( COSName.DCT_DECODE, dctFilter );
         addFilter( COSName.DCT_DECODE_ABBREVIATION, dctFilter );
-        addFilter( COSName.CCITTFAX_DECODE, ccittFaxFilter );
-        addFilter( COSName.CCITTFAX_DECODE_ABBREVIATION, ccittFaxFilter );
         addFilter( COSName.LZW_DECODE, lzwFilter );
         addFilter( COSName.LZW_DECODE_ABBREVIATION, lzwFilter );
         addFilter( COSName.ASCII_HEX_DECODE, asciiHexFilter );
@@ -132,4 +129,4 @@
     {
         return getFilter( COSName.getPDFName( filterName ) );
     }
-}
\ No newline at end of file
+}
diff -uNr pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDCcitt.java pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
--- pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDCcitt.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDCcitt.java	1970-01-01 09:00:00.000000000 +0900
@@ -1,656 +0,0 @@
-/**
- * Copyright (c) 2005-2007, www.pdfbox.org
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. Neither the name of pdfbox; nor the names of its
- *    contributors may be used to endorse or promote products derived from this
- *    software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * http://www.pdfbox.org
- *
- */
-package org.pdfbox.pdmodel.graphics.xobject;
-
-import java.awt.image.BufferedImage;
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.media.jai.JAI;
-import javax.media.jai.PlanarImage;
-
-import org.pdfbox.cos.COSArray;
-import org.pdfbox.cos.COSBase;
-import org.pdfbox.cos.COSDictionary;
-import org.pdfbox.cos.COSName;
-import org.pdfbox.io.RandomAccess;
-
-import org.pdfbox.pdmodel.PDDocument;
-import org.pdfbox.pdmodel.common.PDStream;
-import org.pdfbox.pdmodel.graphics.color.PDDeviceGray;
-
-import com.sun.media.jai.codec.ImageCodec;
-import com.sun.media.jai.codec.ImageDecoder;
-
-/**
- * An image class for CCITT Fax. 
- * 
- * @author <a href="ben@benlitchfield.com">Ben Litchfield</a>
- * @author paul king
- * @version $Revision: 1.6 $
- */
-public class PDCcitt extends PDXObjectImage 
-{
-    private static final List FAX_FILTERS = new ArrayList();
-    
-    static
-    {
-        FAX_FILTERS.add( COSName.CCITTFAX_DECODE.getName() );
-        FAX_FILTERS.add( COSName.CCITTFAX_DECODE_ABBREVIATION.getName() );
-    }
-    
-    /**
-     * Standard constructor.
-     * 
-     * @param ccitt The PDStream that already contains all ccitt information.
-     */
-    public PDCcitt(PDStream ccitt) 
-    {
-        super(ccitt, "tiff");
-        
-    }
-    
-    /**
-     * Construct from a tiff file.
-     * 
-     * @param doc The document to create the image as part of.
-     * @param raf The random access TIFF file which contains a suitable CCITT compressed image
-     * @throws IOException If there is an error reading the tiff data.
-     */
-    
-    public PDCcitt( PDDocument doc, RandomAccess raf ) throws IOException
-    {
-        super( new PDStream(doc),"tiff");
-        // super( new PDStream( doc, null, true ), "tiff" );
-        
-        COSDictionary decodeParms = new COSDictionary(); 
-        
-        COSDictionary dic = getCOSStream();
-      
-        extractFromTiff(raf, getCOSStream().createFilteredStream(),decodeParms);
-        
-        dic.setItem( COSName.FILTER, COSName.CCITTFAX_DECODE);
-        dic.setItem( COSName.SUBTYPE, COSName.IMAGE);
-        dic.setItem( COSName.TYPE, COSName.getPDFName( "XObject" ) );
-        dic.setItem( "DecodeParms", decodeParms);
-        
-        setBitsPerComponent( 1 );
-        setColorSpace( new PDDeviceGray() );
-        setWidth( decodeParms.getInt("Columns") );
-        setHeight( decodeParms.getInt("Rows") );
-        
-    }
-    
-    /**
-     * Returns an image of the CCITT Fax, or null if TIFFs are not supported. (Requires additional JAI Image filters )
-     * 
-     * {@inheritDoc}
-     */
-    public BufferedImage getRGBImage() throws IOException
-    {
-        ImageDecoder dec = ImageCodec.createImageDecoder("tiff", 
-        new TiffWrapper(getPDStream().getPartiallyFilteredStream( FAX_FILTERS ),getCOSStream()), null);
-                        
-        return ((PlanarImage)JAI.create("null", dec.decodeAsRenderedImage())).getAsBufferedImage();
-
-    }
-    
-    /**
-     * This writes a tiff to out. 
-     * 
-     * {@inheritDoc}
-     */
-    public void write2OutputStream(OutputStream out) throws IOException
-    {
-        InputStream data = new TiffWrapper(getPDStream().getPartiallyFilteredStream( FAX_FILTERS ),getCOSStream());
-        byte[] buf = new byte[1024];
-        int amountRead = -1;
-        while( (amountRead = data.read( buf )) != -1 )
-        {
-            out.write( buf, 0, amountRead );
-        }
-    }
-    
-    /**
-     * Extract the ccitt stream from the tiff file.
-     * 
-     * @param raf  - TIFF File
-     * @param os   - Stream to write raw ccitt data two
-     * @param parms - COSDictionary which the encoding parameters are added to
-     * @throws IOException If there is an error reading/writing to/from the stream
-     */
-    private void extractFromTiff(RandomAccess raf, OutputStream os, COSDictionary parms) throws IOException 
-    {
-        try 
-        {
-            
-            // First check the basic tiff header
-            raf.seek(0);  
-            char endianess = (char) raf.read();
-            if ((char) raf.read() != endianess) 
-            {
-                throw new IOException("Not a valid tiff file");
-            }
-            //ensure that endianess is either M or I
-            if (endianess != 'M' && endianess != 'I')
-            {
-                throw new IOException("Not a valid tiff file");
-            }
-            int magicNumber = readshort(endianess, raf); 
-            if( magicNumber != 42)
-            {
-                throw new  IOException("Not a valid tiff file");
-            }
-            
-            // Relocate to the first set of tags
-            raf.seek(readlong(endianess, raf));
-            
-            int numtags = readshort(endianess, raf);
-            
-            //    The number 50 is somewhat arbitary, it just stops us load up junk from somewhere and tramping on
-            if (numtags > 50)
-            {
-                throw new IOException("Not a valid tiff file"); 
-            }
-            
-            // Loop through the tags, some will convert to items in the parms dictionary
-            // Other point us to where to find the data stream
-            // The only parm which might change as a result of other options is K, so
-            // We'll deal with that as a special;
-            
-            int k=-1000; // Default Non CCITT compression
-            int dataoffset=0;
-            int datalength=0;
-            
-            for (int i=0; i < numtags; i++) 
-            {
-                int tag = readshort(endianess, raf);
-                int type = readshort(endianess, raf);
-                int count = readlong(endianess, raf);
-                int val = readlong(endianess, raf); // See note
-                
-                // Note, we treated that value as a long. The value always occupies 4 bytes
-                // But it might only use the first byte or two. Depending on endianess we might need to correct
-                // Note we ignore all other types, they are of little interest for PDFs/CCITT Fax
-                if (endianess == 'M') 
-                {
-                    switch (type) 
-                    {
-                        case 1: 
-                        {
-                            val = val >> 24; 
-                            break; // byte value
-                        }
-                        case 3: 
-                        {
-                            val = val >> 16; 
-                            break; // short value
-                        }
-                        case 4:
-                        {
-                            break; // long value
-                        }
-                        default:
-                        {
-                            //do nothing
-                        }
-                    }
-                }
-                switch (tag) 
-                {
-                    case 256:
-                    {
-                        parms.setInt("Columns",val); 
-                        break;
-                    }
-                    case 257:
-                    {
-                        parms.setInt("Rows",val);
-                        break;
-                    }
-                    case 259: 
-                    {
-                        if (val == 4)
-                        {
-                            k=-1; 
-                        }
-                        if (val == 3)
-                        {
-                            k=0;
-                        }
-                        break;  // T6/T4 Compression
-                    }
-                    case 262:
-                    {
-                        if (val == 1)
-                        {
-                            parms.setBoolean("BlackIs1", true); 
-                        }
-                        break;
-                    }
-                    case 273:
-                    {
-                        if (count == 1)
-                        {
-                            dataoffset=val; 
-                        }
-                        break;
-                    }
-                    case 279:
-                    {
-                        if (count == 1)
-                        {
-                            datalength=val; 
-                        }
-                        break;
-                    }
-                    case 292: 
-                    {
-                        if (val == 1)
-                        {
-                            k=50;  // T4 2D - arbitary K value
-                        }
-                        break;
-                    }
-                    case 324:
-                    {
-                        if (count == 1)
-                        {
-                            dataoffset=val;
-                        }
-                        break;
-                    }
-                    case 325:
-                    {
-                        if (count == 1)
-                        {
-                            datalength=val; 
-                        }
-                        break;
-                    }
-                    default:
-                    {
-                        //do nothing
-                    }
-                }
-            }
-            
-            if (k == -1000)
-            {
-                throw new IOException("First image in tiff is not CCITT T4 or T6 compressed");
-            }
-            if (dataoffset == 0)
-            {
-                throw new IOException("First image in tiff is not a single tile/strip");
-            }
-            
-            parms.setInt("K",k);
-            
-            raf.seek(dataoffset);
-            
-            byte[] buf = new byte[8192];
-            int amountRead = -1;
-            while( (amountRead = raf.read( buf,0, Math.min(8192,datalength) )) > 0 )
-            {
-                datalength -= amountRead;
-                os.write( buf, 0, amountRead );
-            }
-        
-        }
-        finally 
-        {
-            os.close();
-        }
-    }
-    
-    private int readshort(char endianess, RandomAccess raf) throws IOException
-    {
-        if (endianess == 'I')
-        {
-            return raf.read() | (raf.read() << 8);
-        }
-        return (raf.read() << 8) | raf.read();
-    }
-    
-    private int readlong(char endianess, RandomAccess raf) throws IOException
-    {
-        if (endianess == 'I')
-        {
-            return raf.read() | (raf.read() << 8) | (raf.read() << 16) | (raf.read() << 24);
-        }
-        return (raf.read() << 24) | (raf.read() << 16) | (raf.read() << 8) | raf.read();
-    }
-
-    
-    /**
-     * Extends InputStream to wrap the data from the CCITT Fax with a suitable TIFF Header.
-     * For details see www.tiff.org, which contains useful information including pointers to the
-     * TIFF 6.0 Specification
-     *  
-     */
-    private class TiffWrapper extends InputStream 
-    {
-        
-        private int currentOffset;     // When reading, where in the tiffheader are we.
-        private byte[] tiffheader;      // Byte array to store tiff header data
-        private InputStream datastream; // Original InputStream
-        
-        private TiffWrapper(InputStream rawstream, COSDictionary options) 
-        {
-                buildHeader(options);
-                currentOffset=0;
-                datastream = rawstream;
-        }
-        
-        // Implement basic methods from InputStream
-        /**
-         * {@inheritDoc}
-         */
-        public boolean markSupported() 
-        {
-            return false;
-        }
-        /**
-         * {@inheritDoc}
-         */
-        public void reset() throws IOException 
-        {
-            throw new IOException("reset not supported");
-        }
-        
-        /**
-         * For simple read, take a byte from the tiffheader array or pass through.
-         * 
-         * {@inheritDoc}
-         */
-        public int read() throws IOException 
-        {
-            if (currentOffset < tiffheader.length) 
-            {
-                return tiffheader[currentOffset++];
-            }
-            return datastream.read();
-        }
-        
-        /**
-         * For read methods only return as many bytes as we have left in the header
-         * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.
-         * 
-         * {@inheritDoc}
-         */
-        public int read(byte[] data) throws IOException
-        {
-            if (currentOffset < tiffheader.length) 
-            {
-                int length = java.lang.Math.min(tiffheader.length - currentOffset, data.length);
-                if (length > 0)
-                {
-                    System.arraycopy(tiffheader, currentOffset, data, 0, length);
-                }
-                currentOffset += length;
-                return length;
-            }
-            else
-            {
-                return datastream.read(data);
-            }
-        }
-
-        /**
-         * For read methods only return as many bytes as we have left in the header
-         * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.
-         * 
-         *  {@inheritDoc}
-         */
-        public int read(byte[] data, int off, int len) throws IOException
-        {
-            if (currentOffset < tiffheader.length) 
-            {
-                int length = java.lang.Math.min(tiffheader.length - currentOffset, len);
-                if (length > 0)
-                {
-                    System.arraycopy(tiffheader, currentOffset, data, off, length);
-                }
-                currentOffset += length;
-                return length;
-            }
-            else
-            {
-                return datastream.read(data,off,len);
-            }
-        }
-        
-        /**
-         * When skipping if any header data not yet read, only allow to skip what we've in the buffer
-         * Otherwise just pass through.
-         * 
-         * {@inheritDoc}
-         */
-        public long skip(long n) throws IOException 
-        {
-            if (currentOffset < tiffheader.length) 
-            {
-                long length = Math.min(tiffheader.length - currentOffset, n);
-                currentOffset += length;
-                return length;
-            }
-            else 
-            {
-                return datastream.skip(n);
-            }
-        }
-        
-        // Static data for the beginning of the TIFF header
-        private final byte[] basicHeader = {
-                'I','I',42,0,8,0,0,0,       // File introducer and pointer to first IFD
-                0,0};                       // Number of tags start with two 
-
-        
-        private int additionalOffset;      // Offset in header to additional data
-        
-        // Builds up the tiffheader based on the options passed through.
-        private void buildHeader(COSDictionary options) 
-        {
-
-            final int numOfTags = 10; // The maximum tags we'll fill 
-            final int maxAdditionalData = 24; // The maximum amount of additional data
-                                                // outside the IFDs. (bytes)
-            
-            // The length of the header will be the length of the basic header (10)
-            // plus 12 bytes for each IFD, 4 bytes as a pointer to the next IFD (will be 0)
-            // plus the length of the additional data
-            
-            tiffheader = new byte[10 + (12 * numOfTags ) + 4 + maxAdditionalData];
-            java.util.Arrays.fill(tiffheader,(byte)0);
-            System.arraycopy(basicHeader,0,tiffheader,0,basicHeader.length);
-            
-            // Additional data outside the IFD starts after the IFD's and pointer to the next IFD (0)
-            additionalOffset = 10 + (12 * numOfTags ) + 4;
-
-            // Now work out the variable values from TIFF defaults,
-            // PDF Defaults and the Dictionary for this XObject
-            short cols = 1728;
-            short rows = 0;
-            short blackis1 = 0;
-            short comptype = 3; // T4 compression
-            long t4options = 0; // Will set if 1d or 2d T4
-            
-            COSBase dicOrArrayParms = options.getDictionaryObject("DecodeParms");
-            COSDictionary decodeParms = null;
-            if( dicOrArrayParms instanceof COSDictionary )
-            {
-                decodeParms = (COSDictionary)dicOrArrayParms;
-            }
-            else
-            {
-                COSArray parmsArray = (COSArray)dicOrArrayParms;
-                if( parmsArray.size() == 1 )
-                {
-                    decodeParms = (COSDictionary)parmsArray.getObject( 0 );
-                }
-                else
-                {
-                    //else find the first dictionary with Row/Column info and use that.
-                    for( int i=0; i<parmsArray.size() && decodeParms == null; i++ )
-                    {
-                        COSDictionary dic = (COSDictionary)parmsArray.getObject( i );
-                        if( dic.getDictionaryObject( "Columns" ) != null || 
-                            dic.getDictionaryObject( "Rows" ) != null)
-                        {
-                            decodeParms = dic;
-                        }
-                    }
-                }
-            }
-            
-            if (decodeParms != null) 
-            {
-                cols = (short) decodeParms.getInt("Columns", cols);
-                rows = (short) decodeParms.getInt("Rows", rows);
-                if (decodeParms.getBoolean("BlackIs1", false)) 
-                {
-                    blackis1 = 1;
-                }
-                int k = decodeParms.getInt("K");  // Mandatory parm
-                if (k < 0) 
-                {
-                    //T6
-                    comptype = 4;
-                } 
-                if (k > 0) 
-                {
-                    //T4 2D
-                    comptype = 3; 
-                    t4options = 1;
-                } 
-                // else k = 0, leave as default T4 1D compression
-            }
-            
-            // If we couldn't get the number of rows, use the main item from XObject
-            if (rows == 0) 
-            {
-                rows = (short) options.getInt("Height", rows);
-            }
-            
-            // Now put the tags into the tiffheader
-            // These musn't exceed the maximum set above, and by TIFF spec should be sorted into
-            // Numeric sequence.
-            
-            addTag(256, cols); // Columns
-            addTag(257, rows); // Rows
-            addTag(259, comptype);    // T6 
-            addTag(262, blackis1); // Photometric Interpretation
-            addTag(273, tiffheader.length); // Offset to start of image data - updated below
-            addTag(279, options.getInt("Length")); // Length of image data
-            addTag(282, 300, 1); // X Resolution 300 (default unit Inches) This is arbitary
-            addTag(283, 300, 1); // Y Resolution 300 (default unit Inches) This is arbitary
-            if (comptype == 3)
-            {
-                addTag(292, t4options);
-            }
-            addTag(305, "PDFBOX"); // Software generating image
-        }
-        
-        /* Tiff types 1 = byte, 2=ascii, 3=short, 4=ulong 5=rational */
-        
-        private void addTag(int tag,long value) 
-        {
-        // Adds a tag of type 4 (ulong)
-            int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=4;  // Type Long
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(value & 0xff);
-            tiffheader[offset+9]=(byte)((value>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((value>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((value>>24) & 0xff);
-        }
-        
-        private void addTag(int tag, short value) 
-        {
-            // Adds a tag of type 3 (short)
-            int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=3;  // Type Short
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(value & 0xff);
-            tiffheader[offset+9]=(byte)((value>>8) & 0xff);
-        }
-        
-        private void addTag(int tag, String value) 
-        {
-            // Adds a tag of type 2 (ascii)
-            int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=2;  // Type Ascii
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(additionalOffset & 0xff);
-            tiffheader[offset+9]=(byte)((additionalOffset>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((additionalOffset>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((additionalOffset>>24) & 0xff);
-            System.arraycopy(value.getBytes(), 0, tiffheader, additionalOffset, value.length());
-            additionalOffset += value.length() + 1;
-        }
-        
-        private void addTag(int tag, long numerator, long denominator) 
-        {
-            // Adds a tag of type 5 (rational)
-            int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=5;  // Type Rational
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(additionalOffset & 0xff);
-            tiffheader[offset+9]=(byte)((additionalOffset>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((additionalOffset>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((additionalOffset>>24) & 0xff);
-            tiffheader[additionalOffset++]=(byte) ((numerator) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>8) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>16) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>24) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>8) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>16) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>24) & 0xFF);
-        }
-    }
-}
\ No newline at end of file
diff -uNr pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDXObject.java pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDXObject.java
--- pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDXObject.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDXObject.java	2008-08-03 00:15:36.000000000 +0900
@@ -144,10 +144,6 @@
                 if( filters != null && filters.contains( COSName.DCT_DECODE.getName() ) ) 
                 {
                     return new PDJpeg(image);
-                } 
-                else if ( filters != null && filters.contains( COSName.CCITTFAX_DECODE.getName() ) )
-                {
-                    return new PDCcitt(image);
                 }
                 else if( filters != null && filters.contains(COSName.JPX_DECODE.getName()))
                 {
diff -uNr pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java
--- pdfbox.orig/src/org/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java	2008-08-03 00:13:48.000000000 +0900
+++ pdfbox/src/org/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java	2008-08-03 00:17:35.000000000 +0900
@@ -230,17 +230,6 @@
         {
             retval = PDColorSpaceFactory.createColorSpace( cs );
         }
-        else
-        {
-            //there are some cases where the 'required' CS value is not present
-            //but we know that it will be grayscale for a CCITT filter.
-            COSBase filter = getCOSStream().getDictionaryObject( "Filter" );
-            if( COSName.CCITTFAX_DECODE.equals( filter ) ||
-                COSName.CCITTFAX_DECODE_ABBREVIATION.equals( filter ) )
-            {
-                retval = new PDDeviceGray();
-            }
-        }
         return retval;
     }
 
