diff -uNr gdm-9999.orig/configure.ac gdm-9999/configure.ac
--- gdm-9999.orig/configure.ac	2012-08-23 11:15:40.486765859 +0900
+++ gdm-9999/configure.ac	2012-08-23 11:48:50.709885644 +0900
@@ -359,6 +359,10 @@
 AC_CHECK_HEADERS(sys/sockio.h)
 AC_CHECK_FUNCS([setresuid setenv unsetenv clearenv])
 
+dnl Needed for querying the kernel for free VTs
+AC_CHECK_HEADERS(sys/vt.h)
+AC_CHECK_HEADERS(sys/ioctl.h)
+
 dnl checks needed for Darwin compatibility to linux **environ.
 AC_CHECK_HEADERS(crt_externs.h)
 AC_CHECK_FUNCS(_NSGetEnviron)
diff -uNr gdm-9999.orig/daemon/Makefile.am gdm-9999/daemon/Makefile.am
--- gdm-9999.orig/daemon/Makefile.am	2012-08-23 11:15:40.487765846 +0900
+++ gdm-9999/daemon/Makefile.am	2012-08-23 11:51:21.780996137 +0900
@@ -15,6 +15,7 @@
 	-DLOCALSTATEDIR=\"$(localstatedir)\"		\
 	-DLOGDIR=\"$(logdir)\"				\
 	-DSBINDIR=\"$(sbindir)\"			\
+	-DSYSCONFDIR=\""$(sysconfdir)"\"		\
 	-DGNOMELOCALEDIR=\""$(datadir)/locale"\"	\
 	-DGDM_XAUTH_DIR=\"$(GDM_XAUTH_DIR)\"		\
 	-DGDM_SCREENSHOT_DIR=\"$(GDM_SCREENSHOT_DIR)\"		\
diff -uNr gdm-9999.orig/daemon/gdm-server.c gdm-9999/daemon/gdm-server.c
--- gdm-9999.orig/daemon/gdm-server.c	2012-08-23 11:15:40.494765760 +0900
+++ gdm-9999/daemon/gdm-server.c	2012-08-23 12:36:06.081437640 +0900
@@ -26,6 +26,8 @@
 #include <unistd.h>
 #include <string.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/vt.h>
 #include <sys/wait.h>
 #include <errno.h>
 #include <ctype.h>
@@ -51,6 +53,7 @@
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
 #include <glib-object.h>
+#include <gio/gio.h>
 
 #include <X11/Xlib.h> /* for Display */
 
@@ -65,6 +68,8 @@
 
 #define GDM_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_SERVER, GdmServerPrivate))
 
+#define INITTAB SYSCONFDIR"/inittab"
+
 /* These are the servstat values, also used as server
  * process exit codes */
 #define SERVER_TIMEOUT 2        /* Server didn't start */
@@ -761,6 +766,105 @@
 }
 
 /**
+ * Parse the inittab file used by getty to spawn VTs to find unused ttys
+ */
+static int
+get_free_vt_from_inittab ()
+{
+	GFile *gfile;
+	GFileInputStream *contents;
+	GFileInputStream *dstream;
+	GRegex *getty;
+	GMatchInfo *tty_match = NULL;
+	GSList *tty_list = NULL;
+	GError *error = NULL;
+	gchar *temp = NULL;
+	int vtno = 0;
+
+	gfile = g_file_new_for_path (INITTAB);
+	contents = g_file_read (gfile, NULL, &error);
+	g_object_unref (gfile);
+	if (!contents) {
+		if (error) {
+			g_debug ("Unable to open file %s", INITTAB);
+			g_error_free (error);
+		}
+		goto out;
+	}
+
+	dstream = g_data_input_stream_new (G_INPUT_STREAM (contents));
+	getty = g_regex_new ("^c[0-9]+:.+getty.+tty([0-9]+)", 0, 0, NULL);
+	g_object_unref (contents);
+
+	while (1) {
+		temp = g_data_input_stream_read_line (dstream, NULL, NULL, &error);
+		if (!temp)
+			break;
+		if (!g_regex_match (getty, temp, 0, &tty_match))
+			continue;
+		g_free (temp);
+		temp = g_match_info_fetch (tty_match, 1);
+		if (!temp)
+			continue;
+		tty_list = g_slist_insert_sorted (tty_list, temp, (GCompareFunc)g_strcmp0);
+		g_match_info_free (tty_match);
+	}
+
+	if (!error) {
+		g_debug ("Unable to read line from %s", INITTAB);
+		g_error_free (error);
+		goto free;
+	}
+
+	/* Ignore holes in vt allocation, just take the last one */
+	temp = g_slist_last (tty_list)->data;
+	if (temp)
+		vtno = (int) g_ascii_strtoull (temp, NULL, 10) + 1;
+
+free:
+	g_object_unref (dstream);
+	g_regex_unref (getty);
+	g_slist_free_full (tty_list, g_free);
+	g_free (error);
+out:
+	return vtno;
+}
+
+/**
+ * Query the VT_* kernel ioctls to find an empty tty
+ */
+static int
+get_free_vt_from_kernel()
+{
+	int fd, vtno = 0;
+
+	fd = open ("/dev/tty0", O_WRONLY, 0);
+	if ((ioctl(fd, VT_OPENQRY, &vtno) < 0) || (vtno == -1)) {
+		vtno = 0;
+		g_debug ("Unable to find a free vt, falling back to Xorg autodetect");
+	}
+	return vtno;
+}
+
+static gchar*
+get_free_vt ()
+{
+	int inittab_vtno, kernel_vtno;
+	gchar* vt = NULL;
+
+	inittab_vtno = get_free_vt_from_inittab();
+	if (inittab_vtno > 0)
+		g_debug ("Inittab says vt%i is free\n", inittab_vtno);
+	kernel_vtno = get_free_vt_from_kernel();
+	if (kernel_vtno > 0)
+		g_debug ("Kernel says vt%i is free\n", kernel_vtno);
+	/* Select the greater of the two because getty will use the others */
+	if (kernel_vtno != 0 && inittab_vtno != 0)
+		vt = g_strdup_printf ("vt%i", kernel_vtno > inittab_vtno ? kernel_vtno : inittab_vtno);
+	return vt;
+}
+
+/**
  * gdm_server_start:
  * @disp: Pointer to a GdmDisplay structure
  *
@@ -771,16 +875,9 @@
 gdm_server_start (GdmServer *server)
 {
         gboolean res;
-        const char *vtarg = NULL;
-
-        /* Hardcode the VT for the initial X server, but nothing else */
-        if (server->priv->is_initial
-            && g_strcmp0 (server->priv->display_seat_id, "seat0") == 0) {
-                vtarg = "vt" GDM_INITIAL_VT;
-        }
 
         /* fork X server process */
-        res = gdm_server_spawn (server, vtarg);
+        res = gdm_server_spawn (server, get_free_vt());
 
         return res;
 }
