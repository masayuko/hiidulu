diff -r 5d54c7381247 -r 9533002fdeae docs/userguide/ch1_intro.py
--- a/docs/userguide/ch1_intro.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/docs/userguide/ch1_intro.py	Tue Jan 12 14:59:19 2016 +0000
@@ -5,11 +5,12 @@
 from reportlab.platypus.tableofcontents import TableOfContents
 from datetime import datetime
 import reportlab
+from reportlab.rl_config import invariant
 
 title("ReportLab PDF Library")
 title("User Guide")
 centred('ReportLab Version ' + reportlab.Version)
-centred(datetime.now().strftime('Document generated on %Y/%m/%d %H:%M:%S %Z'))
+centred((datetime(2000,1,1,0,0,0) if invariant else datetime.now()).strftime('Document generated on %Y/%m/%d %H:%M:%S %Z'))
 
 nextTemplate("TOC")
 
diff -r 5d54c7381247 -r 9533002fdeae setup.py
--- a/setup.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/setup.py	Tue Jan 12 14:59:19 2016 +0000
@@ -502,7 +502,7 @@
         setup(
             name="reportlab",
             version=get_version(),
-            license="BSD license (see license.txt for details), Copyright (c) 2000-2012, ReportLab Inc.",
+            license="BSD license (see license.txt for details), Copyright (c) 2000-2015, ReportLab Inc.",
             description="The Reportlab Toolkit",
             long_description="""The ReportLab Toolkit. An Open Source Python library for generating PDFs and graphics.""",
 
@@ -524,6 +524,18 @@
             package_dir = PACKAGE_DIR,
             package_data = {'reportlab': reportlab_files},
             ext_modules =   EXT_MODULES,
+            classifiers = [
+                'Development Status :: 5 - Production/Stable',
+                'Intended Audience :: Developers',
+                'License :: OSI Approved :: BSD License',
+                'Topic :: Printing',
+                'Topic :: Text Processing :: Markup',
+                'Programming Language :: Python :: 2',
+                'Programming Language :: Python :: 2.7',
+                'Programming Language :: Python :: 3',
+                'Programming Language :: Python :: 3.3',
+                'Programming Language :: Python :: 3.4',
+                ],
             
             #this probably only works for setuptools, but distutils seems to ignore it
             install_requires=['pillow>=2.4.0','pip>=1.4.1', 'setuptools>=2.2'],
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/__init__.py
--- a/src/reportlab/__init__.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/__init__.py	Tue Jan 12 14:59:19 2016 +0000
@@ -1,8 +1,9 @@
 #Copyright ReportLab Europe Ltd. 2000-2015
 #see license.txt for license details
 __doc__="""The Reportlab PDF generation library."""
-Version = "3.2.0"
+Version = "3.2.16"
 __version__=Version
+__date__='20160112'
 
 import sys, os, imp
 
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/__init__.py
--- a/src/reportlab/graphics/barcode/__init__.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/__init__.py	Tue Jan 12 14:59:19 2016 +0000
@@ -29,29 +29,27 @@
 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 # POSSIBILITY OF SUCH DAMAGE.
 #
-
+__all__ = tuple('''registerWidget getCodes getCodeNames createBarcodeDrawing createBarcodeImageInMemory'''.split())
 __version__ = '0.9'
 __doc__='''Popular barcodes available as reusable widgets'''
 
-def getCodes():
-    """Returns a dict mapping code names to widgets"""
+_widgets = []
+def registerWidget(widget):
+    _widgets.append(widget)
 
+def _reset():
+    _widgets[:] = []
     from reportlab.graphics.barcode.widgets import BarcodeI2of5, BarcodeCode128, BarcodeStandard93,\
                         BarcodeExtended93, BarcodeStandard39, BarcodeExtended39,\
                         BarcodeMSI, BarcodeCodabar, BarcodeCode11, BarcodeFIM,\
-                        BarcodePOSTNET, BarcodeUSPS_4State
+                        BarcodePOSTNET, BarcodeUSPS_4State, BarcodeCode128Auto, BarcodeECC200DataMatrix
 
     #newer codes will typically get their own module
-    from reportlab.graphics.barcode.eanbc import Ean13BarcodeWidget, Ean8BarcodeWidget, UPCA
+    from reportlab.graphics.barcode.eanbc import Ean13BarcodeWidget, Ean8BarcodeWidget, UPCA, Ean5BarcodeWidget, ISBNBarcodeWidget
     from reportlab.graphics.barcode.qr import QrCodeWidget
-
-
-    #the module exports a dictionary of names to widgets, to make it easy for
-    #apps and doc tools to display information about them.
-    codes = {}
-    for widget in (
-                BarcodeI2of5,
+    for widget in (BarcodeI2of5,
                 BarcodeCode128,
+                BarcodeCode128Auto,
                 BarcodeStandard93,
                 BarcodeExtended93,
                 BarcodeStandard39,
@@ -65,8 +63,22 @@
                 Ean13BarcodeWidget,
                 Ean8BarcodeWidget,
                 UPCA,
+                Ean5BarcodeWidget,
+                ISBNBarcodeWidget,
                 QrCodeWidget,
+                BarcodeECC200DataMatrix,
                 ):
+        registerWidget(widget)
+_reset()
+from reportlab.rl_config import register_reset
+register_reset(_reset)
+
+def getCodes():
+    """Returns a dict mapping code names to widgets"""
+    #the module exports a dictionary of names to widgets, to make it easy for
+    #apps and doc tools to display information about them.
+    codes = {}
+    for widget in _widgets:
         codeName = widget.codeName
         codes[codeName] = widget
 
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/code128.py
--- a/src/reportlab/graphics/barcode/code128.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/code128.py	Tue Jan 12 14:59:19 2016 +0000
@@ -319,3 +319,58 @@
 
     def _humanText(self):
         return self.value
+
+class Code128Auto(Code128):
+    '''contributed by https://bitbucket.org/kylemacfarlane/
+    see https://bitbucket.org/rptlab/reportlab/issues/69/implementations-of-code-128-auto-and-data
+    '''
+    def encode(self):
+        s = self.validated
+
+        current_set = None
+        l = []
+        value = list(s)
+        while value:
+            c = value.pop(0)
+            if c in digits and value and value[0] in digits:
+                c += value.pop(0)
+
+            if c in setc:
+                set_ = 'C'
+            elif c in setb:
+                set_ = 'B'
+            else:
+                set_ = 'A'
+
+            if current_set != set_:
+                if current_set:
+                    l.append('TO_' + set_)
+                else:
+                    l.append('START_' + set_)
+                current_set = set_
+
+            l.append(c)
+        l.append('STOP')
+
+        start, set, shset = setmap[l[0]]
+        e = [start]
+
+        l = l[1:-1]
+        while l:
+            c = l[0]
+            if c == 'SHIFT':
+                e = e + [set[c], shset[l[1]]]
+                l = l[2:]
+            elif c in tos:
+                e.append(set[c])
+                set, shset = setmap[c]
+                l = l[1:]
+            else:
+                e.append(set[c])
+                l = l[1:]
+
+        c = e[0]
+        for i in range(1, len(e)):
+            c = c + i * e[i]
+        self.encoded = e + [c % 103, stop]
+        return self.encoded
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/eanbc.py
--- a/src/reportlab/graphics/barcode/eanbc.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/eanbc.py	Tue Jan 12 14:59:19 2016 +0000
@@ -1,10 +1,11 @@
 __all__=(
         'Ean13BarcodeWidget','isEanString',
+        'Ean8BarcodeWidget', 'UPCA', 'Ean5BarcodeWidget', 'ISBNBarcodeWidget',
         )
 from reportlab.graphics.shapes import Group, String, Rect
 from reportlab.lib import colors
 from reportlab.pdfbase.pdfmetrics import stringWidth
-from reportlab.lib.validators import isNumber, isColor, isString, Validator, isBoolean
+from reportlab.lib.validators import isNumber, isColor, isString, Validator, isBoolean, NoneOr
 from reportlab.lib.attrmap import *
 from reportlab.graphics.charts.areas import PlotArea
 from reportlab.lib.units import mm
@@ -348,3 +349,187 @@
     _0csw = 3
     _1csw = 1
     _nbars = 1+7*11+2*3+5
+
+class Ean5BarcodeWidget(Ean13BarcodeWidget):
+    """
+    EAN-5 barcodes can print the human readable price, set:
+        price=True
+    """
+    codeName = "EAN5"
+    _attrMap = AttrMap(BASE=Ean13BarcodeWidget,
+                       price=AttrMapValue(isBoolean,
+                                          desc='whether to display the price or not'),
+                       value=AttrMapValue(nDigits(5), desc='the number'),
+                       )
+    _nbars = 48
+    _digits = 5
+    _sep = '01'
+    _tail = '01011'
+    _0csw = 3
+    _1csw = 9
+
+    _lhconvert = {
+        "0": (1, 1, 0, 0, 0),
+        "1": (1, 0, 1, 0, 0),
+        "2": (1, 0, 0, 1, 0),
+        "3": (1, 0, 0, 0, 1),
+        "4": (0, 1, 1, 0, 0),
+        "5": (0, 0, 1, 1, 0),
+        "6": (0, 0, 0, 1, 1),
+        "7": (0, 1, 0, 1, 0),
+        "8": (0, 1, 0, 0, 1),
+        "9": (0, 0, 1, 0, 1)
+    }
+
+    def _checkdigit(cls, num):
+        z = ord('0')
+        iSum = cls._0csw * sum([(ord(x) - z) for x in num[::2]]) \
+               + cls._1csw * sum([(ord(x) - z) for x in num[1::2]])
+        return chr(z + iSum % 10)
+
+    def _encode_left(self, s, a):
+        check = self._checkdigit(s)
+        cp = self._lhconvert[check]
+        _left = self._left
+        _sep = self._sep
+        z = ord('0')
+        full_code = []
+        for i, c in enumerate(s):
+            full_code.append(_left[cp[i]][ord(c) - z])
+        a(_sep.join(full_code))
+
+    def _short_bar(self, i):
+        i += 9 - self._lquiet
+        return self.humanReadable and ((12 < i < 41) or (43 < i < 73))
+
+    def _add_human_readable(self, s, gAdd):
+        barWidth = self.barWidth
+        fontSize = self.fontSize
+        textColor = self.textColor
+        fontName = self.fontName
+        fth = fontSize * 1.2
+        # draw the num below the line.
+        y = self.y + 0.2 * fth
+
+        x = self.x + (self._nbars + self._lquiet * 2) * barWidth / 2
+
+        gAdd(String(x, y, s, fontName=fontName, fontSize=fontSize,
+                    fillColor=textColor, textAnchor='middle'))
+
+        price = getattr(self,'price',None)
+        if price:
+            price = None
+            if s[0] in '3456':
+                price = '$'
+            elif s[0] in '01':
+                price = '\xc2\xa3'
+
+            if price is None:
+                return
+
+            price += s[1:3] + '.' + s[3:5]
+            y += self.barHeight
+            gAdd(String(x, y, price, fontName=fontName, fontSize=fontSize,
+                        fillColor=textColor, textAnchor='middle'))
+
+    def draw(self):
+        g = Group()
+        gAdd = g.add
+        barWidth = self.barWidth
+        width = self.width
+        barHeight = self.barHeight
+        x = self.x
+        y = self.y
+        gAdd(Rect(x, y, width, barHeight, fillColor=None, strokeColor=None,
+                  strokeWidth=0))
+        s = self.value
+        self._lquiet = lquiet = self._calc_quiet(self.lquiet)
+        rquiet = self._calc_quiet(self.rquiet)
+        b = [lquiet * '0' + self._tail]  # the signal string
+        a = b.append
+        self._encode_left(s, a)
+
+        a(rquiet * '0')
+
+        fontSize = self.fontSize
+        barFillColor = self.barFillColor
+        barStrokeWidth = self.barStrokeWidth
+        barStrokeColor = self.barStrokeColor
+
+        fth = fontSize * 1.2
+        b = ''.join(b)
+
+        lrect = None
+        for i, c in enumerate(b):
+            if c == "1":
+                dh = fth
+                yh = y + dh
+                if lrect and lrect.y == yh:
+                    lrect.width += barWidth
+                else:
+                    lrect = Rect(x, yh, barWidth, barHeight - dh,
+                                 fillColor=barFillColor,
+                                 strokeWidth=barStrokeWidth,
+                                 strokeColor=barStrokeColor)
+                    gAdd(lrect)
+            else:
+                lrect = None
+            x += barWidth
+
+        if self.humanReadable:
+            self._add_human_readable(s, gAdd)
+        return g
+
+class ISBNBarcodeWidget(Ean13BarcodeWidget):
+    """
+    ISBN Barcodes optionally print the EAN-5 supplemental price
+    barcode (with the price in dollars or pounds). Set price to a string
+    that follows the EAN-5 for ISBN spec:
+
+        leading digit 0, 1 = GBP
+                      3    = AUD
+                      4    = NZD
+                      5    = USD
+                      6    = CAD
+        next 4 digits = price between 00.00 and 99.98, i.e.:
+
+        price='52499' # $24.99 USD
+    """
+    codeName = 'ISBN'
+    _attrMap = AttrMap(BASE=Ean13BarcodeWidget,
+                       price=AttrMapValue(
+                           NoneOr(nDigits(5)),
+                           desc='None or the price to display'),
+                       )
+    def draw(self):
+        g = Ean13BarcodeWidget.draw(self)
+
+        price = getattr(self,'price',None)
+        if not price:
+            return g
+
+        bounds = g.getBounds()
+        x = bounds[2]
+        pricecode = Ean5BarcodeWidget(x=x, value=price, price=True,
+                                      humanReadable=True,
+                                      barHeight=self.barHeight, quiet=self.quiet)
+        g.add(pricecode)
+        return g
+
+    def _add_human_readable(self, s, gAdd):
+        Ean13BarcodeWidget._add_human_readable(self,s, gAdd)
+        barWidth = self.barWidth
+        barHeight = self.barHeight
+        fontSize = self.fontSize
+        textColor = self.textColor
+        fontName = self.fontName
+        fth = fontSize * 1.2
+        y = self.y + 0.2 * fth + barHeight
+        x = self._lquiet * barWidth
+
+        isbn = 'ISBN '
+        segments = [s[0:3], s[3:4], s[4:9], s[9:12], s[12]]
+        isbn += '-'.join(segments)
+
+        gAdd(String(x, y, isbn, fontName=fontName, fontSize=fontSize,
+                    fillColor=textColor))
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/ecc200datamatrix.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/reportlab/graphics/barcode/ecc200datamatrix.py	Tue Jan 12 14:59:19 2016 +0000
@@ -0,0 +1,444 @@
+#this code contributed by Kyle Macfarlane see
+#https://bitbucket.org/rptlab/reportlab/issues/69/implementations-of-code-128-auto-and-data
+__all__= ('ECC200datamatrix',)
+FACTORS = {
+    5: (228, 48, 15, 111, 62),
+    7: (23, 68, 144, 134, 240, 92, 254),
+    10: (28, 24, 185, 166, 223, 248, 116, 255, 110, 61),
+    11: (175, 138, 205, 12, 194, 168, 39, 245, 60, 97, 120),
+    12: (41, 153, 158, 91, 61, 42, 142, 213, 97, 178, 100, 242),
+    14: (156, 97, 192, 252, 95, 9, 157, 119, 138, 45, 18, 186, 83, 185),
+    18: (83, 195, 100, 39, 188, 75, 66, 61, 241, 213, 109, 129,
+         94, 254, 225, 48, 90, 188),
+    20: (15, 195, 244, 9, 233, 71, 168, 2, 188, 160, 153, 145,
+         253, 79, 108, 82, 27, 174, 186, 172),
+    24: (52, 190, 88, 205, 109, 39, 176, 21, 155, 197, 251, 223, 155,
+         21, 5, 172, 254, 124, 12, 181, 184, 96, 50, 193),
+    28: (211, 231, 43, 97, 71, 96, 103, 174, 37, 151, 170, 53, 75, 34,
+         249, 121, 17, 138, 110, 213, 141, 136, 120, 151, 233, 168, 93, 255),
+    36: (245, 127, 242, 218, 130, 250, 162, 181, 102, 120, 84, 179, 220, 251,
+         80, 182, 229, 18, 2, 4, 68, 33, 101, 137, 95, 119, 115, 44,
+         175, 184, 59, 25, 225, 98, 81, 112),
+    42: (77, 193, 137, 31, 19, 38, 22, 153, 247, 105, 122, 2, 245, 133,
+         242, 8, 175, 95, 100, 9, 167, 105, 214, 111, 57, 121, 21,
+         1, 253, 57, 54, 101, 248, 202, 69, 50, 150, 177, 226, 5, 9, 5),
+    48: (245, 132, 172, 223, 96, 32, 117, 22, 238, 133, 238, 231, 205, 188,
+         237, 87, 191, 106, 16, 147, 118, 23, 37, 90, 170, 205, 131, 88,
+         120, 100, 66, 138, 186, 240, 82, 44, 176, 87, 187, 147, 160, 175,
+         69, 213, 92, 253, 225, 19),
+    56: (175, 9, 223, 238, 12, 17, 220, 208, 100, 29, 175, 170, 230, 192,
+         215, 235, 150, 159, 36, 223, 38, 200, 132, 54, 228, 146, 218, 234,
+         117, 203, 29, 232, 144, 238, 22, 150, 201, 117, 62, 207, 164, 13,
+         137, 245, 127, 67, 247, 28, 155, 43, 203, 107, 233, 53, 143, 46),
+    62: (242, 93, 169, 50, 144, 210, 39, 118, 202, 188, 201, 189, 143, 108,
+         196, 37, 185, 112, 134, 230, 245, 63, 197, 190, 250, 106, 185, 221,
+         175, 64, 114, 71, 161, 44, 147, 6, 27, 218, 51, 63, 87, 10,
+         40, 130, 188, 17, 163, 31, 176, 170, 4, 107, 232, 7, 94, 166,
+         224, 124, 86, 47, 11, 204),
+    68: (220, 228, 173, 89, 251, 149, 159, 56, 89, 33, 147, 244, 154, 36,
+         73, 127, 213, 136, 248, 180, 234, 197, 158, 177, 68, 122, 93, 213,
+         15, 160, 227, 236, 66, 139, 153, 185, 202, 167, 179, 25, 220, 232,
+         96, 210, 231, 136, 223, 239, 181, 241, 59, 52, 172, 25, 49, 232,
+         211, 189, 64, 54, 108, 153, 132, 63, 96, 103, 82, 186)
+}
+
+LOGVAL = (
+    -255, 255, 1, 240, 2, 225, 241, 53, 3, 38, 226, 133, 242, 43,
+    54, 210, 4, 195, 39, 114, 227, 106, 134, 28, 243, 140, 44, 23,
+    55, 118, 211, 234, 5, 219, 196, 96, 40, 222, 115, 103, 228, 78,
+    107, 125, 135, 8, 29, 162, 244, 186, 141, 180, 45, 99, 24, 49,
+    56, 13, 119, 153, 212, 199, 235, 91, 6, 76, 220, 217, 197, 11,
+    97, 184, 41, 36, 223, 253, 116, 138, 104, 193, 229, 86, 79, 171,
+    108, 165, 126, 145, 136, 34, 9, 74, 30, 32, 163, 84, 245, 173,
+    187, 204, 142, 81, 181, 190, 46, 88, 100, 159, 25, 231, 50, 207,
+    57, 147, 14, 67, 120, 128, 154, 248, 213, 167, 200, 63, 236, 110,
+    92, 176, 7, 161, 77, 124, 221, 102, 218, 95, 198, 90, 12, 152,
+    98, 48, 185, 179, 42, 209, 37, 132, 224, 52, 254, 239, 117, 233,
+    139, 22, 105, 27, 194, 113, 230, 206, 87, 158, 80, 189, 172, 203,
+    109, 175, 166, 62, 127, 247, 146, 66, 137, 192, 35, 252, 10, 183,
+    75, 216, 31, 83, 33, 73, 164, 144, 85, 170, 246, 65, 174, 61,
+    188, 202, 205, 157, 143, 169, 82, 72, 182, 215, 191, 251, 47, 178,
+    89, 151, 101, 94, 160, 123, 26, 112, 232, 21, 51, 238, 208, 131,
+    58, 69, 148, 18, 15, 16, 68, 17, 121, 149, 129, 19, 155, 59,
+    249, 70, 214, 250, 168, 71, 201, 156, 64, 60, 237, 130, 111, 20,
+    93, 122, 177, 150
+)
+
+ALOGVAL = (
+    1, 2, 4, 8, 16, 32, 64, 128, 45, 90, 180, 69, 138, 57,
+    114, 228, 229, 231, 227, 235, 251, 219, 155, 27, 54, 108, 216, 157,
+    23, 46, 92, 184, 93, 186, 89, 178, 73, 146, 9, 18, 36, 72,
+    144, 13, 26, 52, 104, 208, 141, 55, 110, 220, 149, 7, 14, 28,
+    56, 112, 224, 237, 247, 195, 171, 123, 246, 193, 175, 115, 230, 225,
+    239, 243, 203, 187, 91, 182, 65, 130, 41, 82, 164, 101, 202, 185,
+    95, 190, 81, 162, 105, 210, 137, 63, 126, 252, 213, 135, 35, 70,
+    140, 53, 106, 212, 133, 39, 78, 156, 21, 42, 84, 168, 125, 250,
+    217, 159, 19, 38, 76, 152, 29, 58, 116, 232, 253, 215, 131, 43,
+    86, 172, 117, 234, 249, 223, 147, 11, 22, 44, 88, 176, 77, 154,
+    25, 50, 100, 200, 189, 87, 174, 113, 226, 233, 255, 211, 139, 59,
+    118, 236, 245, 199, 163, 107, 214, 129, 47, 94, 188, 85, 170, 121,
+    242, 201, 191, 83, 166, 97, 194, 169, 127, 254, 209, 143, 51, 102,
+    204, 181, 71, 142, 49, 98, 196, 165, 103, 206, 177, 79, 158, 17,
+    34, 68, 136, 61, 122, 244, 197, 167, 99, 198, 161, 111, 222, 145,
+    15, 30, 60, 120, 240, 205, 183, 67, 134, 33, 66, 132, 37, 74,
+    148, 5, 10, 20, 40, 80, 160, 109, 218, 153, 31, 62, 124, 248,
+    221, 151, 3, 6, 12, 24, 48, 96, 192, 173, 119, 238, 241, 207,
+    179, 75, 150, 1
+)
+
+from reportlab.graphics.barcode.common import Barcode
+class ECC200DataMatrix(Barcode):
+    '''This code only supports a Type 12 (44x44) C40 encoded data matrix.
+    This is the size and encoding that Royal Mail wants on all mail from October 1st 2015.
+    see https://bitbucket.org/rptlab/reportlab/issues/69/implementations-of-code-128-auto-and-data
+    '''
+    def __init__(self, *args, **kwargs):
+        # These values are hardcoded for a Type 12 44x44 data matrix
+        self.row_modules = 44
+        self.col_modules = 44
+        self.row_regions = 2
+        self.col_regions = 2
+        self.cw_data = 144
+        self.cw_ecc = 56
+        self.barWidth = 4
+
+        self.row_usable_modules = self.row_modules - self.row_regions * 2
+        self.col_usable_modules = self.col_modules - self.col_regions * 2
+        Barcode.__init__(self,*args, **kwargs)
+
+    def validate(self):
+        self.valid = 1
+        for c in self.value:
+            if ord(c) > 255:
+                self.valid = 0
+                break
+        else:
+            self.validated = self.value
+
+    def _encode_c40_char(self, char):
+        o = ord(char)
+        encoded = []
+
+        if o == 32 or (o >= 48 and o <= 57) or (o >= 65 and o <= 90):
+            # Stay in set 0
+            if o == 32:
+                encoded.append(o - 29)
+            elif o >= 48 and o <= 57:
+                encoded.append(o - 44)
+            else:
+                encoded.append(o - 51)
+        elif o >= 0 and o <= 31:
+            encoded.append(0) # Shift to set 1
+            encoded.append(o)
+        elif (o >= 33 and o <= 64) or (o >= 91 and o <= 95):
+            encoded.append(1) # Shift to set 2
+            if o >= 33 and o <= 64:
+                encoded.append(o - 33)
+            else:
+                encoded.append(o - 69)
+        elif o >= 96 and o <= 127:
+            encoded.append(2) # Shift to set 3
+            encoded.append(o - 96)
+        elif o >= 128 and o <= 255:
+            # Extended ASCII
+            encoded.append(1) # Shift to set 2
+            encoded.append(30) # Upper shift / hibit
+            encoded += self._encode_c40_char(chr(o - 128))
+        else:
+            raise Exception('Cannot encode %s (%s)' % (char, o))
+
+        return encoded
+
+    def _encode_c40(self, value):
+        encoded = []
+
+        for c in value:
+            encoded += self._encode_c40_char(c)
+
+        while len(encoded) % 3:
+            encoded.append(0) # Fake padding that makes chunking in the next step easier
+
+        codewords = []
+        codewords.append(230) # Switch to C40 encoding
+
+        for i in range(0, len(encoded), 3):
+            chunk = encoded[i:i+3]
+            total = chunk[0] * 1600 + chunk[1] * 40 + chunk[2] + 1
+            codewords.append(total // 256)
+            codewords.append(total % 256)
+
+        codewords.append(254) # End of data
+
+        if len(codewords) > self.cw_data:
+            raise Exception('Too much data to fit into a data matrix of this size')
+
+        if len(codewords) < self.cw_data:
+            # Real padding
+            codewords.append(129) # Start padding
+            while len(codewords) < self.cw_data:
+                r = ((149 * (len(codewords) + 1)) % 253) + 1
+                codewords.append((129 + r) % 254)
+
+        return codewords
+
+    def _gfsum(self, int1, int2):
+        return int1 ^ int2
+
+    def _gfproduct(self, int1, int2):
+        if int1 == 0 or int2 == 0:
+            return 0
+        else:
+            return ALOGVAL[(LOGVAL[int1] + LOGVAL[int2]) % 255]
+
+    def _get_reed_solomon_code(self, data, num_code_words):
+        """
+        This method is basically verbatim from "huBarcode" which is BSD licensed
+        https://github.com/hudora/huBarcode/blob/master/hubarcode/datamatrix/reedsolomon.py
+        """
+        cw_factors = FACTORS[num_code_words]
+        code_words = [0] * num_code_words
+
+        for data_word in data:
+            tmp = self._gfsum(data_word, code_words[-1])
+            for j in range(num_code_words - 1, -1, -1):
+                code_words[j] = self._gfproduct(tmp, cw_factors[j])
+                if j > 0:
+                    code_words[j] = self._gfsum(code_words[j - 1], code_words[j])
+
+        code_words.reverse()
+        return code_words
+
+    def _get_next_bits(self, data):
+        value = data.pop(0)
+        bits = []
+        for i in range(0, 8):
+            bits.append(value >> i & 1)
+        bits.reverse()
+        return bits
+
+    def _place_bit(self, row, col, bit):
+        if row < 0:
+            row += self.row_usable_modules
+            col += (4 - ((self.row_usable_modules + 4) % 8))
+
+        if col < 0:
+            col += self.col_usable_modules
+            row += (4 - ((self.col_usable_modules + 4) % 8))
+
+        self._matrix[row][col] = bit
+
+    def _place_bit_corner_1(self, data):
+        bits = self._get_next_bits(data)
+        self._place_bit(self.row_usable_modules - 1, 0, bits[0])
+        self._place_bit(self.row_usable_modules - 1, 1, bits[1])
+        self._place_bit(self.row_usable_modules - 1, 2, bits[2])
+        self._place_bit(0, self.col_usable_modules - 2, bits[3])
+        self._place_bit(0, self.col_usable_modules - 1, bits[4])
+        self._place_bit(1, self.col_usable_modules - 1, bits[5])
+        self._place_bit(2, self.col_usable_modules - 1, bits[6])
+        self._place_bit(3, self.col_usable_modules - 1, bits[7])
+
+    def _place_bit_corner_2(self, data):
+        bits = self._get_next_bits(data)
+        self._place_bit(self.row_usable_modules - 3, 0, bits[0])
+        self._place_bit(self.row_usable_modules - 2, 0, bits[1])
+        self._place_bit(self.row_usable_modules - 1, 0, bits[2])
+        self._place_bit(0, self.col_usable_modules - 4, bits[3])
+        self._place_bit(0, self.col_usable_modules - 3, bits[4])
+        self._place_bit(0, self.col_usable_modules - 2, bits[5])
+        self._place_bit(0, self.col_usable_modules - 1, bits[6])
+        self._place_bit(1, self.col_usable_modules - 1, bits[7])
+
+    def _place_bit_corner_3(self, data):
+        bits = self._get_next_bits(data)
+        self._place_bit(self.row_usable_modules - 3, 0, bits[0])
+        self._place_bit(self.row_usable_modules - 2, 0, bits[1])
+        self._place_bit(self.row_usable_modules - 1, 0, bits[2])
+        self._place_bit(0, self.col_usable_modules - 2, bits[3])
+        self._place_bit(0, self.col_usable_modules - 1, bits[4])
+        self._place_bit(1, self.col_usable_modules - 1, bits[5])
+        self._place_bit(2, self.col_usable_modules - 1, bits[6])
+        self._place_bit(3, self.col_usable_modules - 1, bits[7])
+
+    def _place_bit_corner_4(self, data):
+        bits = self._get_next_bits(data)
+        self._place_bit(self.row_usable_modules - 1, 0, bits[0])
+        self._place_bit(self.row_usable_modules - 1, self.col_usable_modules - 1, bits[1])
+        self._place_bit(0, self.col_usable_modules - 3, bits[2])
+        self._place_bit(0, self.col_usable_modules - 2, bits[3])
+        self._place_bit(0, self.col_usable_modules - 1, bits[4])
+        self._place_bit(1, self.col_usable_modules - 3, bits[5])
+        self._place_bit(1, self.col_usable_modules - 2, bits[6])
+        self._place_bit(1, self.col_usable_modules - 1, bits[7])
+
+    def _place_bit_standard(self, data, row, col):
+        bits = self._get_next_bits(data)
+        self._place_bit(row - 2, col - 2, bits[0])
+        self._place_bit(row - 2, col - 1, bits[1])
+        self._place_bit(row - 1, col - 2, bits[2])
+        self._place_bit(row - 1, col - 1, bits[3])
+        self._place_bit(row - 1, col, bits[4])
+        self._place_bit(row, col - 2, bits[5])
+        self._place_bit(row, col - 1, bits[6])
+        self._place_bit(row, col, bits[7])
+
+    def _create_matrix(self, data):
+        """
+        This method is heavily influenced by "huBarcode" which is BSD licensed
+        https://github.com/hudora/huBarcode/blob/master/hubarcode/datamatrix/placement.py
+        """
+        rows = self.row_usable_modules
+        cols = self.col_usable_modules
+
+        self._matrix = self._create_empty_matrix(rows, cols)
+
+        row = 4
+        col = 0
+
+        while True:
+            if row == rows and col == 0:
+                self._place_bit_corner_1(data)
+            elif row == (rows - 2) and col == 0 and (cols % 4):
+                self._place_bit_corner_2(data)
+            elif row == (rows - 2) and col == 0 and (cols % 8 == 4):
+                self._place_bit_corner_3(data)
+            elif row == (rows + 4) and col == 2 and (cols % 8 == 0):
+                self._place_bit_corner_4(data)
+
+            while True:
+                if row < rows and col >= 0 and self._matrix[row][col] is None:
+                    self._place_bit_standard(data, row, col)
+
+                row -= 2
+                col += 2
+
+                if row < 0 or col >= cols:
+                    break
+
+            row += 1
+            col += 3
+
+            while True:
+                if row >= 0 and col < cols and self._matrix[row][col] is None:
+                    self._place_bit_standard(data, row, col)
+
+                row += 2
+                col -= 2
+
+                if row >= rows or col < 0:
+                    break
+
+            row += 3
+            col += 1
+
+            if row >= rows and col >= cols:
+                break
+
+        for row in self._matrix:
+            for i in range(0, cols):
+                if row[i] is None:
+                    row[i] = 0
+
+        return self._matrix
+
+    def _create_data_regions(self, matrix):
+        regions = []
+        col_offset = 0
+        row_offset = 0
+
+        rows = int(self.row_usable_modules / self.row_regions)
+        cols = int(self.col_usable_modules / self.col_regions)
+
+        while col_offset < self.row_regions:
+            while row_offset < self.col_regions:
+                r_offset = col_offset * rows
+                c_offset = row_offset * cols
+                region = matrix[r_offset:rows+r_offset]
+                for i in range(0, len(region)):
+                    region[i] = region[i][c_offset:cols+c_offset]
+                regions.append(region)
+                row_offset += 1
+            row_offset = 0
+            col_offset += 1
+
+        return regions
+
+    def _create_empty_matrix(self, row, col):
+        matrix = []
+        for i in range(0, row):
+            matrix.append([None] * col)
+        return matrix
+
+    def _wrap_data_regions_with_finders(self, regions):
+        wrapped = []
+
+        for region in regions:
+            matrix = self._create_empty_matrix(
+                int(self.col_modules / self.col_regions),
+                int(self.row_modules / self.row_regions)
+            )
+
+            for i, rows in enumerate(region):
+                for j, data in enumerate(rows):
+                    matrix[i+1][j+1] = data
+
+            for i, row in enumerate(matrix):
+                if i == 0:
+                    for j, col in enumerate(row):
+                        row[j] = (j + 1) % 2
+                elif i + 1 == len(matrix):
+                    for j, col in enumerate(row):
+                        row[j] = 1
+                else:
+                    row[0] = 1
+                    row[-1] = i % 2
+
+            wrapped.append(matrix)
+
+        return wrapped
+
+    def _merge_data_regions(self, regions):
+        merged = []
+
+        for i in range(0, len(regions), self.row_regions):
+            chunk = regions[i:i+self.row_regions]
+            j = 0
+            while j < len(chunk[0]):
+                merged_row = []
+                for row in chunk:
+                    merged_row += row[j]
+                merged.append(merged_row)
+                j += 1
+
+        return merged
+
+    def encode(self):
+        if hasattr(self, 'encoded'):
+            return self.encoded
+
+        encoded = self._encode_c40(self.validated)
+        encoded += self._get_reed_solomon_code(encoded, self.cw_ecc)
+
+        matrix = self._create_matrix(encoded)
+        data_regions = self._create_data_regions(matrix)
+        wrapped = self._wrap_data_regions_with_finders(data_regions)
+        self.encoded = self._merge_data_regions(wrapped)
+
+        self.encoded.reverse() # Helpful since PDFs start at bottom left corner
+
+        return self.encoded
+
+    def computeSize(self, *args):
+        self._height = self.row_modules * self.barWidth
+        self._width = self.col_modules * self.barWidth
+
+    def draw(self):
+        for y, row in enumerate(self.encoded):
+            for x, data in enumerate(row):
+                if data:
+                    self.rect(
+                        self.x + x * self.barWidth,
+                        self.y + y * self.barWidth,
+                        self.barWidth,
+                        self.barWidth
+                    )
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/qr.py
--- a/src/reportlab/graphics/barcode/qr.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/qr.py	Tue Jan 12 14:59:19 2016 +0000
@@ -137,8 +137,8 @@
         moduleCount = self.qr.getModuleCount()
         minwh = float(min(width, height))
         boxsize = minwh / (moduleCount + border * 2.0)
-        offsetX = (width - minwh) / 2.0
-        offsetY = (minwh - height) / 2.0
+        offsetX = x + (width - minwh) / 2.0
+        offsetY = y + (minwh - height) / 2.0
 
         for r, row in enumerate(self.qr.modules):
             row = map(bool, row)
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/test.py
--- a/src/reportlab/graphics/barcode/test.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/test.py	Tue Jan 12 14:59:19 2016 +0000
@@ -8,6 +8,7 @@
 from reportlab.graphics.barcode.code128 import *
 from reportlab.graphics.barcode.usps import *
 from reportlab.graphics.barcode.usps4s import USPS_4State
+from reportlab.graphics.barcode.qr import QrCodeWidget
 
 
 from reportlab.platypus import Spacer, SimpleDocTemplate, Table, TableStyle, Preformatted, PageBreak
@@ -19,7 +20,7 @@
 from reportlab.platypus.paragraph import Paragraph
 from reportlab.platypus.frames import Frame
 from reportlab.platypus.flowables import XBox, KeepTogether
-from reportlab.graphics.shapes import Drawing
+from reportlab.graphics.shapes import Drawing, Rect, Line
 
 from reportlab.graphics.barcode import getCodes, getCodeNames, createBarcodeDrawing, createBarcodeImageInMemory
 def run():
@@ -27,58 +28,113 @@
     styleN = styles['Normal']
     styleH = styles['Heading1']
     story = []
+    storyAdd = story.append
 
     #for codeNames in code
-    story.append(Paragraph('I2of5', styleN))
-    story.append(I2of5(1234, barWidth = inch*0.02, checksum=0))
-    story.append(Paragraph('MSI', styleN))
-    story.append(MSI(1234))
-    story.append(Paragraph('Codabar', styleN))
-    story.append(Codabar("A012345B", barWidth = inch*0.02))
-    story.append(Paragraph('Code 11', styleN))
-    story.append(Code11("01234545634563"))
-    story.append(Paragraph('Code 39', styleN))
-    story.append(Standard39("A012345B%R"))
-    story.append(Paragraph('Extended Code 39', styleN))
-    story.append(Extended39("A012345B}"))
-    story.append(Paragraph('Code93', styleN))
-    story.append(Standard93("CODE 93"))
-    story.append(Paragraph('Extended Code93', styleN))
-    story.append(Extended93("L@@K! Code 93 :-)")) #, barWidth=0.005 * inch))
-    story.append(Paragraph('Code 128', styleN))
-    c=Code128("AB-12345678") #, barWidth=0.005 * inch)
-    #print 'WIDTH =', (c.width / inch), 'barWidth =', (c.barWidth / inch)
-    #print 'LQ =', (c.lquiet / inch), 'RQ =', (c.rquiet / inch)
-    story.append(c)
-    story.append(Paragraph('USPS FIM', styleN))
-    story.append(FIM("A"))
-    story.append(Paragraph('USPS POSTNET', styleN))
-    story.append(POSTNET('78247-1043'))
-    story.append(Paragraph('USPS 4 State', styleN))
-    story.append(USPS_4State('01234567094987654321','01234567891'))
+    storyAdd(Paragraph('I2of5', styleN))
+    storyAdd(I2of5(1234, barWidth = inch*0.02, checksum=0))
+
+    storyAdd(Paragraph('MSI', styleN))
+    storyAdd(MSI(1234))
+
+    storyAdd(Paragraph('Codabar', styleN))
+    storyAdd(Codabar("A012345B", barWidth = inch*0.02))
+
+    storyAdd(Paragraph('Code 11', styleN))
+    storyAdd(Code11("01234545634563"))
+
+    storyAdd(Paragraph('Code 39', styleN))
+    storyAdd(Standard39("A012345B%R"))
+
+    storyAdd(Paragraph('Extended Code 39', styleN))
+    storyAdd(Extended39("A012345B}"))
+
+    storyAdd(Paragraph('Code93', styleN))
+    storyAdd(Standard93("CODE 93"))
+
+    storyAdd(Paragraph('Extended Code93', styleN))
+    storyAdd(Extended93("L@@K! Code 93 :-)")) #, barWidth=0.005 * inch))
+
+    storyAdd(Paragraph('Code 128', styleN))
+    storyAdd(Code128("AB-12345678"))
+
+    storyAdd(Paragraph('Code 128 Auto', styleN))
+    storyAdd(Code128Auto("AB-12345678"))
+
+    storyAdd(Paragraph('USPS FIM', styleN))
+    storyAdd(FIM("A"))
+
+    storyAdd(Paragraph('USPS POSTNET', styleN))
+    storyAdd(POSTNET('78247-1043'))
+
+    storyAdd(Paragraph('USPS 4 State', styleN))
+    storyAdd(USPS_4State('01234567094987654321','01234567891'))
 
     from reportlab.graphics.barcode import createBarcodeDrawing
-    story.append(Paragraph('EAN13', styleN))
-    bcd = createBarcodeDrawing('EAN13', value='123456789012')
-    story.append(bcd)
-    story.append(Paragraph('EAN8', styleN))
-    bcd = createBarcodeDrawing('EAN8', value='1234567')
-    story.append(bcd)
-    story.append(Paragraph('UPCA', styleN))
-    bcd = createBarcodeDrawing('UPCA', value='03600029145')
-    story.append(bcd)
-    story.append(Paragraph('USPS_4State', styleN))
-    bcd = createBarcodeDrawing('USPS_4State', value='01234567094987654321',routing='01234567891')
-    story.append(bcd)
 
-    story.append(Paragraph('Label Size', styleN))
-    story.append(XBox((2.0 + 5.0/8.0)*inch, 1 * inch, '1x2-5/8"'))
-    story.append(Paragraph('Label Size', styleN))
-    story.append(XBox((1.75)*inch, .5 * inch, '1/2x1-3/4"'))
-    c = Canvas('out.pdf')
-    f = Frame(inch, inch, 6*inch, 9*inch, showBoundary=1)
-    f.addFromList(story, c)
-    c.save()
+    storyAdd(Paragraph('EAN13', styleN))
+    storyAdd(createBarcodeDrawing('EAN13', value='123456789012'))
+
+    storyAdd(Paragraph('EAN13 quiet=False', styleN))
+    storyAdd(createBarcodeDrawing('EAN13', value='123456789012', quiet=False))
+
+    storyAdd(Paragraph('EAN8', styleN))
+    storyAdd(createBarcodeDrawing('EAN8', value='1234567'))
+
+    storyAdd(PageBreak())
+
+    storyAdd(Paragraph('EAN5 price=True', styleN))
+    storyAdd(createBarcodeDrawing('EAN5', value='11299', price=True))
+
+    storyAdd(Paragraph('EAN5 price=True quiet=False', styleN))
+    storyAdd(createBarcodeDrawing('EAN5', value='11299', price=True, quiet=False))
+
+    storyAdd(Paragraph('EAN5 price=False', styleN))
+    storyAdd(createBarcodeDrawing('EAN5', value='11299', price=False))
+
+    storyAdd(Paragraph('ISBN alone', styleN))
+    storyAdd(createBarcodeDrawing('ISBN', value='9781565924796'))
+
+    storyAdd(Paragraph('ISBN  with ean5 price', styleN))
+    storyAdd(createBarcodeDrawing('ISBN', value='9781565924796',price='01299'))
+
+    storyAdd(Paragraph('ISBN  with ean5 price, quiet=False', styleN))
+    storyAdd(createBarcodeDrawing('ISBN', value='9781565924796',price='01299',quiet=False))
+
+    storyAdd(Paragraph('UPCA', styleN))
+    storyAdd(createBarcodeDrawing('UPCA', value='03600029145'))
+
+    storyAdd(Paragraph('USPS_4State', styleN))
+    storyAdd(createBarcodeDrawing('USPS_4State', value='01234567094987654321',routing='01234567891'))
+
+    storyAdd(Paragraph('QR', styleN))
+    storyAdd(createBarcodeDrawing('QR', value='01234567094987654321'))
+
+    storyAdd(Paragraph('QR', styleN))
+    storyAdd(createBarcodeDrawing('QR', value='01234567094987654321',x=30,y=50))
+
+    storyAdd(Paragraph('QR in drawing at (0,0)', styleN))
+    d = Drawing(100,100)
+    d.add(Rect(0,0,100,100,strokeWidth=1,strokeColor=colors.red,fillColor=None))
+    d.add(QrCodeWidget(value='01234567094987654321'))
+    storyAdd(d)
+
+    storyAdd(Paragraph('QR in drawing at (10,10)', styleN))
+    d = Drawing(100,100)
+    d.add(Rect(0,0,100,100,strokeWidth=1,strokeColor=colors.red,fillColor=None))
+    d.add(Line(7.5,10,12.5,10,strokeWidth=0.5,strokeColor=colors.blue))
+    d.add(Line(10,7.5, 10, 12.5,strokeWidth=0.5,strokeColor=colors.blue))
+    d.add(QrCodeWidget(value='01234567094987654321',x=10,y=10))
+    storyAdd(d)
+
+    storyAdd(Paragraph('Label Size', styleN))
+    storyAdd(XBox((2.0 + 5.0/8.0)*inch, 1 * inch, '1x2-5/8"'))
+
+    storyAdd(Paragraph('Label Size', styleN))
+    storyAdd(XBox((1.75)*inch, .5 * inch, '1/2x1-3/4"'))
+    
+
+    SimpleDocTemplate('out.pdf').build(story)
     print('saved out.pdf')
 
 def fullTest(fileName="test_full.pdf"):
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/barcode/widgets.py
--- a/src/reportlab/graphics/barcode/widgets.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/barcode/widgets.py	Tue Jan 12 14:59:19 2016 +0000
@@ -171,6 +171,14 @@
                 _tests = ['ReportLab Rocks!', 'PFWZF'],
                 )
 
+BarcodeCode128Auto = _BCW(
+                'Modified Code128 to use auto encoding',
+                'Code128Auto',
+                AttrMap(BASE=BarcodeCode128),
+                'reportlab.graphics.barcode.code128',
+                'XY149740345GB'
+                )
+
 BarcodeStandard93=_BCW("""This is a compressed form of Code 39""",
                         "Standard93",
                         AttrMap(BASE=BarcodeCode128,
@@ -302,6 +310,38 @@
                         _pre_init="\n\t\tkw.setdefault('routing','01234567891')\n",
                         _methods = "\n\tdef annotate(self,x,y,text,fontName,fontSize,anchor='middle'):\n\t\t_BarcodeWidget.annotate(self,x,y,text,fontName,fontSize,anchor='start')\n"
                         )
+BarcodeECC200DataMatrix = _BCW(
+    'ECC200DataMatrix',
+    'ECC200DataMatrix',
+    AttrMap(BASE=_BarcodeWidget,
+        x=AttrMapValue(isNumber, desc='X position of the lower-left corner of the barcode.'),
+        y=AttrMapValue(isNumber, desc='Y position of the lower-left corner of the barcode.'),
+        barWidth=AttrMapValue(isNumber, desc='Size of data modules.'),
+        barFillColor=AttrMapValue(isColorOrNone, desc='Color of data modules.'),
+        value=AttrMapValue(EitherOr((isString,isNumber)), desc='Value.'),
+        height=AttrMapValue(None, desc='ignored'),
+        width=AttrMapValue(None, desc='ignored'),
+        strokeColor=AttrMapValue(None, desc='ignored'),
+        strokeWidth=AttrMapValue(None, desc='ignored'),
+        fillColor=AttrMapValue(None, desc='ignored'),
+        background=AttrMapValue(None, desc='ignored'),
+        debug=AttrMapValue(None, desc='ignored'),
+        gap=AttrMapValue(None, desc='ignored'),
+        row_modules=AttrMapValue(None, desc='???'),
+        col_modules=AttrMapValue(None, desc='???'),
+        row_regions=AttrMapValue(None, desc='???'),
+        col_regions=AttrMapValue(None, desc='???'),
+        cw_data=AttrMapValue(None, desc='???'),
+        cw_ecc=AttrMapValue(None, desc='???'),
+        row_usable_modules = AttrMapValue(None, desc='???'),
+        col_usable_modules = AttrMapValue(None, desc='???'),
+        valid = AttrMapValue(None, desc='???'),
+        validated = AttrMapValue(None, desc='???'),
+        decomposed = AttrMapValue(None, desc='???'),
+    ),
+    'reportlab.graphics.barcode.ecc200datamatrix',
+    'JGB 0204H20B012722900021AC35B2100001003241014241014TPS01  WJ067073605GB185 MOUNT PLEASANT MAIL CENTER         EC1A1BB9ZGBREC1A1BB  EC1A1BB  STEST FILE       FOR SPEC                                       '
+    )
 
 if __name__=='__main__':
     raise ValueError('widgets.py has no script function')
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/charts/lineplots.py
--- a/src/reportlab/graphics/charts/lineplots.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/charts/lineplots.py	Tue Jan 12 14:59:19 2016 +0000
@@ -258,8 +258,9 @@
         P = list(range(len(self._positions)))
         if self.reversePlotOrder: P.reverse()
         inFill = getattr(self,'_inFill',None)
-        styleCount = len(self.lines)
-        if inFill or [rowNo for rowNo in P if getattr(self.lines[rowNo%styleCount],'inFill',False)]:
+        lines = self.lines
+        styleCount = len(lines)
+        if inFill or [rowNo for rowNo in P if getattr(lines[rowNo%styleCount],'inFill',False)]:
             inFillY = getattr(inFill,'yValue',None)
             if inFillY is None:
                 inFillY = xA._y
@@ -272,14 +273,15 @@
         # Iterate over data rows.
         for rowNo in P:
             row = self._positions[rowNo]
-            rowStyle = self.lines[rowNo % styleCount]
+            styleRowNo = rowNo % styleCount
+            rowStyle = lines[styleRowNo]
             rowColor = getattr(rowStyle,'strokeColor',None)
             dash = getattr(rowStyle, 'strokeDashArray', None)
 
             if hasattr(rowStyle, 'strokeWidth'):
                 width = rowStyle.strokeWidth
-            elif hasattr(self.lines, 'strokeWidth'):
-                width = self.lines.strokeWidth
+            elif hasattr(lines, 'strokeWidth'):
+                width = lines.strokeWidth
             else:
                 width = None
 
@@ -305,15 +307,25 @@
 
             if hasattr(rowStyle, 'symbol'):
                 uSymbol = rowStyle.symbol
-            elif hasattr(self.lines, 'symbol'):
-                uSymbol = self.lines.symbol
+            elif hasattr(lines, 'symbol'):
+                uSymbol = lines.symbol
             else:
                 uSymbol = None
 
             if uSymbol:
                 if bubblePlot: drow = self.data[rowNo]
                 for j,xy in enumerate(row):
-                    symbol = uSymbol2Symbol(uSymbol,xy[0],xy[1],rowColor)
+                    if (styleRowNo,j) in lines._children:
+                        juSymbol = getattr(lines[styleRowNo,j],'symbol',uSymbol)
+                    else:
+                        juSymbol = uSymbol
+                    if juSymbol is uSymbol:
+                        symbol = uSymbol
+                        symColor = rowColor
+                    else:
+                        symbol = juSymbol
+                        symColor = getattr(symbol,'fillColor',rowColor)
+                    symbol = uSymbol2Symbol(symbol,xy[0],xy[1],symColor)
                     if symbol:
                         if bubblePlot:
                             symbol.size = bubbleR*(drow[j][2]/bubbleMax)**0.5
@@ -321,9 +333,10 @@
             else:
                 if bubblePlot: drow = self.data[rowNo]
                 for j,xy in enumerate(row):
-                    usymbol = getattr(self.lines[rowNo,j],'symbol',None)
-                    if not usymbol: continue
-                    symbol = uSymbol2Symbol(uSymbol,xy[0],xy[1],rowColor)
+                    juSymbol = getattr(lines[styleRowNo,j],'symbol',None)
+                    if not juSymbol: continue
+                    symColor = getattr(juSymbol,'fillColor',getattr(juSymbol,'strokeColor',rowColor))
+                    symbol = uSymbol2Symbol(juSymbol,xy[0],xy[1],symColor)
                     if symbol:
                         if bubblePlot:
                             symbol.size = bubbleR*(drow[j][2]/bubbleMax)**0.5
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/charts/piecharts.py
--- a/src/reportlab/graphics/charts/piecharts.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/charts/piecharts.py	Tue Jan 12 14:59:19 2016 +0000
@@ -666,8 +666,7 @@
     def normalizeData(self,keepData=False):
         data = list(map(abs,self.data))
         s = self._sum = float(sum(data))
-        if s<=1e-8: s = 0
-        f = 360./s
+        f = 360./s if s!=0 else 1
         if keepData:
             return [AngleData(f*x,x) for x in data]
         else:
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/graphics/renderSVG.py
--- a/src/reportlab/graphics/renderSVG.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/graphics/renderSVG.py	Tue Jan 12 14:59:19 2016 +0000
@@ -280,13 +280,8 @@
         return '; '.join(items) + ';'
 
     def _escape(self, s):
-        """
-        return a copy of string s with special characters in postscript strings
-        escaped with backslashes.
-        Have not handled characters that are converted normally in python strings
-        i.e. \\n -> newline
-        """
-        return s.replace(chr(0x5C), r'\\' ).replace('(', '\(' ).replace(')', '\)')
+        '''I don't think this was ever needed; seems to have been copied from renderPS'''
+        return s
 
     def _genArcCode(self, x1, y1, x2, y2, startAng, extent):
         """Calculate the path for an arc inscribed in rectangle defined
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/lib/normalDate.py
--- a/src/reportlab/lib/normalDate.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/lib/normalDate.py	Tue Jan 12 14:59:19 2016 +0000
@@ -122,6 +122,8 @@
             2. integer in yyyymmdd format
             3. string in yyyymmdd format
             4. tuple in (yyyy, mm, dd) - localtime/gmtime can also be used
+            5. string iso date format see _iso_re above
+            6. datetime.datetime or datetime.date
         """
         if normalDate is None:
             self.setNormalDate(time.localtime(time.time()))
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/lib/styles.py
--- a/src/reportlab/lib/styles.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/lib/styles.py	Tue Jan 12 14:59:19 2016 +0000
@@ -130,6 +130,8 @@
         'splitLongWords':1,     #make best efforts to split long words
         'underlineProportion': _baseUnderlineProportion,    #set to non-zero to get proportional
         'bulletAnchor': 'start',    #where the bullet is anchored ie start, middle, end or numeric
+        'justifyLastLine': 0,   #n allow justification on the last line for more than n words 0 means don't bother
+        'justifyBreaks': 0,     #justify lines broken with <br/>
         }
 
 class LineStyle(PropertySet):
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/lib/utils.py
--- a/src/reportlab/lib/utils.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/lib/utils.py	Tue Jan 12 14:59:19 2016 +0000
@@ -20,6 +20,12 @@
 except ImportError:
     import md5
 
+try:
+    import platform
+    isPyPy = platform.python_implementation()=='PyPy'
+except:
+    isPyPy = False
+
 def isFunction(v):
     return type(v) == type(isFunction)
 
@@ -1224,7 +1230,7 @@
     if maxWidth:
         L = []
         for l in lines:
-            L[-1:-1] = _simpleSplit(l,maxWidth,SW)
+            L.extend(_simpleSplit(l,maxWidth,SW))
         lines = L
     return lines
 
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/pdfbase/pdfdoc.py
--- a/src/reportlab/pdfbase/pdfdoc.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/pdfbase/pdfdoc.py	Tue Jan 12 14:59:19 2016 +0000
@@ -269,7 +269,6 @@
                 if fontObj._dynamicFont:
                     raise PDFError("getInternalFontName(%s) called for a dynamic font" % repr(psfontname))
                 fontObj.addObjects(self)
-                #self.addFont(fontObj)
                 return fm[psfontname]
             except KeyError:
                 raise PDFError("Font %s not known!" % repr(psfontname))
@@ -1538,6 +1537,7 @@
 
     def __init__(self):
         self.invariant = rl_config.invariant
+        self.trapped = 'False'  #could be 'True' or 'Unknown'
 
     def digest(self, md5object):
         # add self information to signature
@@ -1548,11 +1548,12 @@
         D = {}
         D["Title"] = PDFString(self.title)
         D["Author"] = PDFString(self.author)
-        D["CreationDate"] = PDFDate(invariant=self.invariant,dateFormatter=self._dateFormatter)
+        D['ModDate'] = D["CreationDate"] = PDFDate(invariant=self.invariant,dateFormatter=self._dateFormatter)
         D["Producer"] = PDFString(self.producer)
         D["Creator"] = PDFString(self.creator)
         D["Subject"] = PDFString(self.subject)
         D["Keywords"] = PDFString(self.keywords)
+        D["Trapped"] = PDFName(self.trapped)
 
         PD = PDFDictionary(D)
         return PD.format(document)
@@ -2107,7 +2108,10 @@
 
     def loadImageFromA85(self,source):
         IMG=[]
-        imagedata = [s.strip() for s in pdfutils.makeA85Image(source,IMG=IMG)]
+        imagedata = pdfutils.makeA85Image(source,IMG=IMG,detectJpeg=True)
+        if not imagedata:
+            return self.loadImageFromSRC(IMG[0])
+        imagedata = [s.strip() for s in imagedata]
         words = imagedata[1].split()
         self.width, self.height = (int(words[1]),int(words[3]))
         self.colorSpace = {'/RGB':'DeviceRGB', '/G':'DeviceGray', '/CMYK':'DeviceCMYK'}[words[7]]
@@ -2145,7 +2149,9 @@
 
     def loadImageFromRaw(self,source):
         IMG=[]
-        imagedata = pdfutils.makeRawImage(source,IMG=IMG)
+        imagedata = pdfutils.makeRawImage(source,IMG=IMG,detectJpeg=True)
+        if not imagedata:
+            return self.loadImageFromSRC(IMG[0])
         words = imagedata[1].split()
         self.width = int(words[1])
         self.height = int(words[3])
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/pdfbase/pdfmetrics.py
--- a/src/reportlab/pdfbase/pdfmetrics.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/pdfbase/pdfmetrics.py	Tue Jan 12 14:59:19 2016 +0000
@@ -34,7 +34,7 @@
 _typefaces = {}
 _encodings = {}
 _fonts = {}
-
+_dynFaceNames = {}      #record dynamicFont face names
 
 class FontError(Exception):
     pass
@@ -599,7 +599,20 @@
     "Registers a font, including setting up info for accelerated stringWidth"
     #assert isinstance(font, Font), 'Not a Font: %s' % font
     fontName = font.fontName
-    _fonts[fontName] = font
+    if font._dynamicFont:
+        faceName = font.face.name
+        if fontName not in _fonts:
+            if faceName in _dynFaceNames:
+                ofont = _dynFaceNames[faceName]
+                if not ofont._dynamicFont:
+                    raise ValueError('Attempt to register fonts %r %r for face %r' % (ofont, font, faceName))
+                else:
+                    _fonts[fontName] = ofont
+            else:
+                _dynFaceNames[faceName] = _fonts[fontName] = font
+    else:
+        _fonts[fontName] = font
+
     if font._multiByte:
         # CID fonts don't need to have typeface registered.
         #need to set mappings so it can go in a paragraph even if within
@@ -783,6 +796,7 @@
             _typefaces = _typefaces.copy(),
             _encodings = _encodings.copy(),
             _fonts = _fonts.copy(),
+            _dynFaceNames = _dynFaceNames.copy(),
             )
         ):
     for k,v in initial_dicts.items():
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/pdfbase/pdfutils.py
--- a/src/reportlab/pdfbase/pdfutils.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/pdfbase/pdfutils.py	Tue Jan 12 14:59:19 2016 +0000
@@ -26,10 +26,13 @@
 ##########################################################
 _mode2cs = {'RGB':'RGB', 'CMYK': 'CMYK', 'L': 'G'}
 _mode2bpp = {'RGB': 3, 'CMYK':4, 'L':1}
-def makeA85Image(filename,IMG=None):
+def makeA85Image(filename,IMG=None, detectJpeg=False):
     import zlib
     img = ImageReader(filename)
-    if IMG is not None: IMG.append(img)
+    if IMG is not None:
+        IMG.append(img)
+        if detectJpeg and img.jpeg_fh():
+            return None
 
     imgwidth, imgheight = img.getSize()
     raw = img.getRGBData()
@@ -50,10 +53,13 @@
 
     append('EI')
     return code
-def makeRawImage(filename,IMG=None):
+def makeRawImage(filename,IMG=None,detectJpeg=False):
     import zlib
     img = ImageReader(filename)
-    if IMG is not None: IMG.append(img)
+    if IMG is not None:
+        IMG.append(img)
+        if detectJpeg and img.jpeg_fh():
+            return None
 
     imgwidth, imgheight = img.getSize()
     raw = img.getRGBData()
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/pdfbase/ttfonts.py
--- a/src/reportlab/pdfbase/ttfonts.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/pdfbase/ttfonts.py	Tue Jan 12 14:59:19 2016 +0000
@@ -57,6 +57,7 @@
 from reportlab import rl_config
 from reportlab.lib.rl_accel import hex32, add32, calcChecksum, instanceStringWidthTTF
 from collections import namedtuple
+import time
 
 class TTFError(pdfdoc.PDFError):
     "TrueType font exception"
@@ -158,6 +159,9 @@
         """
         self.validate = validate
         self.readFile(file)
+        self._filename = getattr(file,'name','')
+        if self._filename.startswith('<'):
+            self._filename = ''
         isCollection = self.readHeader()
         if isCollection:
             self.readTTCHeader()
@@ -395,6 +399,8 @@
 
 class TTFontFile(TTFontParser):
     "TTF file parser and generator"
+    _agfnc = 0
+    _agfnm = {}
 
     def __init__(self, file, charInfo=1, validate=0,subfontIndex=0):
         """Loads and parses a TrueType font file.
@@ -479,18 +485,38 @@
                 nameCount -= 1
                 if nameCount==0: break
         if names[6] is not None:
-            psName = names[6].replace(b" ", b"-")  #Dinu Gherman's fix for font names with spaces
+            psName = names[6]
         elif names[4] is not None:
-            psName = names[4].replace(b" ", b"-")
+            psName = names[4]
         # Fine, one last try before we bail.
         elif names[1] is not None:
-            psName = names[1].replace(b" ", b"-")
+            psName = names[1]
         else:
             psName = None
 
         # Don't just assume, check for None since some shoddy fonts cause crashes here...
         if not psName:
-            raise TTFError("Could not find PostScript font name")
+            if rl_config.autoGenerateTTFMissingTTFName:
+                fn = self._filename
+                if fn:
+                    bfn = os.path.splitext(os.path.basename(fn))[0]
+                if not fn:
+                    psName = bytestr('_RL_%s_%s_TTF' % (time.time(), self.__class__._agfnc))
+                    self.__class__._agfnc += 1
+                else:
+                    psName = self._agfnm.get(fn,'')
+                    if not psName:
+                        if bfn:
+                            psName = bytestr('_RL_%s_TTF' % bfn)
+                        else:
+                            psName = bytestr('_RL_%s_%s_TTF' % (time.time(), self.__class__._agfnc))
+                            self.__class__._agfnc += 1
+                        self._agfnm[fn] = psName
+            else:
+                raise TTFError("Could not find PostScript font name")
+
+        psName = psName.replace(b" ", b"-")  #Dinu Gherman's fix for font names with spaces
+
         for c in psName:
             if char2int(c)>126 or c in b' [](){}<>/%':
                 raise TTFError("psName=%r contains invalid character %s" % (psName,ascii(c)))
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/pdfgen/canvas.py
--- a/src/reportlab/pdfgen/canvas.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/pdfgen/canvas.py	Tue Jan 12 14:59:19 2016 +0000
@@ -237,6 +237,13 @@
                  cropMarks=None,
                  pdfVersion=None,
                  enforceColorSpace=None,
+                 initialFontName=None,
+                 initialFontSize=None,
+                 initialLeading=None,
+                 cropBox=None,
+                 artBox=None,
+                 trimBox=None,
+                 bleedBox=None,
                  ):
         """Create a canvas of a given size. etc.
 
@@ -255,6 +262,11 @@
         """
         if pagesize is None: pagesize = rl_config.defaultPageSize
         if invariant is None: invariant = rl_config.invariant
+
+        self._initialFontName = initialFontName if initialFontName else rl_config.canvas_basefontname
+        self._initialFontSize = initialFontSize if initialFontSize is not None else 12
+        self._initialLeading = initialLeading if initialLeading is not None else self._initialFontSize*1.2
+
         self._filename = filename
 
         self._doc = pdfdoc.PDFDocument(compression=pageCompression,
@@ -297,6 +309,12 @@
         #drawing coordinates.
         self.bottomup = bottomup
         self.imageCaching = rl_config.defaultImageCaching
+
+        self._cropBox = cropBox     #we don't do semantics for these at all
+        self._artBox = artBox
+        self._trimBox = trimBox
+        self._bleedBox = bleedBox
+
         self.init_graphics_state()
         self._make_preamble()
         self.state_stack = []
@@ -330,11 +348,11 @@
         #initial graphics state, never modify any of these in place
         self._x = 0
         self._y = 0
-        self._fontname = rl_config.canvas_basefontname
-        self._fontsize = 12
+        self._fontname = self._initialFontName
+        self._fontsize = self._initialFontSize
 
         self._textMode = 0  #track if between BT/ET
-        self._leading = 14.4
+        self._leading = self._initialLeading
         self._currentMatrix = (1., 0., 0., 1., 0., 0.)
         self._fillMode = 0   #even-odd
 
@@ -630,6 +648,10 @@
         page.hasImages = self._currentPageHasImages
         page.setPageTransition(self._pageTransition)
         page.setCompression(self._pageCompression)
+        for box in ('crop','art','bleed','trim'):
+            size = getattr(self,'_%sBox'%box,None)
+            if size:
+                setattr(page,box.capitalize()+'Box',pdfdoc.PDFArray(size))
         if self._pageDuration is not None:
             page.Dur = self._pageDuration
 
@@ -1230,6 +1252,23 @@
         self._pagesize = size
         self._make_preamble()
 
+    def setCropBox(self, size, name='crop'):
+        """accepts a 2-tuple in points for name+'Box' size for this and subsequent pages"""
+        name = name.lower()
+        if name.endswith('box'): name = name[:-3]
+        if name not in ('crop','art','trim','bleed'):
+            raise ValueError('unknown box name: %r' % name)
+        setattr(self,'_%sBox' % name, size)
+
+    def setTrimBox(self,size):
+        self.setCropBox(size,name='trim')
+
+    def setArtBox(self,size):
+        self.setCropBox(size,name='art')
+
+    def setBleedBox(self,size):
+        self.setCropBox(size,name='bleed')
+
     def setPageRotation(self, rot):
         """Instruct display device that this page is to be rotated"""
         assert rot % 90.0 == 0.0, "Rotation must be a multiple of 90 degrees"
@@ -1597,19 +1636,8 @@
 
         Standard set now, but may grow in future with font embedding."""
         fontnames = self._doc.getAvailableFonts()
-        fontnames.sort()
         return fontnames
 
-    def addFont(self, fontObj):
-        "add a new font for subsequent use."
-        self._doc.addFont(fontObj)
-
-    def _addStandardFonts(self):
-        """Ensures the standard 14 fonts are available in the system encoding.
-        Called by canvas on initialization"""
-        for fontName in pdfmetrics.standardFonts:
-            self.addFont(pdfmetrics.fontsByName[fontName])
-
     def listLoadedFonts0(self):
         "Convenience function to list all loaded fonts"
         names = list(pdfmetrics.widths.keys())
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/platypus/doctemplate.py
--- a/src/reportlab/platypus/doctemplate.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/platypus/doctemplate.py	Tue Jan 12 14:59:19 2016 +0000
@@ -251,7 +251,12 @@
     derived classes can also implement beforeDrawPage and afterDrawPage if they want
     """
     def __init__(self,id=None,frames=[],onPage=_doNothing, onPageEnd=_doNothing,
-                 pagesize=None, autoNextPageTemplate=None):
+                 pagesize=None, autoNextPageTemplate=None,
+                 cropBox=None,
+                 artBox=None,
+                 trimBox=None,
+                 bleedBox=None,
+                 ):
         frames = frames or []
         if not isSeq(frames): frames = [frames]
         assert [x for x in frames if not isinstance(x,Frame)]==[], "frames argument error"
@@ -261,6 +266,10 @@
         self.onPageEnd = onPageEnd
         self.pagesize = pagesize
         self.autoNextPageTemplate = autoNextPageTemplate
+        self.cropBox = cropBox
+        self.artBox = artBox
+        self.trimBox = trimBox
+        self.bleedBox = bleedBox
 
     def beforeDrawPage(self,canv,doc):
         """Override this if you want additional functionality or prefer
@@ -288,6 +297,10 @@
                 canv.setPageSize(self.pagesize)
             elif cp!=dp:
                 canv.setPageSize(doc.pagesize)
+        for box in 'crop','art','trim','bleed':
+            size = getattr(self,box+'Box',None)
+            if size:
+                canv.setCropBox(size,name=box)
 
     def afterDrawPage(self, canv, doc):
         """This is called after the last flowable for the page has
@@ -302,7 +315,6 @@
         flowables[0:0] = S
         del frame._generated_content
 
-
 class onDrawStr(str):
     def __new__(cls,value,onDraw,label,kind=None):
         self = str.__new__(cls,value)
@@ -453,6 +465,13 @@
                     'enforceColorSpace': None,
                     'displayDocTitle': None,
                     'lang': None,
+                    'initialFontName': None,
+                    'initialFontSize': None,
+                    'initialLeading': None,
+                    'cropBox': None,
+                    'artBox': None,
+                    'trimBox': None,
+                    'bleedBox': None,
                     }
     _invalidInitArgs = ()
     _firstPageTemplateIndex = 0
@@ -496,6 +515,7 @@
         #context sensitive margins - set by story, not from outside
         self._leftExtraIndent = 0.0
         self._rightExtraIndent = 0.0
+        self._topFlowables = []
         self._frameBGs = []
 
         self._calc()
@@ -628,6 +648,8 @@
         f._leftExtraIndent = self._leftExtraIndent
         f._rightExtraIndent = self._rightExtraIndent
         f._frameBGs = self._frameBGs
+        if self._topFlowables:
+            self._hanging.extend(self._topFlowables)
 
     def handle_frameEnd(self,resume=0):
         ''' Handles the semantics of the end of a frame. This includes the selection of
@@ -857,6 +879,13 @@
                                 invariant=self.invariant,
                                 pageCompression=self.pageCompression,
                                 enforceColorSpace=self.enforceColorSpace,
+                                initialFontName = self.initialFontName,
+                                initialFontSize = self.initialFontSize,
+                                initialLeading = self.initialLeading,
+                                cropBox = self.cropBox,
+                                artBox = self.artBox,
+                                trimBox = self.trimBox,
+                                bleedBox = self.bleedBox,
                                 )
 
         getattr(self.canv,'setEncrypt',lambda x: None)(self.encrypt)
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/platypus/flowables.py
--- a/src/reportlab/platypus/flowables.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/platypus/flowables.py	Tue Jan 12 14:59:19 2016 +0000
@@ -1980,3 +1980,17 @@
         if bool(self.funcWrap(aW,aH)):
             self.add_content(*(list(self.block)+[self]))
         return 0,0
+
+class SetTopFlowables(NullDraw):
+    _ZEROZSIZE = 1
+    def __init__(self,F,show=False):
+        self._F = F
+        self._show = show
+
+    def wrap(self,aW,aH):
+        doc = getattr(getattr(self,'canv',None),'_doctemplate',None)
+        if doc:
+            doc._topFlowables=self._F
+            if self._show and self._F:
+                doc.frame._generated_content = self._F
+        return 0,0
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/platypus/paragraph.py
--- a/src/reportlab/platypus/paragraph.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/platypus/paragraph.py	Tue Jan 12 14:59:19 2016 +0000
@@ -253,7 +253,7 @@
                         raise AttributeError("Missing %s callback attribute '%s'" % (kind,name))
                     tx._canvas._curr_tx_info=dict(tx=tx,cur_x=cur_x,cur_y=cur_y,leading=leading,xs=tx.XtraState)
                     try:
-                        func(tx._canvas,kind,cbDefn.label)
+                        func(tx._canvas,kind,getattr(cbDefn,'label',None))
                     finally:
                         del tx._canvas._curr_tx_info
             if f is words[-1]:
@@ -1257,6 +1257,7 @@
         maxlineno = len(maxWidths)-1
         style = self.style
         splitLongWords = style.splitLongWords
+        self._splitLongWordCount = 0
 
         #for bullets, work out width and ensure we wrap the right amount onto line one
         _handleBulletWidth(self.bulletText,style,maxWidths)
@@ -1297,6 +1298,7 @@
                     if wordWidth>max(maxWidths[nmw:nmw+1]) and not isinstance(word,_SplitText) and splitLongWords:
                         #a long word
                         words[0:0] = _splitWord(word,maxWidth-spaceWidth-currentWidth,maxWidths,lineno,fontName,fontSize,self.encoding)
+                        self._splitLongWordCount += 1
                         continue
                 if newWidth <= maxWidth or not len(cLine):
                     # fit one more on this line
@@ -1327,6 +1329,7 @@
                 #preserving splitting algorithm
                 return self.blPara
             n = 0
+            njlbv = not style.justifyBreaks
             words = []
             _words = _getFragWords(frags,maxWidth)
             while _words:
@@ -1356,6 +1359,7 @@
                     if wordWidth>max(maxWidths[nmw:nmw+1]):
                         #a long word
                         _words[0:0] = _splitFragWord(w,maxWidth-spaceWidth-currentWidth,maxWidths,lineno)
+                        self._splitLongWordCount += 1
                         continue
                 endLine = (newWidth>maxWidth and n>0) or lineBreak
                 if not endLine:
@@ -1434,7 +1438,7 @@
                     if currentWidth>self.width: self.width = currentWidth
                     #end of line
                     lines.append(FragLine(extraSpace=maxWidth-currentWidth, wordCount=n,
-                                        lineBreak=lineBreak, words=words, fontSize=maxSize, ascent=maxAscent, descent=minDescent, maxWidth=maxWidth))
+                                        lineBreak=lineBreak and njlbv, words=words, fontSize=maxSize, ascent=maxAscent, descent=minDescent, maxWidth=maxWidth))
 
                     #start new line
                     lineno += 1
@@ -1480,7 +1484,7 @@
             #deal with any leftovers on the final line
             if words!=[]:
                 if currentWidth>self.width: self.width = currentWidth
-                lines.append(ParaLines(extraSpace=(maxWidth - currentWidth),wordCount=n,
+                lines.append(ParaLines(extraSpace=(maxWidth - currentWidth),wordCount=n,lineBreak=False,
                                     words=words, fontSize=maxSize,ascent=maxAscent,descent=minDescent,maxWidth=maxWidth))
             return ParaLines(kind=1, lines=lines)
 
@@ -1594,7 +1598,8 @@
             alignment = style.alignment
             offset = style.firstLineIndent+_offsets[0]
             lim = nLines-1
-            noJustifyLast = not (hasattr(self,'_JustifyLast') and self._JustifyLast)
+            noJustifyLast = not getattr(self,'_JustifyLast',False)
+            jllwc = style.justifyLastLine
 
             if blPara.kind==0:
                 if alignment == TA_LEFT:
@@ -1634,7 +1639,11 @@
                 #now the font for the rest of the paragraph
                 tx.setFont(f.fontName, f.fontSize, leading)
                 ws = lines[0][0]
-                t_off = dpl( tx, offset, ws, lines[0][1], noJustifyLast and nLines==1)
+                words = lines[0][1]
+                lastLine = noJustifyLast and nLines==1
+                if lastLine and jllwc and len(words)>jllwc:
+                    lastLine=False
+                t_off = dpl( tx, offset, ws, words, lastLine)
                 if f.underline or f.link or f.strike or style.endDots:
                     xs = tx.XtraState = ABag()
                     xs.cur_y = cur_y
@@ -1658,21 +1667,29 @@
                     if underline: _do_under_line(0, dx, ws, tx)
                     if strike: _do_under_line(0, dx, ws, tx, lm=0.125)
                     if link: _do_link_line(0, dx, ws, tx)
-                    if noJustifyLast and nLines==1 and style.endDots and dpl!=_rightDrawParaLine: _do_dots(0, dx, ws, xs, tx, dpl)
+                    if lastLine and style.endDots and dpl!=_rightDrawParaLine: _do_dots(0, dx, ws, xs, tx, dpl)
 
                     #now the middle of the paragraph, aligned with the left margin which is our origin.
                     for i in xrange(1, nLines):
                         ws = lines[i][0]
-                        t_off = dpl( tx, _offsets[i], ws, lines[i][1], noJustifyLast and i==lim)
+                        words = lines[i][1]
+                        lastLine = noJustifyLast and i==lim
+                        if lastLine and jllwc and len(words)>jllwc:
+                            lastLine=False
+                        t_off = dpl( tx, _offsets[i], ws, words, lastLine)
                         dx = t_off+leftIndent
                         if dpl!=_justifyDrawParaLine: ws = 0
                         if underline: _do_under_line(i, dx, ws, tx)
                         if strike: _do_under_line(i, dx, ws, tx, lm=0.125)
                         if link: _do_link_line(i, dx, ws, tx)
-                        if noJustifyLast and i==lim and style.endDots and dpl!=_rightDrawParaLine: _do_dots(i, dx, ws, xs, tx, dpl)
+                        if lastLine and style.endDots and dpl!=_rightDrawParaLine: _do_dots(i, dx, ws, xs, tx, dpl)
                 else:
                     for i in xrange(1, nLines):
-                        dpl( tx, _offsets[i], lines[i][0], lines[i][1], noJustifyLast and i==lim)
+                        words = lines[i][1]
+                        lastLine = noJustifyLast and i==lim
+                        if lastLine and jllwc and len(words)>jllwc:
+                            lastLine=False
+                        dpl( tx, _offsets[i], lines[i][0], words, lastLine)
             else:
                 if self.style.wordWrap == 'RTL':
                     for line in lines:
@@ -1732,13 +1749,20 @@
                 xs.autoLeading = autoLeading
 
                 tx._fontname,tx._fontsize = None, None
-                dpl( tx, offset, lines[0], noJustifyLast and nLines==1)
+                line = lines[0]
+                lastLine = noJustifyLast and nLines==1
+                if lastLine and jllwc and line.wordCount>jllwc:
+                    lastLine=False
+                dpl( tx, offset, line, lastLine)
                 _do_post_text(tx)
 
                 #now the middle of the paragraph, aligned with the left margin which is our origin.
                 for i in xrange(1, nLines):
-                    f = lines[i]
-                    dpl( tx, _offsets[i], f, noJustifyLast and i==lim)
+                    line = lines[i]
+                    lastLine = noJustifyLast and i==lim
+                    if lastLine and jllwc and line.wordCount>jllwc:
+                        lastLine=False
+                    dpl( tx, _offsets[i], line, lastLine)
                     _do_post_text(tx)
 
             canvas.drawText(tx)
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/platypus/paraparser.py
--- a/src/reportlab/platypus/paraparser.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/platypus/paraparser.py	Tue Jan 12 14:59:19 2016 +0000
@@ -14,7 +14,7 @@
 import reportlab.lib.sequencer
 
 from reportlab.lib.abag import ABag
-from reportlab.lib.utils import ImageReader, isPy3, annotateException, encode_label, asUnicode, asBytes, uniChr
+from reportlab.lib.utils import ImageReader, isPy3, annotateException, encode_label, asUnicode, asBytes, uniChr, isStr
 from reportlab.lib.colors import toColor, white, black, red, Color
 from reportlab.lib.fonts import tt2ps, ps2tt
 from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
@@ -71,6 +71,20 @@
         s = s[:-4]
     return _convnum(s,unit,allowRelative)
 
+def _int(s):
+    try:
+        return int(s)
+    except:
+        raise ValueError('cannot convert %r to int' % s)
+
+def _bool(s):
+    s = s.lower()
+    if s in ('true','1','yes'):
+        return True
+    if s in ('false','0','no'):
+        return False
+    raise ValueError('cannot convert %r to bool value' % s)
+
 def _numpct(s,unit=1,allowRelative=False):
     if s.endswith('%'):
         return _PCT(_convnum(s[:-1],allowRelative=allowRelative))
@@ -119,6 +133,20 @@
         raise ValueError('illegal bullet anchor %r' % s)
     return s
 
+def _wordWrapConv(s):
+    s = s.upper().strip()
+    if not s: return None
+    if s not in ('CJK','RTL','LTR'):
+        raise ValueError('cannot convert wordWrap=%r' % s)
+    return s
+
+def _textTransformConv(s):
+    s = s.lower().strip()
+    if not s: return None
+    if s not in ('uppercase','lowercase','capitalize','none'):
+        raise ValueError('cannot convert wordWrap=%r' % s)
+    return s
+
 _paraAttrMap = {'font': ('fontName', None),
                 'face': ('fontName', None),
                 'fontsize': ('fontSize', _num),
@@ -142,6 +170,19 @@
                 'bgcolor':('backColor',toColor),
                 'bg':('backColor',toColor),
                 'fg': ('textColor',toColor),
+                'justifybreaks': ('justifyBreaks',_bool),
+                'justifylastline': ('justifyLastLine',_int),
+                'wordwrap': ('wordWrap',_wordWrapConv),
+                'allowwidows': ('allowWidows',_bool),
+                'alloworphans': ('allowOrphans',_bool),
+                'splitlongwords': ('splitLongWords',_bool),
+                'borderwidth': ('borderWidth',_num),
+                'borderpadding': ('borderpadding',_num),
+                'bordercolor': ('borderColor',toColor),
+                'borderradius': ('borderRadius',_num),
+                'texttransform':('textTransform',_textTransformConv),
+                'enddots':('endDots',None),
+                'underlineproportion':('underlineProportion',_num),
                 }
 
 _bulletAttrMap = {
@@ -1010,7 +1051,7 @@
         for k, v in attr.items():
             if not self.caseSensitive:
                 k = k.lower()
-            if k in list(attrMap.keys()):
+            if k in attrMap:
                 j = attrMap[k]
                 func = j[1]
                 try:
@@ -1018,6 +1059,7 @@
                 except:
                     self._syntax_error('%s: invalid value %s'%(k,v))
             else:
+                raise ValueError('invalid attribute name %s attrMap=%r'% (k,list(sorted(attrMap.keys()))))
                 self._syntax_error('invalid attribute name %s'%k)
         return A
 
diff -r 5d54c7381247 -r 9533002fdeae src/reportlab/rl_settings.py
--- a/src/reportlab/rl_settings.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/reportlab/rl_settings.py	Tue Jan 12 14:59:19 2016 +0000
@@ -50,7 +50,8 @@
 CMapSearchPath
 baseUnderlineProportion
 decimalSymbol
-errorOnDuplicatePageLabelPage'''.split())
+errorOnDuplicatePageLabelPage
+autoGenerateMissingTTFName'''.split())
 
 allowTableBoundsErrors =    1 # set to 0 to die on too large elements in tables in debug (recommend 1 for production use)
 shapeChecking =             1
@@ -104,6 +105,7 @@
                                                     #by default typical value 0.05. may be overridden on a parastyle.
 decimalSymbol=              '.'                     #what we use to align floats numerically
 errorOnDuplicatePageLabelPage= 0                    #if True will cause repeated PageLabel page numbers to raise an error.
+autoGenerateMissingTTFName=0                        #if true we try to auto generate any missing TTF font name
 
 # places to look for T1Font information
 T1SearchPath =  (
diff -r 5d54c7381247 -r 9533002fdeae src/rl_addons/rl_accel/_rl_accel.c
--- a/src/rl_addons/rl_accel/_rl_accel.c	Tue Jun 02 13:10:14 2015 +0100
+++ b/src/rl_addons/rl_accel/_rl_accel.c	Tue Jan 12 14:59:19 2016 +0000
@@ -29,11 +29,10 @@
 #ifndef min
 #	define min(a,b) ((a)<(b)?(a):(b))
 #endif
-#define VERSION "0.70"
+#define VERSION "0.71"
 #define MODULE "_rl_accel"
 
 struct module_state	{
-	PyObject *moduleVersion;
 	int moduleLineno;
 #ifndef isPy3
 	PyObject *module;
@@ -1274,20 +1273,8 @@
 	{NULL,		NULL}		/* sentinel */
 	};
 
-/*Initialization function for the module (*must* be called init_pdfmetrics)*/
+/*Initialization function for the module*/
 #ifdef isPy3
-static int _traverse(PyObject *m, visitproc visit, void *arg) {
-	struct module_state *st = GETSTATE(m);
-	Py_VISIT(st->moduleVersion);
-	return 0;
-	}
-
-static int _clear(PyObject *m) {
-	struct module_state *st = GETSTATE(m);
-	Py_CLEAR(st->moduleVersion);
-	return 0;
-	}
-
 static struct PyModuleDef moduledef = {
 	PyModuleDef_HEAD_INIT,
 	"_rl_accel",
@@ -1295,8 +1282,8 @@
 	sizeof(struct module_state),
 	_methods,
 	NULL,
-	_traverse,
-	_clear,
+	NULL,
+	NULL,
 	NULL
 	};
 
@@ -1305,8 +1292,7 @@
 void init_rl_accel(void)
 #endif
 {
-	PyObject			*module=NULL;
-	struct module_state *st=NULL;
+	PyObject			*module=NULL, *moduleVersion=NULL;
 	/*Create the module and add the functions and module doc string*/
 #ifdef isPy3
 	module = PyModule_Create(&moduledef);
@@ -1314,14 +1300,13 @@
 	module = Py_InitModule3("_rl_accel", _methods,__DOC__);
 #endif
 	if(!module) goto err;
-	st=GETSTATE(module);
 	/*Add some symbolic constants to the module */
-	st->moduleVersion = PyBytes_FromString(VERSION);
-	if(!st->moduleVersion)goto err;
+	moduleVersion = PyBytes_FromString(VERSION);
+	if(!moduleVersion)goto err;
 #ifndef isPy3
-	st->module = module;
+	GETSTATE(module)->module = module;
 #endif
-	PyModule_AddObject(module, "version", st->moduleVersion );
+	PyModule_AddObject(module, "version", moduleVersion);
 
 #ifdef	HAVE_BOX
 #ifndef isPy3
@@ -1342,9 +1327,7 @@
 
 err:/*Check for errors*/
 #ifdef isPy3
-	if(st){
-		Py_XDECREF(st->moduleVersion);
-		}
+	Py_XDECREF(moduleVersion);
 	Py_XDECREF(module);
 	return NULL;
 #else
diff -r 5d54c7381247 -r 9533002fdeae tests/test_docstrings.py
--- a/tests/test_docstrings.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_docstrings.py	Tue Jan 12 14:59:19 2016 +0000
@@ -13,8 +13,7 @@
 setOutDir(__name__)
 import os, sys, glob, re, unittest, inspect
 import reportlab
-isPy3= reportlab.isPy3
-from reportlab.lib.utils import rl_exec
+from reportlab.lib.utils import rl_exec, isPy3, isPyPy
 
 def typ2is(typ):
     return getattr(inspect,'is'+typ)
@@ -23,7 +22,7 @@
         'module':lambda x: (x[0],getattr(x[1],'__name__',''),getattr(x[1],'__path__',getattr(x,'__file__',''))),
         'class':lambda x: (x[0],getattr(x[1],'__name__',''),getattr(x[1],'__module__','')),
         'method':lambda x: (x[0],getattr(x[1],'__name__',''),getattr(x[1],'__module__','')),
-        'function':lambda x: (x[0],getattr(x[1],'__name__',''),x[1].__code__.co_filename),
+        'function':lambda x: (x[0],getattr(x[1],'__name__',''),'???' if isPyPy else x[1].__code__.co_filename),
         }
 def typ2key(typ):
     return _typ2key[typ]
@@ -97,7 +96,7 @@
             continue
         typ = obj2typ(obj)
         if typ in ('function','method'):
-            if os.path.splitext(obj.__code__.co_filename)[0]==modBn:
+            if not isPyPy and os.path.splitext(obj.__code__.co_filename)[0]==modBn:
                 lookup[obj] = 1
                 objects.setdefault(typ if typ=='function' and ttyp=='module' else 'method',[]).append((mName,obj))
         elif typ=='class':
diff -r 5d54c7381247 -r 9533002fdeae tests/test_graphics_barcode.py
--- a/tests/test_graphics_barcode.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_graphics_barcode.py	Tue Jan 12 14:59:19 2016 +0000
@@ -7,6 +7,11 @@
 setOutDir(__name__)
 import unittest, os, sys, glob
 
+try:
+    from reportlab.graphics import _renderPM
+except ImportError:
+    _renderPM = None
+
 class BarcodeWidgetTestCase(unittest.TestCase):
     "Test barcode classes."
 
@@ -18,6 +23,7 @@
         for x in glob.glob(os.path.join(outDir,'*')):
             os.remove(x)
 
+    @unittest.skipIf(not _renderPM,'no _renderPM')
     def test0(self):
         from reportlab.graphics.shapes import Drawing
         outDir = self.outDir
diff -r 5d54c7381247 -r 9533002fdeae tests/test_graphics_charts.py
--- a/tests/test_graphics_charts.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_graphics_charts.py	Tue Jan 12 14:59:19 2016 +0000
@@ -30,7 +30,10 @@
 from reportlab.graphics.charts.spider import SpiderChart
 from reportlab.graphics.widgets.markers import makeMarker
 
-
+try:
+    from reportlab.graphics import _renderPM
+except ImportError:
+    _renderPM = None
 
 def myMainPageFrame(canvas, doc):
     "The page frame used for all PDF documents."
@@ -412,6 +415,7 @@
         story.append(drawing8)
         story.append(Spacer(0,1*cm))
 
+    @unittest.skipIf(not _renderPM,'no _renderPM')
     def test8(self):
         '''text _text2Path'''
         story = self.story
diff -r 5d54c7381247 -r 9533002fdeae tests/test_graphics_render.py
--- a/tests/test_graphics_render.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_graphics_render.py	Tue Jan 12 14:59:19 2016 +0000
@@ -7,6 +7,10 @@
 setOutDir(__name__)
 import unittest, os, sys, glob
 from reportlab.lib.utils import isPy3
+try:
+    from reportlab.graphics import _renderPM
+except:
+    _renderPM = None
 
 class RenderTestCase(unittest.TestCase):
     "Test renderPS classes."
@@ -22,10 +26,12 @@
     def test0(self):
         from reportlab.graphics.renderPS import test
         assert test(self.outDir) is None
+
     def test1(self):
         from reportlab.graphics.renderPDF import test
         assert test(self.outDir) is None
 
+    @unittest.skipIf(not _renderPM,'no _renderPM')
     def test2(self):
         from reportlab.graphics.renderPM import test
         assert test(self.outDir) is None
diff -r 5d54c7381247 -r 9533002fdeae tests/test_invariant.py
--- a/tests/test_invariant.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_invariant.py	Tue Jan 12 14:59:19 2016 +0000
@@ -14,7 +14,7 @@
 
 class InvarTestCase(unittest.TestCase):
     "Simplest test that makes PDF"
-    def test(self):
+    def test0(self):
         import os
         from reportlab.lib.testutils import testsFolder
         c = Canvas(filename, invariant=1, pageCompression=0)
@@ -24,7 +24,8 @@
         c.drawImage(gif,100,600)
         c.save()
 
-        raw1 = open(filename, 'rb').read()
+        with open(filename, 'rb') as f:
+            raw1 = f.read()
 
         c = Canvas(filename, invariant=1, pageCompression=0)
         c.setFont('Helvetica-Bold', 36)
@@ -32,9 +33,22 @@
         c.drawImage(gif,100,600)
         c.save()
 
-        raw2 = open(filename, 'rb').read()
+        with open(filename, 'rb') as f:
+            raw2 = f.read()
+
         assert raw1 == raw2, 'repeated runs differ!'
 
+    def test1(self):
+        import os
+        from reportlab.lib.testutils import testsFolder
+        filename = outputfile('test_no_helvetica.pdf')
+        c = Canvas(filename, invariant=1, pageCompression=0, initialFontName='Times-Roman')
+        c.drawString(100,700, 'Hello World')
+        c.save()
+        with open(filename, 'rb') as f:
+            raw = f.read()
+        assert b'Helvetica' not in raw and b'Times-Roman' in raw, 'Canvas initialFontName expectations not satisfied!'
+
 def makeSuite():
     return makeSuiteForClasses(InvarTestCase)
 
diff -r 5d54c7381247 -r 9533002fdeae tests/test_lib_utils.py
--- a/tests/test_lib_utils.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_lib_utils.py	Tue Jan 12 14:59:19 2016 +0000
@@ -10,7 +10,7 @@
 import unittest
 from reportlab.lib import colors
 from reportlab.lib.utils import recursiveImport, recursiveGetAttr, recursiveSetAttr, rl_isfile, \
-                                isCompactDistro, isPy3
+                                isCompactDistro, isPy3, isPyPy
 
 def _rel_open_and_read(fn):
     from reportlab.lib.utils import open_and_read
@@ -151,8 +151,12 @@
             m1 = recursiveImport('unimportable')
             self.fail("Imported a buggy module")
         except Exception as e:
-            self.assertIn(reportlab.isPy3 and 'division by zero' or 'integer division or modulo by zero',str(e))
-
+            self.assertIn(("integer division by zeroException raised while importing 'unimportable': integer division by zero"
+                            if isPyPy 
+                            else ('division by zero' if isPy3
+                                 else 'integer division or modulo by zero'))
+                        ,str(e))
+ 
 def makeSuite():
     return makeSuiteForClasses(ImporterTestCase)
 
diff -r 5d54c7381247 -r 9533002fdeae tests/test_pdfbase_ttfonts.py
--- a/tests/test_pdfbase_ttfonts.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_pdfbase_ttfonts.py	Tue Jan 12 14:59:19 2016 +0000
@@ -56,6 +56,19 @@
         c.drawString(100, 700, b'Hello, ' + utf8(0xffee))
         c.save()
 
+    def testSameTTFDifferentName(self):
+        "Test PDF generation with TrueType fonts"
+        pdfmetrics.registerFont(TTFont("Vera", "Vera.ttf"))
+        pdfmetrics.registerFont(TTFont("MyVera", "Vera.ttf"))
+
+        # Do it twice with the same font object
+        c = Canvas(outputfile('test_pdfbase_ttfontsduplicate.pdf'))
+        # Draw a table of Unicode characters
+        c.setFont('Vera', 10)
+        c.drawString(100, 700, b'Hello World')
+        c.setFont('MyVera', 10)
+        c.drawString(100, 688, b'Hello World')
+        c.save()
 
 class TTFontFileTestCase(NearTestCase):
     "Tests TTFontFile, TTFontParser and TTFontMaker classes"
diff -r 5d54c7381247 -r 9533002fdeae tests/test_pdfgen_general.py
--- a/tests/test_pdfgen_general.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_pdfgen_general.py	Tue Jan 12 14:59:19 2016 +0000
@@ -209,7 +209,7 @@
     c.drawString(100, 100, msg_uni)
     c.drawString(100, 80, msg_utf8)
 
-    
+
 
 
     t = c.beginText(inch, 10*inch)
@@ -546,7 +546,7 @@
         if anchor=='end':
             x -= width
         elif anchor in ('centre','center'):
-            x = 0.5*width 
+            x = 0.5*width
         c.saveState()
         c.setDash(2,2)
         c.setStrokeColor(color)
@@ -824,33 +824,33 @@
         #preserveAspectRatio test
         c.drawString(inch, 8.8*inch, 'Both of these should appear within the boxes, vertically centered')
 
-    
+
         x, y, w, h = inch, 6.75* inch, 2*inch, 2*inch
         c.rect(x, y, w, h)
         (w2, h2) = c.drawImage(gif,  #anchor southwest, drawImage
-                    x, y, width=w, height=h, 
-                    preserveAspectRatio=True, 
+                    x, y, width=w, height=h,
+                    preserveAspectRatio=True,
                     anchor='c'
                     )
-                    
-        #now test drawInlineImage across the page            
+
+        #now test drawInlineImage across the page
         x = 5 * inch
         c.rect(x, y, w, h)
         (w2, h2) = c.drawInlineImage(gif,  #anchor southwest, drawInlineImage
-                    x, y, width=w, height=h, 
+                    x, y, width=w, height=h,
                     preserveAspectRatio=True,
                     anchor='c'
                     )
-                    
-        c.drawString(inch, 5.75*inch, 
+
+        c.drawString(inch, 5.75*inch,
         'anchored by respective corners - use both a wide and a tall one as tests')
         x = 0.25 * inch
         for anchor in ['nw','n','ne','w','c','e','sw','s','se']:
             x += 0.75*inch
             c.rect(x, 5*inch, 0.6*inch, 0.6*inch)
             c.drawImage(
-                    gif, x, 5*inch, 
-                    width=0.6*inch, height=0.6*inch, 
+                    gif, x, 5*inch,
+                    width=0.6*inch, height=0.6*inch,
                     preserveAspectRatio=True,
                     anchor=anchor
                     )
@@ -862,8 +862,8 @@
             x += 0.75*inch
             c.rect(x, 4*inch, 0.6*inch, 0.6*inch)
             c.drawImage(
-                    tall_red, x, 4*inch, 
-                    width=0.6*inch, height=0.6*inch, 
+                    tall_red, x, 4*inch,
+                    width=0.6*inch, height=0.6*inch,
                     preserveAspectRatio=True,
                     anchor=anchor
                     )
@@ -1034,7 +1034,7 @@
             c.showPage()
 
         # Output the PDF
-        c.save()    
+        c.save()
 
     def test2(self):
         c=canvas.Canvas('test_pdfgen_autocropmarks.pdf',cropMarks=True)
@@ -1112,7 +1112,7 @@
         self.assertRaises(ValueError,trySomeColors,rgb+cmyk+seps,'rgb')
         self.assertRaises(ValueError,trySomeColors,rgb+cmyk,'rgb')
         self.assertRaises(ValueError,trySomeColors,rgb+seps,'rgb')
-        trySomeColors(rgb+sepb,'rgb')   #should work because blacks are convertible 
+        trySomeColors(rgb+sepb,'rgb')   #should work because blacks are convertible
         trySomeColors(rgb+cmykb,'rgb')
         self.assertRaises(ValueError,trySomeColors,cmyk+rgb+seps,'cmyk')
         trySomeColors(cmyk+['black']+seps,'cmyk')   #OK because black & seps are convertible
@@ -1167,8 +1167,18 @@
         # Output the PDF
         stuff = c.getpdfdata()
         #multiple calls to save / getpdfdata used to cause errors
-        stuff = c.getpdfdata()    
+        stuff = c.getpdfdata()
 
+    def testBoxes(self):
+        c=canvas.Canvas(outputfile('test_pdfgen_boxes.pdf'))
+        w,h = c._pagesize
+        c.setCropBox((0.1,0.1,w-0.2,h-0.2))
+        c.setBleedBox((-0.1,-0.1,w+0.2,h+0.2))
+        c.setArtBox((0.2,0.2,w-0.4,h-0.4))
+        c.setTrimBox((0.01,0.01,w-0.02,h-0.02))
+        c.drawString(100, 700, 'Hello World!')
+        c.showPage()
+        c.save()
 
 def trySomeColors(C,enforceColorSpace=None):
     from reportlab.lib.utils import getBytesIO
diff -r 5d54c7381247 -r 9533002fdeae tests/test_platypus_breaking.py
--- a/tests/test_platypus_breaking.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_platypus_breaking.py	Tue Jan 12 14:59:19 2016 +0000
@@ -18,6 +18,7 @@
 from reportlab.lib.randomtext import randomText, PYTHON
 from reportlab.platypus.doctemplate import PageTemplate, BaseDocTemplate, Indenter, SimpleDocTemplate
 from reportlab.platypus.paragraph import *
+from reportlab.rl_config import invariant
 
 
 def myMainPageFrame(canvas, doc):
@@ -86,7 +87,7 @@
         <a name='top'/>Subsequent pages test pageBreakBefore, frameBreakBefore and
         keepTogether attributes.  Generated at %s.  The number in brackets
         at the end of each paragraph is its position in the story. (%d)""" % (
-            time.ctime(time.time()), len(story)), bt))
+            time.ctime(946684800.0 if invariant else time.time()), len(story)), bt))
 
     for i in range(10):
         a(Paragraph('Heading 1 always starts a new page (%d)' % len(story), h1))
diff -r 5d54c7381247 -r 9533002fdeae tests/test_platypus_paragraphs.py
--- a/tests/test_platypus_paragraphs.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_platypus_paragraphs.py	Tue Jan 12 14:59:19 2016 +0000
@@ -583,8 +583,9 @@
 phonemic and morphological analysis.'''
         story =[]
         a = story.append
-        for mode in (0,1,2,3,4):
+        for mode in (0,1,2,3,4,5,6,7):
             text = text0
+            paraStyle = normal_just
             if mode==1:
                 text = text.replace('English sentences','<b>English sentences</b>').replace('quite equivalent','<i>quite equivalent</i>')
                 text = text.replace('the methodological work','<b>the methodological work</b>').replace('to impose problems','<i>to impose problems</i>')
@@ -599,10 +600,26 @@
                 text = text.replace('English ','English&nbsp;').replace('quite ','quite&nbsp;')
                 text = text.replace(' methodological','&nbsp;methodological').replace(' impose','&nbsp;impose')
                 a(Paragraph('Justified paragraph in normal font &amp; some hard spaces',style=normal))
+            elif mode in (5,6,7):
+                text = text.replace('as to impose','<br/>as to impose').replace(' most of the','<br/>most of the')
+                text = text.replace(' grounds','<br/>grounds').replace(' various','<br/>various')
+                if mode in (6,7):
+                    msg = []
+                    msg.append('justifyBreaks=1')
+                    paraStyle = paraStyle.clone('paraStyle6',paraStyle,justifyBreaks=1)
+                    if mode==7:
+                        msg.append('justifyLastLine=3')
+                        paraStyle = paraStyle.clone('paraStyle7',paraStyle,justifyLastLine=3)
+                    msg = '(%s) ' % (' '.join(msg))
+                else:
+                    a(PageBreak())
+                    msg = ' '
+
+                a(Paragraph('Justified%swith some &lt;br/&gt; tags' % msg,style=normal))
             else:
                 a(Paragraph('Justified paragraph in normal font',style=normal))
 
-            a(Paragraph(text,style=normal_just))
+            a(Paragraph(text,style=paraStyle))
         doc = MyDocTemplate(outputfile('test_platypus_paragraphs_just.pdf'))
         doc.build(story)
 
diff -r 5d54c7381247 -r 9533002fdeae tests/test_renderSVG.py
--- a/tests/test_renderSVG.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_renderSVG.py	Tue Jan 12 14:59:19 2016 +0000
@@ -259,9 +259,8 @@
     </body>
 <html>
 """
-        open('test_renderSVG_output.html', 'w').write(body)
-        
-
+        with open('test_renderSVG_output.html', 'w') as f:
+            f.write(body)
 
 class RenderSvgAxesTestCase(unittest.TestCase):
     "Testing renderSVG module on Axes widgets."
diff -r 5d54c7381247 -r 9533002fdeae tests/test_rl_accel.py
--- a/tests/test_rl_accel.py	Tue Jun 02 13:10:14 2015 +0100
+++ b/tests/test_rl_accel.py	Tue Jan 12 14:59:19 2016 +0000
@@ -1,7 +1,7 @@
 __version__=''' $Id'''
 __doc__='''basic tests.'''
 from reportlab.lib.testutils import setOutDir,makeSuiteForClasses, printLocation
-from reportlab.lib.utils import asBytes
+from reportlab.lib.utils import asBytes, isPyPy
 setOutDir(__name__)
 
 import unittest
@@ -9,6 +9,7 @@
     return (_c_funcs.get(name,None),'c'),(_py_funcs.get(name,None),'py')
 
 def getrc(defns,depth=1):
+    if isPyPy: return ''
     from sys import getrefcount, _getframe
     f = _getframe(depth)
     G0 = f.f_globals
@@ -31,6 +32,7 @@
     return ' '.join([str(getrefcount(eval(x,L,G0))-1) for x in defns.split()])
 
 def checkrc(defns,rcv0):
+    if isPyPy: return ''
     rcv1 = getrc(defns,2)
     return ' '.join(["%s %s-->%s" % (x,v,w) for x,v,w in zip(defns.split(),rcv0.split(),rcv1.split()) if v!=w])
 
