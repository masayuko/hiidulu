diff -uNr reportlab-3.1.8/PKG-INFO reportlab-3.1.41/PKG-INFO
--- reportlab-3.1.8/PKG-INFO	2014-04-22 21:34:11.000000000 +0900
+++ reportlab-3.1.41/PKG-INFO	1970-01-01 09:00:00.000000000 +0900
@@ -1,11 +0,0 @@
-
-Metadata-Version: 1.0
-Name: reportlab
-Version: 3.1.8
-Summary: The ReportLab Toolkit
-Home-page: http://www.reportlab.com/
-Author: Andy Robinson, Robin Becker, the ReportLab team and the community
-Author-email: reportlab-users@lists2.reportlab.com
-License: BSD license (see license.txt for details), Copyright (c) 2000-2010, ReportLab Inc.
-Description: The ReportLab Toolkit. An Open Source Python library for generating PDFs and graphics.
-Platform: UNKNOWN
diff -uNr reportlab-3.1.8/README.txt reportlab-3.1.41/README.txt
--- reportlab-3.1.8/README.txt	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/README.txt	2014-08-12 20:28:18.695110803 +0900
@@ -54,31 +54,25 @@
 
 2.1 General prerequisites
 --------------------------
-You need to have installed Python (versions 2.5 through 2.7),
-and ideally PIL with Freetype support; more notes on prerequisites
+You need to have installed Python (versions 2.7 or >=3.3),
+and ideally PIL or Pillow with Freetype support; more notes on prerequisites
 follow below.  
 
 2.2. Where to get the code
 ------------------------------------------
+Latest builds are available from ReportLab's
+open source download area::
 
-    
-Daily and release builds are available from ReportLab's
-open download area::
-
-    http://www.reportlab.org/ftp/
+    https://www.reportlab.com/pypi/
 
-Daily builds will unzip/untar to produce a dated directory e.g. 
-``reportlab-YYYYMMDD/`` but are otherwise structured just like the Mercurial
-repository and release builds.
-
-Releases are also available from the Python Package Index:
+Main releases are also available from the Python Package Index:
 
     http://pypi.python.org/
 
 From March 2013, the code is being hosted in Mercurial on BitBucket.
 You can obtain the latest code from our Mercurial repository with::
 
-    hg clone http://bitbucket.org/rptlab/reportlab
+    hg clone https://bitbucket.org/rptlab/reportlab
 
 
 Users of our commercial libraries, and/or anyone who registers on our site,
@@ -89,16 +83,21 @@
 
 
 
-2.3 Windows Installer
---------------------------
-A binary ``.exe`` installer for Windows (built with distutils) is
-available on our website.  This will install the 'reportlab' package
-into your site-packages area (e.g. ``C:\Python27\lib\site-packages``).
+2.3 Windows Packages
+--------------------
+We no longer made .exe or .msi files.  We provide ``.whl`` files with compiled 
+C extensions for all supported python versions at 
+
+    http://pypi.python.org/pypi/reportlab/
+
+These may be installed using recent `pip` or other competent distribution
+package.  If you aren't comfortable with the command line, we recommend pip-win:
+    https://sites.google.com/site/pydatalog/python/pip-for-windows
 
 This will NOT install the tests, examples and documentation.  If you want
 to learn your way around the package or do development with it on Windows,
-we suggest you also download a source copy, unzip it and work with the
-examples/tests within that directory.
+we suggest you also obtain source from https://bitbucket.org/rptlab/reportlab 
+and work with the examples/tests within that directory.
 
 2.4 Mac OS
 -------------
@@ -146,7 +145,7 @@
 going back to Python 1.5 or thereabouts.
 
 There are no absolute prerequisites beyond the Python
-standard library; but the Python Imaging Library (PIL)
+standard library; but the Python Imaging Library (PIL or Pillow)
 is needed to include images other than JPG inside PDF files.
 
 The C extension are optional but anyone able to do so should
diff -uNr reportlab-3.1.8/setup.py reportlab-3.1.41/setup.py
--- reportlab-3.1.8/setup.py	2014-04-03 18:38:20.000000000 +0900
+++ reportlab-3.1.41/setup.py	2014-08-12 20:28:18.696110802 +0900
@@ -522,7 +522,7 @@
             ext_modules =   EXT_MODULES,
             
             #this probably only works for setuptools, but distutils seems to ignore it
-            install_requires=['pillow ==2.0.0, >=2.4.0','pip>=1.4.1', 'setuptools>=2.2'],
+            install_requires=['pillow>=2.4.0','pip>=1.4.1', 'setuptools>=2.2'],
             )
         print()
         print('########## SUMMARY INFO #########')
diff -uNr reportlab-3.1.8/src/reportlab/__init__.py reportlab-3.1.41/src/reportlab/__init__.py
--- reportlab-3.1.8/src/reportlab/__init__.py	2014-04-22 21:33:42.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/__init__.py	2014-08-12 20:28:18.697110801 +0900
@@ -3,7 +3,7 @@
 #history http://www.reportlab.co.uk/cgi-bin/viewcvs.cgi/public/reportlab/trunk/reportlab/__init__.py
 __version__=''' $Id$ '''
 __doc__="""The Reportlab PDF generation library."""
-Version = "3.1.8"
+Version = "3.1.29"
 
 import sys, os, imp
 
diff -uNr reportlab-3.1.8/src/reportlab/graphics/barcode/qr.py reportlab-3.1.41/src/reportlab/graphics/barcode/qr.py
--- reportlab-3.1.8/src/reportlab/graphics/barcode/qr.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/barcode/qr.py	2014-08-12 20:28:18.716110786 +0900
@@ -1,60 +1,94 @@
-# QRCode for Python
 #
-# Ported from the Javascript library by Sam Curren
-# ReportLab module by German M. Bravo
+# ReportLab QRCode widget
 #
-# QRCode for Javascript
-# http://d-project.googlecode.com/svn/trunk/misc/qrcode/js/qrcode.js
-#
-# Copyright (c) 2009 Kazuhiko Arase
+# Ported from the Javascript library QRCode for Javascript by Sam Curren
 #
 # URL: http://www.d-project.com/
+# http://d-project.googlecode.com/svn/trunk/misc/qrcode/js/qrcode.js
+# qrcode.js is copyright (c) 2009 Kazuhiko Arase
+#
+# Original ReportLab module by German M. Bravo
 #
-# Licensed under the MIT license:
-#   http://www.opensource.org/licenses/mit-license.php
+# modified and improved by Anders Hammarquist <iko@openend.se>
+# and used with permission under the ReportLab License
 #
 # The word "QR Code" is registered trademark of
 # DENSO WAVE INCORPORATED
 #   http://www.denso-wave.com/qrcode/faqpatent-e.html
 
-__all__=(
-        'QrCodeWidget',
-        )
-import math, re
+__all__ = ('QrCodeWidget')
+
+import itertools
+
+from reportlab.platypus.flowables import Flowable
 from reportlab.graphics.shapes import Group, Rect
 from reportlab.lib import colors
-from reportlab.lib.validators import isNumber, isColor, isString, Validator
-from reportlab.lib.attrmap import *
-from reportlab.graphics.charts.areas import PlotArea
+from reportlab.lib.validators import isNumber, isNumberOrNone, isColor, isString, Validator
+from reportlab.lib.attrmap import AttrMap, AttrMapValue
+from reportlab.graphics.widgetbase import Widget
 from reportlab.lib.units import mm
-from reportlab.lib.utils import asNative
 try:
-    from itertools import zip_longest
-except:
-    from itertools import izip_longest as zip_longest
+    from reportlab.lib.utils import asUnicodeEx, isUnicode
+except ImportError:
+    # ReportLab 2.x compatibility
+    def asUnicodeEx(v, enc='utf8'):
+        if isinstance(v, unicode):
+            return v
+        if isinstance(v, str):
+            return v.decode(enc)
+        return str(v).decode(enc)
+
+    def isUnicode(v):
+        return isinstance(v, unicode)
+
+from reportlab.graphics.barcode import qrencoder
 
 class isLevel(Validator):
-    def test(self,x):
-        # level L : About 7% or less errors can be corrected.
-        # level M : About 15% or less errors can be corrected.
-        # level Q : About 25% or less errors can be corrected.
-        # level H : About 30% or less errors can be corrected.
-        return type(x) is str and len(x)==1 and x in ['L', 'M', 'Q', 'H']
+    def test(self, x):
+        return x in ['L', 'M', 'Q', 'H']
 isLevel = isLevel()
 
-class QrCodeWidget(PlotArea):
+class isUnicodeOrQRList(Validator):
+    def _test(self, x):
+        if isUnicode(x):
+            return True
+        if all(isinstance(v, qrencoder.QR) for v in x):
+            return True
+        return False
+
+    def test(self, x):
+        return self._test(x) or self.normalizeTest(x)
+
+    def normalize(self, x):
+        if self._test(x):
+            return x
+        try:
+            return asUnicodeEx(x)
+        except UnicodeError:
+            raise ValueError("Can't convert to unicode: %r" % x)
+isUnicodeOrQRList = isUnicodeOrQRList()
+
+class SRect(Rect):
+    def __init__(self, x, y, width, height, fillColor=colors.black):
+        Rect.__init__(self, x, y, width, height, fillColor=fillColor,
+                      strokeColor=None, strokeWidth=0)
+
+class QrCodeWidget(Widget):
     codeName = "QR"
-    _attrMap = AttrMap(BASE=PlotArea,
-        value = AttrMapValue(isString, desc='the text'),
+    _attrMap = AttrMap(
+        BASE = Widget,
+        value = AttrMapValue(isUnicodeOrQRList, desc='QRCode data'),
         x = AttrMapValue(isNumber, desc='x-coord'),
         y = AttrMapValue(isNumber, desc='y-coord'),
         barFillColor = AttrMapValue(isColor, desc='bar color'),
         barWidth = AttrMapValue(isNumber, desc='Width of bars.'), # maybe should be named just width?
         barHeight = AttrMapValue(isNumber, desc='Height of bars.'), # maybe should be named just height?
-        barStrokeWidth = AttrMapValue(isNumber, desc='Width of bar borders.'), # maybe removed?
-        barStrokeColor = AttrMapValue(isColor, desc='Color of bar borders.'), # maybe removed?
         barBorder = AttrMapValue(isNumber, desc='Width of QR border.'), # maybe should be named qrBorder?
         barLevel = AttrMapValue(isLevel, desc='QR Code level.'), # maybe should be named qrLevel
+        qrVersion = AttrMapValue(isNumberOrNone, desc='QR Code version. None for auto'),
+        # Below are ignored, they make no sense
+        barStrokeWidth = AttrMapValue(isNumber, desc='Width of bar borders.'),
+        barStrokeColor = AttrMapValue(isColor, desc='Color of bar borders.'),
         )
     x = 0
     y = 0
@@ -65,938 +99,111 @@
     barWidth = 32*mm
     barBorder = 4
     barLevel = 'L'
+    qrVersion = None
+    value = None
 
-    def __init__(self,value='Hello World',**kw):
-        value = str(value) if isinstance(value,int) else asNative(value)
-        self.value=value
+    def __init__(self, value='Hello World', **kw):
+        self.value = isUnicodeOrQRList.normalize(value)
         for k, v in kw.items():
             setattr(self, k, v)
 
-    def wrap(self,aW,aH):
-        return self.width,self.height
+        ec_level = getattr(qrencoder.QRErrorCorrectLevel, self.barLevel)
+
+        self.__dict__['qr'] = qrencoder.QRCode(self.qrVersion, ec_level)
+
+        if isUnicode(self.value):
+            self.addData(self.value)
+        elif self.value:
+            for v in self.value:
+                self.addData(v)
 
+    def addData(self, value):
+        self.qr.addData(value)
 
     def draw(self):
+        self.qr.make()
+
         g = Group()
-        gAdd = g.add
-        barWidth = self.barWidth
-        barHeight = self.barHeight
+
+        color = self.barFillColor
+        border = self.barBorder
+        width = self.barWidth
+        height = self.barHeight
         x = self.x
         y = self.y
-        gAdd(Rect(x,y,barWidth,barHeight,fillColor=None,strokeColor=None,strokeWidth=0))
 
-        barFillColor = self.barFillColor
-        barStrokeWidth = self.barStrokeWidth
-        barStrokeColor = self.barStrokeColor
-        barBorder = self.barBorder
-
-        correctLevel = {
-            'L': QRErrorCorrectLevel.L,
-            'M': QRErrorCorrectLevel.M,
-            'Q': QRErrorCorrectLevel.Q,
-            'H': QRErrorCorrectLevel.H,
-        }[self.barLevel]
-
-        qr = QRCode(None, correctLevel)
-
-        qr.addData(self.value)
-        qr.make()
-
-        moduleCount = qr.getModuleCount()
-        boxsize = min(barWidth, barHeight) / (moduleCount + barBorder * 2)
-        offsetX = (barWidth - min(barWidth, barHeight)) / 2
-        offsetY = (min(barWidth, barHeight) - barHeight) / 2
-
-        for r in xrange(moduleCount):
-            for c in xrange(moduleCount):
-                if (qr.isDark(r, c) ):
-                    x = (c + barBorder) * boxsize
-                    y = (r + barBorder+1) * boxsize
-                    qrect = Rect(offsetX+x,offsetY+barHeight-y,boxsize,boxsize,fillColor=barFillColor,strokeWidth=barStrokeWidth,strokeColor=barStrokeColor)
-                    gAdd(qrect)
+        g.add(SRect(x, y, width, height, fillColor=None))
+
+        moduleCount = self.qr.getModuleCount()
+        minwh = float(min(width, height))
+        boxsize = minwh / (moduleCount + border * 2.0)
+        offsetX = (width - minwh) / 2.0
+        offsetY = (minwh - height) / 2.0
+
+        for r, row in enumerate(self.qr.modules):
+            row = map(bool, row)
+            c = 0
+            for t, tt in itertools.groupby(row):
+                isDark = t
+                count = len(list(tt))
+                if isDark:
+                    x = (c + border) * boxsize
+                    y = (r + border + 1) * boxsize
+                    s = SRect(offsetX + x, offsetY + height - y, count * boxsize, boxsize)
+                    g.add(s)
+                c += count
 
         return g
 
-class QRMode:
-    MODE_NUMBER = 1 << 0
-    MODE_ALPHA_NUM = 1 << 1
-    MODE_8BIT_BYTE = 1 << 2
-    MODE_KANJI = 1 << 3
-
-class QR:
-    def __init__(self, data):
-        if self.valid:
-            if not re.search('^[%s]+$' % self.valid, data):
-                raise ValueError
-        else:
-            self.valid = ''.join(chr(c) for c in xrange(256))
-        self.data = data
-
-    def getLength(self):
-        return len(self.data)
-
-    def __repr__(self):
-        return self.data
-
-    def write(self, buffer):
-        for g in zip_longest(*[iter(self.data)] * self.group):
-            bits = 0
-            n = 0
-            for i in xrange(self.group):
-                if g[i] is not None:
-                    n *= len(self.valid)
-                    n += self.valid.index(g[i])
-                    bits += self.bits[i]
-            buffer.put(n, bits)
-
-class QRNumber(QR):
-    valid = '0123456789'
-    bits = (4,3,3)
-    group = 3
-    mode = QRMode.MODE_NUMBER
-
-class QRAlphaNum(QR):
-    valid = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'
-    bits = (6,5)
-    group = 2
-    mode = QRMode.MODE_ALPHA_NUM
-
-class QR8bitByte(QR):
-    valid = None #''.join(chr(c) for c in xrange(256))
-    bits = (8,)
-    group = 1
-    mode = QRMode.MODE_8BIT_BYTE
-
-    def write(self, buffer):
-        for c in self.data:
-            buffer.put(ord(c), 8)
-
-class QRKanji(QR):
-    valid = None
-    bits = (8,)
-    group = 1
-    mode = QRMode.MODE_KANJI
-
-class QRCode:
-    def __init__(self, typeNumber, errorCorrectLevel):
-        self.typeNumber = typeNumber
-        self.errorCorrectLevel = errorCorrectLevel
-        self.modules = None
-        self.moduleCount = 0
-        self.dataCache = None
-        self.dataList = []
-
-    def addData(self, data):
-        try :
-            newData = QRNumber(data)
-        except ValueError:
-            try:
-                newData = QRAlphaNum(data)
-            except ValueError:
-                try:
-                    newData = QR8bitByte(data)
-                except ValueError:
-                    try:
-                        newData = QRKanji(data)
-                    except:
-                        raise
-        self.dataList.append(newData)
-        self.dataCache = None
-
-    def isDark(self, row, col):
-        if (row < 0 or self.moduleCount <= row or col < 0 or self.moduleCount <= col):
-            raise Exception("%s,%s - %s" % (row, col, self.moduleCount))
-        return self.modules[row][col]
-
-    def getModuleCount(self):
-        return self.moduleCount
-
-    def make(self):
-        if self.typeNumber is None:
-            # Calculate typeNumber for data to fit the QR Code capacity
-            errorCorrectLevel = self.errorCorrectLevel
-            for typeNumber in xrange(1, 40):
-                rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel)
-                totalDataCount = 0;
-                for i in xrange(len(rsBlocks)):
-                    totalDataCount += rsBlocks[i].dataCount
-                length = 0
-                for i in xrange(len(self.dataList)):
-                    data = self.dataList[i]
-                    length += 4
-                    length += QRUtil.getLengthInBits(data.mode, typeNumber)
-                    length += len(data.data) * 8
-                if length <= totalDataCount * 8:
-                    break
-            self.typeNumber = typeNumber
-        self.makeImpl(False, self.getBestMaskPattern())
-
-    def makeImpl(self, test, maskPattern):
-        self.moduleCount = self.typeNumber * 4 + 17
-        self.modules = [None for x in xrange(self.moduleCount)]
-        for row in xrange(self.moduleCount):
-            self.modules[row] = [None for x in xrange(self.moduleCount)]
-            for col in xrange(self.moduleCount):
-                self.modules[row][col] = None #(col + row) % 3;
-        self.setupPositionProbePattern(0, 0)
-        self.setupPositionProbePattern(self.moduleCount - 7, 0)
-        self.setupPositionProbePattern(0, self.moduleCount - 7)
-        self.setupPositionAdjustPattern()
-        self.setupTimingPattern()
-        self.setupTypeInfo(test, maskPattern)
-        if (self.typeNumber >= 7):
-            self.setupTypeNumber(test)
-        if (self.dataCache == None):
-            self.dataCache = QRCode.createData(self.typeNumber, self.errorCorrectLevel, self.dataList)
-        self.mapData(self.dataCache, maskPattern)
-
-    def setupPositionProbePattern(self, row, col):
-        for r in xrange(-1, 8):
-            if (row + r <= -1 or self.moduleCount <= row + r): continue
-            for c in xrange(-1, 8):
-                if (col + c <= -1 or self.moduleCount <= col + c): continue
-                if ( (0 <= r and r <= 6 and (c == 0 or c == 6) )
-                        or (0 <= c and c <= 6 and (r == 0 or r == 6) )
-                        or (2 <= r and r <= 4 and 2 <= c and c <= 4) ):
-                    self.modules[row + r][col + c] = True;
-                else:
-                    self.modules[row + r][col + c] = False;
-
-    def getBestMaskPattern(self):
-        minLostPoint = 0
-        pattern = 0
-        for i in xrange(8):
-            self.makeImpl(True, i);
-            lostPoint = QRUtil.getLostPoint(self);
-            if (i == 0 or minLostPoint > lostPoint):
-                minLostPoint = lostPoint
-                pattern = i
-        return pattern
-
-    def setupTimingPattern(self):
-        for r in xrange(8, self.moduleCount - 8):
-            if (self.modules[r][6] != None):
-                continue
-            self.modules[r][6] = (r % 2 == 0)
-        for c in xrange(8, self.moduleCount - 8):
-            if (self.modules[6][c] != None):
-                continue
-            self.modules[6][c] = (c % 2 == 0)
-
-    def setupPositionAdjustPattern(self):
-        pos = QRUtil.getPatternPosition(self.typeNumber)
-        for i in xrange(len(pos)):
-            for j in xrange(len(pos)):
-                row = pos[i]
-                col = pos[j]
-                if (self.modules[row][col] != None):
-                    continue
-                for r in xrange(-2, 3):
-                    for c in xrange(-2, 3):
-                        if (r == -2 or r == 2 or c == -2 or c == 2 or (r == 0 and c == 0) ):
-                            self.modules[row + r][col + c] = True
-                        else:
-                            self.modules[row + r][col + c] = False
-
-    def setupTypeNumber(self, test):
-        bits = QRUtil.getBCHTypeNumber(self.typeNumber)
-        for i in xrange(18):
-            mod = (not test and ( (bits >> i) & 1) == 1)
-            self.modules[i // 3][i % 3 + self.moduleCount - 8 - 3] = mod;
-        for i in xrange(18):
-            mod = (not test and ( (bits >> i) & 1) == 1)
-            self.modules[i % 3 + self.moduleCount - 8 - 3][i // 3] = mod;
-
-    def setupTypeInfo(self, test, maskPattern):
-        data = (self.errorCorrectLevel << 3) | maskPattern
-        bits = QRUtil.getBCHTypeInfo(data)
-        # vertical
-        for i in xrange(15):
-            mod = (not test and ( (bits >> i) & 1) == 1)
-            if (i < 6):
-                self.modules[i][8] = mod
-            elif (i < 8):
-                self.modules[i + 1][8] = mod
-            else:
-                self.modules[self.moduleCount - 15 + i][8] = mod
-        # horizontal
-        for i in xrange(15):
-            mod = (not test and ( (bits >> i) & 1) == 1);
-            if (i < 8):
-                self.modules[8][self.moduleCount - i - 1] = mod
-            elif (i < 9):
-                self.modules[8][15 - i - 1 + 1] = mod
-            else:
-                self.modules[8][15 - i - 1] = mod
-        # fixed module
-        self.modules[self.moduleCount - 8][8] = (not test)
-
-    def mapData(self, data, maskPattern):
-        inc = -1
-        row = self.moduleCount - 1
-        bitIndex = 7
-        byteIndex = 0
-        for col in xrange(self.moduleCount - 1, 0, -2):
-            if (col == 6): col-=1
-            while (True):
-                for c in xrange(2):
-                    if (self.modules[row][col - c] == None):
-                        dark = False
-                        if (byteIndex < len(data)):
-                            dark = ( ( (data[byteIndex] >> bitIndex) & 1) == 1)
-                        mask = QRUtil.getMask(maskPattern, row, col - c)
-                        if (mask):
-                            dark = not dark
-                        self.modules[row][col - c] = dark
-                        bitIndex-=1
-                        if (bitIndex == -1):
-                            byteIndex+=1
-                            bitIndex = 7
-                row += inc
-                if (row < 0 or self.moduleCount <= row):
-                    row -= inc
-                    inc = -inc
-                    break
-    PAD0 = 0xEC
-    PAD1 = 0x11
-
-    @staticmethod
-    def createData(typeNumber, errorCorrectLevel, dataList):
-        rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel)
-        buffer = QRBitBuffer();
-        for i in xrange(len(dataList)):
-            data = dataList[i]
-            buffer.put(data.mode, 4)
-            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber) )
-            data.write(buffer)
-        # calc num max data.
-        totalDataCount = 0;
-        for i in xrange(len(rsBlocks)):
-            totalDataCount += rsBlocks[i].dataCount
-        if (buffer.getLengthInBits() > totalDataCount * 8):
-            raise Exception("code length overflow. (%d > %d)" % (buffer.getLengthInBits(), totalDataCount * 8))
-        # end code
-        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8):
-            buffer.put(0, 4)
-        # padding
-        while (buffer.getLengthInBits() % 8 != 0):
-            buffer.putBit(False)
-        # padding
-        while (True):
-            if (buffer.getLengthInBits() >= totalDataCount * 8):
-                break
-            buffer.put(QRCode.PAD0, 8)
-            if (buffer.getLengthInBits() >= totalDataCount * 8):
-                break
-            buffer.put(QRCode.PAD1, 8)
-        return QRCode.createBytes(buffer, rsBlocks)
-
-    @staticmethod
-    def createBytes(buffer, rsBlocks):
-        offset = 0
-        maxDcCount = 0
-        maxEcCount = 0
-        dcdata = [0 for x in xrange(len(rsBlocks))]
-        ecdata = [0 for x in xrange(len(rsBlocks))]
-        for r in xrange(len(rsBlocks)):
-            dcCount = rsBlocks[r].dataCount
-            ecCount = rsBlocks[r].totalCount - dcCount
-            maxDcCount = max(maxDcCount, dcCount)
-            maxEcCount = max(maxEcCount, ecCount)
-            dcdata[r] = [0 for x in xrange(dcCount)]
-            for i in xrange(len(dcdata[r])):
-                dcdata[r][i] = 0xff & buffer.buffer[i + offset]
-            offset += dcCount
-            rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount)
-            rawPoly = QRPolynomial(dcdata[r], rsPoly.getLength() - 1)
-            modPoly = rawPoly.mod(rsPoly)
-            ecdata[r] = [0 for x in xrange(rsPoly.getLength()-1)]
-            for i in xrange(len(ecdata[r])):
-                modIndex = i + modPoly.getLength() - len(ecdata[r])
-                if (modIndex >= 0):
-                    ecdata[r][i] = modPoly.get(modIndex)
-                else:
-                    ecdata[r][i] = 0
-        totalCodeCount = 0
-        for i in xrange(len(rsBlocks)):
-            totalCodeCount += rsBlocks[i].totalCount
-        data = [None for x in xrange(totalCodeCount)]
-        index = 0
-        for i in xrange(maxDcCount):
-            for r in xrange(len(rsBlocks)):
-                if (i < len(dcdata[r])):
-                    data[index] = dcdata[r][i]
-                    index+=1
-        for i in xrange(maxEcCount):
-            for r in xrange(len(rsBlocks)):
-                if (i < len(ecdata[r])):
-                    data[index] = ecdata[r][i]
-                    index+=1
-        return data
-
-
-class QRErrorCorrectLevel:
-    L = 1
-    M = 0
-    Q = 3
-    H = 2
-
-class QRMaskPattern:
-    PATTERN000 = 0
-    PATTERN001 = 1
-    PATTERN010 = 2
-    PATTERN011 = 3
-    PATTERN100 = 4
-    PATTERN101 = 5
-    PATTERN110 = 6
-    PATTERN111 = 7
-
-class QRUtil(object):
-    PATTERN_POSITION_TABLE = [
-        [],
-        [6, 18],
-        [6, 22],
-        [6, 26],
-        [6, 30],
-        [6, 34],
-        [6, 22, 38],
-        [6, 24, 42],
-        [6, 26, 46],
-        [6, 28, 50],
-        [6, 30, 54],
-        [6, 32, 58],
-        [6, 34, 62],
-        [6, 26, 46, 66],
-        [6, 26, 48, 70],
-        [6, 26, 50, 74],
-        [6, 30, 54, 78],
-        [6, 30, 56, 82],
-        [6, 30, 58, 86],
-        [6, 34, 62, 90],
-        [6, 28, 50, 72, 94],
-        [6, 26, 50, 74, 98],
-        [6, 30, 54, 78, 102],
-        [6, 28, 54, 80, 106],
-        [6, 32, 58, 84, 110],
-        [6, 30, 58, 86, 114],
-        [6, 34, 62, 90, 118],
-        [6, 26, 50, 74, 98, 122],
-        [6, 30, 54, 78, 102, 126],
-        [6, 26, 52, 78, 104, 130],
-        [6, 30, 56, 82, 108, 134],
-        [6, 34, 60, 86, 112, 138],
-        [6, 30, 58, 86, 114, 142],
-        [6, 34, 62, 90, 118, 146],
-        [6, 30, 54, 78, 102, 126, 150],
-        [6, 24, 50, 76, 102, 128, 154],
-        [6, 28, 54, 80, 106, 132, 158],
-        [6, 32, 58, 84, 110, 136, 162],
-        [6, 26, 54, 82, 110, 138, 166],
-        [6, 30, 58, 86, 114, 142, 170]
-    ]
-
-    G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
-    G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)
-    G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
-
-    @staticmethod
-    def getBCHTypeInfo(data):
-        d = data << 10;
-        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0):
-            d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) )
-        return ( (data << 10) | d) ^ QRUtil.G15_MASK
-
-    @staticmethod
-    def getBCHTypeNumber(data):
-        d = data << 12;
-        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0):
-            d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) )
-        return (data << 12) | d
-
-    @staticmethod
-    def getBCHDigit(data):
-        digit = 0;
-        while (data != 0):
-            digit += 1
-            data >>= 1
-        return digit
-
-    @staticmethod
-    def getPatternPosition(typeNumber):
-        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1]
-
-    @staticmethod
-    def getMask(maskPattern, i, j):
-        if maskPattern == QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0
-        if maskPattern == QRMaskPattern.PATTERN001 : return i % 2 == 0
-        if maskPattern == QRMaskPattern.PATTERN010 : return j % 3 == 0
-        if maskPattern == QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0
-        if maskPattern == QRMaskPattern.PATTERN100 : return (math.floor(i / 2) + math.floor(j / 3) ) % 2 == 0
-        if maskPattern == QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0
-        if maskPattern == QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0
-        if maskPattern == QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0
-        raise Exception("bad maskPattern:" + maskPattern)
-
-    @staticmethod
-    def getErrorCorrectPolynomial(errorCorrectLength):
-        a = QRPolynomial([1], 0);
-        for i in xrange(errorCorrectLength):
-            a = a.multiply(QRPolynomial([1, QRMath.gexp(i)], 0) )
-        return a
-
-    @staticmethod
-    def getLengthInBits(mode, type):
-        if 1 <= type and type < 10:
-            # 1 - 9
-            if mode == QRMode.MODE_NUMBER     : return 10
-            if mode == QRMode.MODE_ALPHA_NUM     : return 9
-            if mode == QRMode.MODE_8BIT_BYTE    : return 8
-            if mode == QRMode.MODE_KANJI      : return 8
-            raise Exception("mode:" + mode)
-        elif (type < 27):
-            # 10 - 26
-            if mode == QRMode.MODE_NUMBER     : return 12
-            if mode == QRMode.MODE_ALPHA_NUM     : return 11
-            if mode == QRMode.MODE_8BIT_BYTE    : return 16
-            if mode == QRMode.MODE_KANJI      : return 10
-            raise Exception("mode:" + mode)
-        elif (type < 41):
-            # 27 - 40
-            if mode == QRMode.MODE_NUMBER     : return 14
-            if mode == QRMode.MODE_ALPHA_NUM    : return 13
-            if mode == QRMode.MODE_8BIT_BYTE    : return 16
-            if mode == QRMode.MODE_KANJI      : return 12
-            raise Exception("mode:" + mode)
-        else:
-            raise Exception("type:" + type)
-
-    @staticmethod
-    def getLostPoint(qrCode):
-        moduleCount = qrCode.getModuleCount();
-        lostPoint = 0;
-        # LEVEL1
-        for row in xrange(moduleCount):
-            for col in xrange(moduleCount):
-                sameCount = 0;
-                dark = qrCode.isDark(row, col);
-                for r in xrange(-1, 2):
-                    if (row + r < 0 or moduleCount <= row + r):
-                        continue
-                    for c in xrange(-1, 2):
-                        if (col + c < 0 or moduleCount <= col + c):
-                            continue
-                        if (r == 0 and c == 0):
-                            continue
-                        if (dark == qrCode.isDark(row + r, col + c) ):
-                            sameCount+=1
-                if (sameCount > 5):
-                    lostPoint += (3 + sameCount - 5)
-        # LEVEL2
-        for row in xrange(moduleCount - 1):
-            for col in xrange(moduleCount - 1):
-                count = 0;
-                if (qrCode.isDark(row,     col    ) ): count+=1
-                if (qrCode.isDark(row + 1, col    ) ): count+=1
-                if (qrCode.isDark(row,     col + 1) ): count+=1
-                if (qrCode.isDark(row + 1, col + 1) ): count+=1
-                if (count == 0 or count == 4):
-                    lostPoint += 3
-        # LEVEL3
-        for row in xrange(moduleCount):
-            for col in xrange(moduleCount - 6):
-                if (qrCode.isDark(row, col)
-                        and not qrCode.isDark(row, col + 1)
-                        and  qrCode.isDark(row, col + 2)
-                        and  qrCode.isDark(row, col + 3)
-                        and  qrCode.isDark(row, col + 4)
-                        and not qrCode.isDark(row, col + 5)
-                        and  qrCode.isDark(row, col + 6) ):
-                    lostPoint += 40
-        for col in xrange(moduleCount):
-            for row in xrange(moduleCount - 6):
-                if (qrCode.isDark(row, col)
-                        and not qrCode.isDark(row + 1, col)
-                        and  qrCode.isDark(row + 2, col)
-                        and  qrCode.isDark(row + 3, col)
-                        and  qrCode.isDark(row + 4, col)
-                        and not qrCode.isDark(row + 5, col)
-                        and  qrCode.isDark(row + 6, col) ):
-                    lostPoint += 40
-        # LEVEL4
-        darkCount = 0;
-        for col in xrange(moduleCount):
-            for row in xrange(moduleCount):
-                if (qrCode.isDark(row, col) ):
-                    darkCount+=1
-        ratio = abs(100 * darkCount / moduleCount / moduleCount - 50) / 5
-        lostPoint += ratio * 10
-        return lostPoint
-
-class QRMath:
-    @staticmethod
-    def glog(n):
-        if (n < 1):
-            raise Exception("glog(" + n + ")")
-        return LOG_TABLE[n];
-
-    @staticmethod
-    def gexp(n):
-        while n < 0:
-            n += 255
-        while n >= 256:
-            n -= 255
-        return EXP_TABLE[n];
-
-EXP_TABLE = [x for x in xrange(256)]
-LOG_TABLE = [x for x in xrange(256)]
-for i in xrange(8):
-    EXP_TABLE[i] = 1 << i;
-for i in xrange(8, 256):
-    EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8]
-for i in xrange(255):
-    LOG_TABLE[EXP_TABLE[i] ] = i
-
-class QRPolynomial:
-    def __init__(self, num, shift):
-        if (len(num) == 0):
-            raise Exception(num.length + "/" + shift)
-        offset = 0
-        while offset < len(num) and num[offset] == 0:
-            offset += 1
-        self.num = [0 for x in xrange(len(num)-offset+shift)]
-        for i in xrange(len(num) - offset):
-            self.num[i] = num[i + offset]
-
-    def get(self, index):
-        return self.num[index]
-
-    def getLength(self):
-        return len(self.num)
-
-    def multiply(self, e):
-        num = [0 for x in xrange(self.getLength() + e.getLength() - 1)];
-        for i in xrange(self.getLength()):
-            for j in xrange(e.getLength()):
-                num[i + j] ^= QRMath.gexp(QRMath.glog(self.get(i) ) + QRMath.glog(e.get(j) ) )
-        return QRPolynomial(num, 0);
-
-    def mod(self, e):
-        if (self.getLength() - e.getLength() < 0):
-            return self;
-        ratio = QRMath.glog(self.get(0) ) - QRMath.glog(e.get(0) )
-        num = [0 for x in xrange(self.getLength())]
-        for i in xrange(self.getLength()):
-            num[i] = self.get(i);
-        for i in xrange(e.getLength()):
-            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i) ) + ratio)
-        # recursive call
-        return QRPolynomial(num, 0).mod(e);
-
-class QRRSBlock:
-    RS_BLOCK_TABLE = [
-        # L
-        # M
-        # Q
-        # H
-
-        # 1
-        [1, 26, 19],
-        [1, 26, 16],
-        [1, 26, 13],
-        [1, 26, 9],
-
-        # 2
-        [1, 44, 34],
-        [1, 44, 28],
-        [1, 44, 22],
-        [1, 44, 16],
-
-        # 3
-        [1, 70, 55],
-        [1, 70, 44],
-        [2, 35, 17],
-        [2, 35, 13],
-
-        # 4
-        [1, 100, 80],
-        [2, 50, 32],
-        [2, 50, 24],
-        [4, 25, 9],
-
-        # 5
-        [1, 134, 108],
-        [2, 67, 43],
-        [2, 33, 15, 2, 34, 16],
-        [2, 33, 11, 2, 34, 12],
-
-        # 6
-        [2, 86, 68],
-        [4, 43, 27],
-        [4, 43, 19],
-        [4, 43, 15],
-
-        # 7
-        [2, 98, 78],
-        [4, 49, 31],
-        [2, 32, 14, 4, 33, 15],
-        [4, 39, 13, 1, 40, 14],
-
-        # 8
-        [2, 121, 97],
-        [2, 60, 38, 2, 61, 39],
-        [4, 40, 18, 2, 41, 19],
-        [4, 40, 14, 2, 41, 15],
-
-        # 9
-        [2, 146, 116],
-        [3, 58, 36, 2, 59, 37],
-        [4, 36, 16, 4, 37, 17],
-        [4, 36, 12, 4, 37, 13],
-
-        # 10
-        [2, 86, 68, 2, 87, 69],
-        [4, 69, 43, 1, 70, 44],
-        [6, 43, 19, 2, 44, 20],
-        [6, 43, 15, 2, 44, 16],
-
-        # 11
-        [4, 101, 81],
-        [1, 80, 50, 4, 81, 51],
-        [4, 50, 22, 4, 51, 23],
-        [3, 36, 12, 8, 37, 13],
-
-        # 12
-        [2, 116, 92, 2, 117, 93],
-        [6, 58, 36, 2, 59, 37],
-        [4, 46, 20, 6, 47, 21],
-        [7, 42, 14, 4, 43, 15],
-
-        # 13
-        [4, 133, 107],
-        [8, 59, 37, 1, 60, 38],
-        [8, 44, 20, 4, 45, 21],
-        [12, 33, 11, 4, 34, 12],
-
-        # 14
-        [3, 145, 115, 1, 146, 116],
-        [4, 64, 40, 5, 65, 41],
-        [11, 36, 16, 5, 37, 17],
-        [11, 36, 12, 5, 37, 13],
-
-        # 15
-        [5, 109, 87, 1, 110, 88],
-        [5, 65, 41, 5, 66, 42],
-        [5, 54, 24, 7, 55, 25],
-        [11, 36, 12],
-
-        # 16
-        [5, 122, 98, 1, 123, 99],
-        [7, 73, 45, 3, 74, 46],
-        [15, 43, 19, 2, 44, 20],
-        [3, 45, 15, 13, 46, 16],
-
-        # 17
-        [1, 135, 107, 5, 136, 108],
-        [10, 74, 46, 1, 75, 47],
-        [1, 50, 22, 15, 51, 23],
-        [2, 42, 14, 17, 43, 15],
-
-        # 18
-        [5, 150, 120, 1, 151, 121],
-        [9, 69, 43, 4, 70, 44],
-        [17, 50, 22, 1, 51, 23],
-        [2, 42, 14, 19, 43, 15],
-
-        # 19
-        [3, 141, 113, 4, 142, 114],
-        [3, 70, 44, 11, 71, 45],
-        [17, 47, 21, 4, 48, 22],
-        [9, 39, 13, 16, 40, 14],
-
-        # 20
-        [3, 135, 107, 5, 136, 108],
-        [3, 67, 41, 13, 68, 42],
-        [15, 54, 24, 5, 55, 25],
-        [15, 43, 15, 10, 44, 16],
-
-        # 21
-        [4, 144, 116, 4, 145, 117],
-        [17, 68, 42],
-        [17, 50, 22, 6, 51, 23],
-        [19, 46, 16, 6, 47, 17],
-
-        # 22
-        [2, 139, 111, 7, 140, 112],
-        [17, 74, 46],
-        [7, 54, 24, 16, 55, 25],
-        [34, 37, 13],
-
-        # 23
-        [4, 151, 121, 5, 152, 122],
-        [4, 75, 47, 14, 76, 48],
-        [11, 54, 24, 14, 55, 25],
-        [16, 45, 15, 14, 46, 16],
-
-        # 24
-        [6, 147, 117, 4, 148, 118],
-        [6, 73, 45, 14, 74, 46],
-        [11, 54, 24, 16, 55, 25],
-        [30, 46, 16, 2, 47, 17],
-
-        # 25
-        [8, 132, 106, 4, 133, 107],
-        [8, 75, 47, 13, 76, 48],
-        [7, 54, 24, 22, 55, 25],
-        [22, 45, 15, 13, 46, 16],
-
-        # 26
-        [10, 142, 114, 2, 143, 115],
-        [19, 74, 46, 4, 75, 47],
-        [28, 50, 22, 6, 51, 23],
-        [33, 46, 16, 4, 47, 17],
-
-        # 27
-        [8, 152, 122, 4, 153, 123],
-        [22, 73, 45, 3, 74, 46],
-        [8, 53, 23, 26, 54, 24],
-        [12, 45, 15, 28, 46, 16],
-
-        # 28
-        [3, 147, 117, 10, 148, 118],
-        [3, 73, 45, 23, 74, 46],
-        [4, 54, 24, 31, 55, 25],
-        [11, 45, 15, 31, 46, 16],
-
-        # 29
-        [7, 146, 116, 7, 147, 117],
-        [21, 73, 45, 7, 74, 46],
-        [1, 53, 23, 37, 54, 24],
-        [19, 45, 15, 26, 46, 16],
-
-        # 30
-        [5, 145, 115, 10, 146, 116],
-        [19, 75, 47, 10, 76, 48],
-        [15, 54, 24, 25, 55, 25],
-        [23, 45, 15, 25, 46, 16],
-
-        # 31
-        [13, 145, 115, 3, 146, 116],
-        [2, 74, 46, 29, 75, 47],
-        [42, 54, 24, 1, 55, 25],
-        [23, 45, 15, 28, 46, 16],
-
-        # 32
-        [17, 145, 115],
-        [10, 74, 46, 23, 75, 47],
-        [10, 54, 24, 35, 55, 25],
-        [19, 45, 15, 35, 46, 16],
-
-        # 33
-        [17, 145, 115, 1, 146, 116],
-        [14, 74, 46, 21, 75, 47],
-        [29, 54, 24, 19, 55, 25],
-        [11, 45, 15, 46, 46, 16],
-
-        # 34
-        [13, 145, 115, 6, 146, 116],
-        [14, 74, 46, 23, 75, 47],
-        [44, 54, 24, 7, 55, 25],
-        [59, 46, 16, 1, 47, 17],
-
-        # 35
-        [12, 151, 121, 7, 152, 122],
-        [12, 75, 47, 26, 76, 48],
-        [39, 54, 24, 14, 55, 25],
-        [22, 45, 15, 41, 46, 16],
-
-        # 36
-        [6, 151, 121, 14, 152, 122],
-        [6, 75, 47, 34, 76, 48],
-        [46, 54, 24, 10, 55, 25],
-        [2, 45, 15, 64, 46, 16],
-
-        # 37
-        [17, 152, 122, 4, 153, 123],
-        [29, 74, 46, 14, 75, 47],
-        [49, 54, 24, 10, 55, 25],
-        [24, 45, 15, 46, 46, 16],
-
-        # 38
-        [4, 152, 122, 18, 153, 123],
-        [13, 74, 46, 32, 75, 47],
-        [48, 54, 24, 14, 55, 25],
-        [42, 45, 15, 32, 46, 16],
-
-        # 39
-        [20, 147, 117, 4, 148, 118],
-        [40, 75, 47, 7, 76, 48],
-        [43, 54, 24, 22, 55, 25],
-        [10, 45, 15, 67, 46, 16],
-
-        # 40
-        [19, 148, 118, 6, 149, 119],
-        [18, 75, 47, 31, 76, 48],
-        [34, 54, 24, 34, 55, 25],
-        [20, 45, 15, 61, 46, 16]
-
-    ]
-
-    def __init__(self, totalCount, dataCount):
-        self.totalCount = totalCount
-        self.dataCount = dataCount
-
-    @staticmethod
-    def getRSBlocks(typeNumber, errorCorrectLevel):
-        rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
-        if rsBlock == None:
-            raise Exception("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel)
-        length = len(rsBlock) // 3
-        list = []
-        for i in xrange(length):
-            count = rsBlock[i * 3 + 0]
-            totalCount = rsBlock[i * 3 + 1]
-            dataCount  = rsBlock[i * 3 + 2]
-            for j in xrange(count):
-                list.append(QRRSBlock(totalCount, dataCount))
-        return list;
-
-    @staticmethod
-    def getRsBlockTable(typeNumber, errorCorrectLevel):
-        if errorCorrectLevel == QRErrorCorrectLevel.L:
-            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
-        elif errorCorrectLevel == QRErrorCorrectLevel.M:
-            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
-        elif errorCorrectLevel ==  QRErrorCorrectLevel.Q:
-            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
-        elif errorCorrectLevel ==  QRErrorCorrectLevel.H:
-            return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
-        else:
-            return None;
-
-class QRBitBuffer:
-    def __init__(self):
-        self.buffer = []
-        self.length = 0
-
-    def __repr__(self):
-        return ".".join([str(n) for n in self.buffer])
-
-    def get(self, index):
-        bufIndex = math.floor(index / 8)
-        val = ( (self.buffer[bufIndex] >> (7 - index % 8) ) & 1) == 1
-        return ( (self.buffer[bufIndex] >> (7 - index % 8) ) & 1) == 1
-
-    def put(self, num, length):
-        for i in xrange(length):
-            self.putBit( ( (num >> (length - i - 1) ) & 1) == 1)
-
-    def getLengthInBits(self):
-        return self.length
-
-    def putBit(self, bit):
-        bufIndex = self.length // 8
-        if len(self.buffer) <= bufIndex:
-            self.buffer.append(0)
-        if bit:
-            self.buffer[bufIndex] |= (0x80 >> (self.length % 8) )
-        self.length += 1
+
+# Flowable version
+
+class QrCode(Flowable):
+    height = 32*mm
+    width = 32*mm
+    qrBorder = 4
+    qrLevel = 'L'
+    qrVersion = None
+    value = None
+
+    def __init__(self, value=None, **kw):
+        self.value = isUnicodeOrQRList.normalize(value)
+
+        for k, v in kw.items():
+            setattr(self, k, v)
+
+        ec_level = getattr(qrencoder.QRErrorCorrectLevel, self.qrLevel)
+
+        self.qr = qrencoder.QRCode(self.qrVersion, ec_level)
+
+        if isUnicode(self.value):
+            self.addData(self.value)
+        elif self.value:
+            for v in self.value:
+                self.addData(v)
+
+    def addData(self, value):
+        self.qr.addData(value)
+
+    def draw(self):
+        self.qr.make()
+
+        moduleCount = self.qr.getModuleCount()
+        border = self.qrBorder
+        xsize = self.width / (moduleCount + border * 2.0)
+        ysize = self.height / (moduleCount + border * 2.0)
+
+        for r, row in enumerate(self.qr.modules):
+            row = map(bool, row)
+            c = 0
+            for t, tt in itertools.groupby(row):
+                isDark = t
+                count = len(list(tt))
+                if isDark:
+                    x = (c + border) * xsize
+                    y = self.height - (r + border + 1) * ysize
+                    self.rect(x, y, count * xsize, ysize * 1.05)
+                c += count
+
+    def rect(self, x, y, w, h):
+        self.canv.rect(x, y, w, h, stroke=0, fill=1)
diff -uNr reportlab-3.1.8/src/reportlab/graphics/barcode/qrencoder.py reportlab-3.1.41/src/reportlab/graphics/barcode/qrencoder.py
--- reportlab-3.1.8/src/reportlab/graphics/barcode/qrencoder.py	1970-01-01 09:00:00.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/barcode/qrencoder.py	2014-08-12 20:28:18.717110785 +0900
@@ -0,0 +1,1130 @@
+# QRCode for Python
+#
+# Support for Kanji, Hanzi, ECI, FNC1 and Structurded append,
+# and optimizations by Anders Hammarquist <iko@openend.se>
+#
+# Copyright (c) 2014 Open End AB http://www.openend.se/
+#
+# Ported from the Javascript library by Sam Curren
+#
+# QRCode for Javascript
+# http://d-project.googlecode.com/svn/trunk/misc/qrcode/js/qrcode.js
+#
+# Copyright (c) 2009 Kazuhiko Arase
+#
+# URL: http://www.d-project.com/
+#
+# Licensed under the MIT license:
+#   http://www.opensource.org/licenses/mit-license.php
+#
+# The word "QR Code" is registered trademark of
+# DENSO WAVE INCORPORATED
+#   http://www.denso-wave.com/qrcode/faqpatent-e.html
+
+import re
+import itertools
+try:
+    from itertools import zip_longest
+except:
+    from itertools import izip_longest as zip_longest
+
+try:
+    unicode
+except NameError:
+    # No unicode in Python 3
+    unicode = str
+
+class QR:
+    valid = None
+    bits = None
+    group = 0
+
+    def __init__(self, data):
+        if self.valid and not self.valid(data):
+            raise ValueError
+        self.data = data
+
+    def __len__(self):
+        return len(self.data)
+
+    @property
+    def bitlength(self):
+        if self.bits is None:
+            return 0
+        q, r = divmod(len(self), len(self.bits))
+        return q * sum(self.bits) + sum(self.bits[:r])
+
+    def getLengthBits(self, ver):
+        if 0 < ver < 10:
+            return self.lengthbits[0]
+        elif ver < 27:
+            return self.lengthbits[1]
+        elif ver < 41:
+            return self.lengthbits[2]
+        raise ValueError("Unknown version: " + ver)
+
+    def getLength(self):
+        return len(self.data)
+
+    def __repr__(self):
+        return repr(self.data)
+
+    def write_header(self, buffer, version):
+        buffer.put(self.mode, 4)
+        lenbits = self.getLengthBits(version)
+        if lenbits:
+            buffer.put(len(self.data), lenbits )
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        for g in zip_longest(*[iter(self.data)] * self.group):
+            bits = 0
+            n = 0
+            for i in range(self.group):
+                if g[i] is not None:
+                    n *= len(self.chars)
+                    n += self.chars.index(g[i])
+                    bits += self.bits[i]
+            buffer.put(n, bits)
+
+class QRNumber(QR):
+    valid = re.compile(u'[0-9]*$').match
+    chars = u'0123456789'
+    bits = (4,3,3)
+    group = 3
+    mode = 0x1
+    lengthbits = (10, 12, 14)
+
+class QRAlphaNum(QR):
+    valid = re.compile(u'[-0-9A-Z $%*+-./:]*$').match
+    chars = u'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'
+    bits = (6,5)
+    group = 2
+    mode = 0x2
+    lengthbits = (9, 11, 13)
+
+class QR8bitByte(QR):
+    bits = (8,)
+    group = 1
+    mode = 0x4
+    lengthbits = (8, 16, 16)
+
+    def __init__(self, data):
+        if isinstance(data, unicode):
+            self.data = data.encode('utf-8')  # XXX This really needs an ECI too
+        else:
+            self.data = data  # It'd better be byte data
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        for c in self.data:
+            if isinstance(c, str):
+                c = ord(c)
+            buffer.put(c, 8)
+
+class QRKanji(QR):
+    bits = (13,)
+    group = 1
+    mode = 0x8
+    lengthbits = (8, 10, 12)
+
+    def __init__(self, data):
+        try:
+            self.data = self.unicode_to_qrkanji(data)
+        except UnicodeEncodeError:
+            raise ValueError('Not valid kanji')
+
+    def unicode_to_qrkanji(self, data):
+        codes = []
+        for i,c in enumerate(data):
+            try:
+                c = c.encode('shift-jis')
+                try:
+                    c,d = map(ord, c)
+                except TypeError:
+                    # Python 3
+                    c,d = c
+            except UnicodeEncodeError as e:
+                raise UnicodeEncodeError('qrkanji', data, i, i+1, e.args[4])
+            except ValueError:
+                raise UnicodeEncodeError('qrkanji', data, i, i+1,
+                                         'illegal multibyte sequence')
+            c = c << 8 | d
+            if 0x8140 <= c <=0x9ffc:
+                c -= 0x8140
+                c = (((c & 0xff00) >> 8) * 0xc0) + (c & 0xff)
+            elif 0xe040 <= c <= 0xebbf:
+                c -= 0xc140
+                c = (((c & 0xff00) >> 8) * 0xc0) + (c & 0xff)
+            else:
+                raise UnicodeEncodeError('qrkanji', data, i, i+1,
+                                         'illegal multibyte sequence')
+            codes.append(c)
+        return codes
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        for d in self.data:
+            buffer.put(d, 13)
+
+class QRHanzi(QR):
+    bits = (13,)
+    group = 1
+    mode = 0xD
+    lengthbits = (8, 10, 12)
+
+    def __init__(self, data):
+        try:
+            self.data = self.unicode_to_qrhanzi(data)
+        except UnicodeEncodeError:
+            raise ValueError('Not valid hanzi')
+
+    def unicode_to_qrhanzi(self, data):
+        codes = []
+        for i,c in enumerate(data):
+            try:
+                c = c.encode('gb2312')
+                try:
+                    c,d = map(ord, c)
+                except TypeError:
+                    # Python 3
+                    c,d = c
+            except UnicodeEncodeError as e:
+                raise UnicodeEncodeError('qrhanzi', data, i, i+1, e.args[4])
+            except ValueError:
+                raise UnicodeEncodeError('qrhanzi', data, i, i+1,
+                                         'illegal multibyte sequence')
+            c = c << 8 | d
+            if 0xa1a1 <= c <=0xaafe:
+                c -= 0xa1a1
+                c = (((c & 0xff00) >> 8) * 0x60) + (c & 0xff)
+            elif 0xb0a1 <= c <= 0xfafe:
+                c -= 0xa6a1
+                c = (((c & 0xff00) >> 8) * 0x60) + (c & 0xff)
+            else:
+                raise UnicodeEncodeError('qrhanzi', data, i, i+1,
+                                         'illegal multibyte sequence')
+            codes.append(c)
+        return codes
+
+    def write_header(self, buffer, version):
+        buffer.put(self.mode, 4)
+        buffer.put(1, 4)  # Subset 1: GB2312 encoding
+        lenbits = self.getLengthBits(version)
+        if lenbits:
+            buffer.put(len(self.data), lenbits )
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        for d in self.data:
+            buffer.put(d, 13)
+
+
+# Special modes
+class QRECI(QR):
+    mode = 0x7
+    lengthbits = (0, 0, 0)
+
+    def __init__(self, data):
+        if not 0 < data < 999999:
+            # Spec says 999999, format supports up to 0x1fffff = 2097151
+            raise ValueError("ECI out of range")
+        self.data = data
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        if self.data <= 0x7f:
+            buffer.put(self.data, 8)
+        elif self.data <= 0x3fff:
+            buffer.put(self.data | 0x8000, 16)
+        elif self.data <= 0x1fffff:
+            buffer.put(self.data | 0xC00000, 24)
+
+class QRStructAppend(QR):
+    mode = 0x3
+    lengthbits = (0, 0, 0)
+
+    def __init__(self, part, total, parity):
+        if not 0 < part <= 16:
+            raise ValueError("part out of range [1,16]")
+        if not 0 < total <= 16:
+            raise ValueError("total out of range [1,16]")
+        self.part = part
+        self.total = total
+        self.parity = parity
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        buffer.put(self.part, 4)
+        buffer.put(self.total, 4)
+        buffer.put(self.parity, 8)
+
+class QRFNC1First(QR):
+    mode = 0x5
+    lengthbits = (0, 0, 0)
+
+    def __init__(self):
+        pass
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+
+
+class QRFNC1Second(QR):
+    valid = re.compile('^([A-Za-z]|[0-9][0-9])$').match
+    mode = 0x9
+    lengthbits = (0, 0, 0)
+
+    def write(self, buffer, version):
+        self.write_header(buffer, version)
+        d = self.data
+        if len(d) == 1:
+            d = ord(d) + 100
+        else:
+            d = int(d)
+        buffer.put(d, 8)
+
+class QRCode:
+    def __init__(self, version, errorCorrectLevel):
+        self.version = version
+        self.errorCorrectLevel = errorCorrectLevel
+        self.modules = None
+        self.moduleCount = 0
+        self.dataCache = None
+        self.dataList = []
+
+    def addData(self, data):
+        if isinstance(data, QR):
+            newData = data
+        else:
+            for conv in (QRNumber, QRAlphaNum, QRKanji, QR8bitByte):
+                try:
+                    newData = conv(data)
+                    break
+                except ValueError:
+                    pass
+            else:
+                raise ValueError
+
+        self.dataList.append(newData)
+        self.dataCache = None
+
+    def isDark(self, row, col):
+        return self.modules[row][col]
+
+    def getModuleCount(self):
+        return self.moduleCount
+
+    def calculate_version(self):
+        # Calculate version for data to fit the QR Code capacity
+        for version in range(1, 40):
+            rsBlocks = QRRSBlock.getRSBlocks(version, self.errorCorrectLevel)
+            totalDataCount = sum(block.dataCount for block in rsBlocks)
+            length = 0
+            for data in self.dataList:
+                length += 4
+                length += data.getLengthBits(version)
+                length += data.bitlength
+            if length <= totalDataCount * 8:
+                break
+        return version
+
+    def make(self):
+        if self.version is None:
+            self.version = self.calculate_version()
+        self.makeImpl(False, self.getBestMaskPattern())
+
+    def makeImpl(self, test, maskPattern):
+        self.moduleCount = self.version * 4 + 17
+        self.modules = [ [False] * self.moduleCount
+                         for x in range(self.moduleCount) ]
+        self.setupPositionProbePattern(0, 0)
+        self.setupPositionProbePattern(self.moduleCount - 7, 0)
+        self.setupPositionProbePattern(0, self.moduleCount - 7)
+        self.setupPositionAdjustPattern()
+        self.setupTimingPattern()
+        self.setupTypeInfo(test, maskPattern)
+        if (self.version >= 7):
+            self.setupTypeNumber(test)
+        if (self.dataCache == None):
+            self.dataCache = QRCode.createData(self.version,
+                                               self.errorCorrectLevel,
+                                               self.dataList)
+        self.mapData(self.dataCache, maskPattern)
+
+    _positionProbePattern = [
+        [True,  True,  True,  True,  True,  True,  True],
+        [True, False, False, False, False, False,  True],
+        [True, False,  True,  True,  True, False,  True],
+        [True, False,  True,  True,  True, False,  True],
+        [True, False,  True,  True,  True, False,  True],
+        [True, False, False, False, False, False,  True],
+        [True,  True,  True,  True,  True,  True,  True],
+        ]
+
+    def setupPositionProbePattern(self, row, col):
+        if row == 0:
+            self.modules[row+7][col:col+7] = [False] * 7
+            if col == 0:
+                self.modules[row+7][col+7] = False
+            else:
+                self.modules[row+7][col-1] = False
+        else:
+            # col == 0
+            self.modules[row-1][col:col+8] = [False] * 8
+
+        for r, data in enumerate(self._positionProbePattern):
+            self.modules[row+r][col:col+7] = data
+            if col == 0:
+                self.modules[row+r][col+7] = False
+            else:
+                self.modules[row+r][col-1] = False
+
+    def getBestMaskPattern(self):
+        minLostPoint = 0
+        pattern = 0
+        for i in range(8):
+            self.makeImpl(True, i);
+            lostPoint = QRUtil.getLostPoint(self);
+            if (i == 0 or minLostPoint > lostPoint):
+                minLostPoint = lostPoint
+                pattern = i
+        return pattern
+
+    def setupTimingPattern(self):
+        for r in range(8, self.moduleCount - 8):
+            self.modules[r][6] = (r % 2 == 0)
+        self.modules[6][8:self.moduleCount - 8] = itertools.islice(
+            itertools.cycle([True, False]), self.moduleCount - 16)
+
+    _positionAdjustPattern = [
+        [True,  True,  True,  True,  True],
+        [True, False, False, False,  True],
+        [True, False,  True, False,  True],
+        [True, False, False, False,  True],
+        [True,  True,  True,  True,  True],
+        ]
+
+    def setupPositionAdjustPattern(self):
+        pos = QRUtil.getPatternPosition(self.version)
+        maxpos = self.moduleCount - 8
+        for row, col in itertools.product(pos, pos):
+            if col <= 8 and (row <= 8 or row >= maxpos):
+                continue
+            elif col >= maxpos and row <= 8:
+                continue
+            for r, data in enumerate(self._positionAdjustPattern):
+                self.modules[row + r - 2][col-2:col+3] = data
+
+    def setupTypeNumber(self, test):
+        bits = QRUtil.getBCHTypeNumber(self.version)
+        for i in range(18):
+            mod = (not test and ( (bits >> i) & 1) == 1)
+            self.modules[i // 3][i % 3 + self.moduleCount - 8 - 3] = mod;
+        for i in range(18):
+            mod = (not test and ( (bits >> i) & 1) == 1)
+            self.modules[i % 3 + self.moduleCount - 8 - 3][i // 3] = mod;
+
+    def setupTypeInfo(self, test, maskPattern):
+        data = (self.errorCorrectLevel << 3) | maskPattern
+        bits = QRUtil.getBCHTypeInfo(data)
+        # vertical
+        for i in range(15):
+            mod = (not test and ( (bits >> i) & 1) == 1)
+            if (i < 6):
+                self.modules[i][8] = mod
+            elif (i < 8):
+                self.modules[i + 1][8] = mod
+            else:
+                self.modules[self.moduleCount - 15 + i][8] = mod
+        # horizontal
+        for i in range(15):
+            mod = (not test and ( (bits >> i) & 1) == 1);
+            if (i < 8):
+                self.modules[8][self.moduleCount - i - 1] = mod
+            elif (i < 9):
+                self.modules[8][15 - i - 1 + 1] = mod
+            else:
+                self.modules[8][15 - i - 1] = mod
+        # fixed module
+        self.modules[self.moduleCount - 8][8] = (not test)
+
+    def _dataPosIterator(self):
+        cols = itertools.chain(range(self.moduleCount - 1, 6, -2),
+                               range(5, 0, -2))
+        rows = (list(range(9, self.moduleCount - 8)),
+                list(itertools.chain(range(6), range(7, self.moduleCount))),
+                list(range(9, self.moduleCount)))
+        rrows = tuple( list(reversed(r)) for r in rows)
+
+        ppos = QRUtil.getPatternPosition(self.version)
+        ppos = set(itertools.chain.from_iterable(
+            (p-2, p-1, p, p+1, p+2) for p in ppos))
+        maxpos = self.moduleCount - 11
+
+        for col in cols:
+            rows, rrows = rrows, rows
+            if col <= 8: rowidx = 0
+            elif col >= self.moduleCount - 8: rowidx = 2
+            else: rowidx = 1
+            for row in rows[rowidx]:
+                for c in range(2):
+                    c = col - c
+                    if self.version >= 7:
+                        if row < 6 and c >= self.moduleCount - 11:
+                            continue
+                        elif col < 6 and row >= self.moduleCount - 11:
+                            continue
+                    if row in ppos and c in ppos:
+                        if not (row < 11 and (c < 11 or c > maxpos) or
+                            c < 11 and (row < 11 or row > maxpos)):
+                            continue
+
+                    yield (c, row)
+
+    _dataPosList = None
+
+    def dataPosIterator(self):
+        if not self._dataPosList:
+            self._dataPosList = list(self._dataPosIterator())
+        return self._dataPosList
+
+    def _dataBitIterator(self, data):
+        for byte in data:
+            for bit in [0x80, 0x40, 0x20, 0x10,
+                        0x08, 0x04, 0x02, 0x01]:
+                yield bool(byte & bit)
+
+    _dataBitList = None
+    def dataBitIterator(self, data):
+        if not self._dataBitList:
+            self._dataBitList = list(self._dataBitIterator(data))
+        return iter(self._dataBitList)
+
+    def mapData(self, data, maskPattern):
+        bits = self.dataBitIterator(data)
+        mask = QRUtil.getMask(maskPattern)
+
+        for (col, row), dark in zip_longest(self.dataPosIterator(), bits,
+                                            fillvalue=False):
+            self.modules[row][col] = dark ^ mask(row, col)
+
+    PAD0 = 0xEC
+    PAD1 = 0x11
+
+    @staticmethod
+    def createData(version, errorCorrectLevel, dataList):
+        rsBlocks = QRRSBlock.getRSBlocks(version, errorCorrectLevel)
+        buffer = QRBitBuffer();
+        for data in dataList:
+            data.write(buffer, version)
+        # calc num max data.
+        totalDataCount = 0;
+        for block in rsBlocks:
+            totalDataCount += block.dataCount
+        if (buffer.getLengthInBits() > totalDataCount * 8):
+            raise Exception("code length overflow. (%d > %d)" %
+                            (buffer.getLengthInBits(), totalDataCount * 8))
+        # end code
+        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8):
+            buffer.put(0, 4)
+        # padding
+        while (buffer.getLengthInBits() % 8 != 0):
+            buffer.putBit(False)
+        # padding
+        while (True):
+            if (buffer.getLengthInBits() >= totalDataCount * 8):
+                break
+            buffer.put(QRCode.PAD0, 8)
+            if (buffer.getLengthInBits() >= totalDataCount * 8):
+                break
+            buffer.put(QRCode.PAD1, 8)
+        return QRCode.createBytes(buffer, rsBlocks)
+
+    @staticmethod
+    def createBytes(buffer, rsBlocks):
+        offset = 0
+        maxDcCount = 0
+        maxEcCount = 0
+        totalCodeCount = 0
+        dcdata = []
+        ecdata = []
+        for block in rsBlocks:
+            totalCodeCount += block.totalCount
+            dcCount = block.dataCount
+            ecCount = block.totalCount - dcCount
+            maxDcCount = max(maxDcCount, dcCount)
+            maxEcCount = max(maxEcCount, ecCount)
+            dcdata.append(buffer.buffer[offset:offset+dcCount])
+            offset += dcCount
+            rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount)
+            rawPoly = QRPolynomial(dcdata[-1], rsPoly.getLength() - 1)
+            modPoly = rawPoly.mod(rsPoly)
+            rLen = rsPoly.getLength() - 1
+            mLen = modPoly.getLength()
+            ecdata.append([ (modPoly.get(i) if i >= 0 else 0)
+                          for i in range(mLen - rLen, mLen) ])
+
+        data = [ d for dd in itertools.chain(
+                zip_longest(*dcdata), zip_longest(*ecdata))
+                 for d in dd if d is not None]
+        return data
+
+
+class QRErrorCorrectLevel:
+    L = 1
+    M = 0
+    Q = 3
+    H = 2
+
+class QRMaskPattern:
+    PATTERN000 = 0
+    PATTERN001 = 1
+    PATTERN010 = 2
+    PATTERN011 = 3
+    PATTERN100 = 4
+    PATTERN101 = 5
+    PATTERN110 = 6
+    PATTERN111 = 7
+
+class QRUtil(object):
+    PATTERN_POSITION_TABLE = [
+        [],
+        [6, 18],
+        [6, 22],
+        [6, 26],
+        [6, 30],
+        [6, 34],
+        [6, 22, 38],
+        [6, 24, 42],
+        [6, 26, 46],
+        [6, 28, 50],
+        [6, 30, 54],
+        [6, 32, 58],
+        [6, 34, 62],
+        [6, 26, 46, 66],
+        [6, 26, 48, 70],
+        [6, 26, 50, 74],
+        [6, 30, 54, 78],
+        [6, 30, 56, 82],
+        [6, 30, 58, 86],
+        [6, 34, 62, 90],
+        [6, 28, 50, 72, 94],
+        [6, 26, 50, 74, 98],
+        [6, 30, 54, 78, 102],
+        [6, 28, 54, 80, 106],
+        [6, 32, 58, 84, 110],
+        [6, 30, 58, 86, 114],
+        [6, 34, 62, 90, 118],
+        [6, 26, 50, 74, 98, 122],
+        [6, 30, 54, 78, 102, 126],
+        [6, 26, 52, 78, 104, 130],
+        [6, 30, 56, 82, 108, 134],
+        [6, 34, 60, 86, 112, 138],
+        [6, 30, 58, 86, 114, 142],
+        [6, 34, 62, 90, 118, 146],
+        [6, 30, 54, 78, 102, 126, 150],
+        [6, 24, 50, 76, 102, 128, 154],
+        [6, 28, 54, 80, 106, 132, 158],
+        [6, 32, 58, 84, 110, 136, 162],
+        [6, 26, 54, 82, 110, 138, 166],
+        [6, 30, 58, 86, 114, 142, 170]
+    ]
+
+    G15 = ((1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) |
+           (1 << 0))
+    G18 = ((1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) |
+           (1 << 5) | (1 << 2) | (1 << 0))
+    G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
+
+    @staticmethod
+    def getBCHTypeInfo(data):
+        d = data << 10;
+        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0):
+            d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) -
+                                 QRUtil.getBCHDigit(QRUtil.G15) ) )
+        return ( (data << 10) | d) ^ QRUtil.G15_MASK
+
+    @staticmethod
+    def getBCHTypeNumber(data):
+        d = data << 12;
+        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0):
+            d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) -
+                                 QRUtil.getBCHDigit(QRUtil.G18) ) )
+        return (data << 12) | d
+
+    @staticmethod
+    def getBCHDigit(data):
+        digit = 0;
+        while (data != 0):
+            digit += 1
+            data >>= 1
+        return digit
+
+    @staticmethod
+    def getPatternPosition(version):
+        return QRUtil.PATTERN_POSITION_TABLE[version - 1]
+
+    maskPattern = {
+        0: lambda i,j: (i + j) % 2 == 0,
+        1: lambda i,j: i % 2 == 0,
+        2: lambda i,j: j % 3 == 0,
+        3: lambda i,j: (i + j) % 3 == 0,
+        4: lambda i,j: (i // 2 + j // 3) % 2 == 0,
+        5: lambda i,j: (i*j)%2 + (i*j)%3 == 0,
+        6: lambda i,j: ( (i * j) % 2 + (i * j) % 3) % 2 == 0,
+        7: lambda i,j: ( (i * j) % 3 + (i + j) % 2) % 2 == 0
+        }
+
+    @classmethod
+    def getMask(cls, maskPattern):
+        return cls.maskPattern[maskPattern]
+
+    @staticmethod
+    def getErrorCorrectPolynomial(errorCorrectLength):
+        a = QRPolynomial([1], 0);
+        for i in range(errorCorrectLength):
+            a = a.multiply(QRPolynomial([1, QRMath.gexp(i)], 0) )
+        return a
+
+    @classmethod
+    def maskScoreRule1vert(cls, modules):
+        score = 0
+        lastCount = [0]
+        lastRow = None
+        for row in modules:
+            # Vertical patterns
+            if lastRow:
+                changed = [a ^ b for a,b in zip(row, lastRow)]
+                scores = [a and (b-4+3) for a,b in
+                          zip_longest(changed, lastCount, fillvalue=0)
+                          if b >= 4]
+                score += sum(scores)
+                lastCount = [0 if a else b + 1
+                             for a,b in zip_longest(changed, lastCount,
+                                                    fillvalue=0)]
+            lastRow = row
+
+        score += sum([b-4+3 for b in lastCount if b >= 4])  # final counts
+        return score
+
+    @classmethod
+    def maskScoreRule2(cls, modules):
+        score = 0
+        lastRow = modules[0]
+        for row in modules[1:]:
+            lastCol0, lastCol1 = row[0], lastRow[0]
+            for col0, col1 in zip(row[1:], lastRow[1:]):
+                if col0 == col1 == lastCol0 == lastCol1:
+                    score += 3
+                lastCol0, lastCol1 = col0, col1
+            lastRow = row
+
+        return score
+
+    @classmethod
+    def maskScoreRule3hor(
+        cls, modules,
+        pattern = [True, False, True, True, True, False, True,
+                   False, False, False, False]):
+        patternlen = len(pattern)
+        score = 0
+        for row in modules:
+            j = 0
+            maxj = len(row) - patternlen
+            while j < maxj:
+                if row[j:j+patternlen] == pattern:
+                    score += 40
+                    j += patternlen
+                else:
+                    j += 1
+
+        return score
+
+    @classmethod
+    def maskScoreRule4(cls, modules):
+        cellCount = len(modules)**2
+        count = sum(sum(row) for row in modules)
+        return 10 * (abs(100 * count // cellCount - 50) // 5)
+
+    @classmethod
+    def getLostPoint(cls, qrCode):
+        lostPoint = 0;
+        # LEVEL1
+        lostPoint += cls.maskScoreRule1vert(qrCode.modules)
+        lostPoint += cls.maskScoreRule1vert(zip(*qrCode.modules))
+        # LEVEL2
+        lostPoint += cls.maskScoreRule2(qrCode.modules)
+        # LEVEL3
+        lostPoint += cls.maskScoreRule3hor(qrCode.modules)
+        lostPoint += cls.maskScoreRule3hor(zip(*qrCode.modules))
+        # LEVEL4
+        lostPoint += cls.maskScoreRule4(qrCode.modules)
+        return lostPoint
+
+class QRMath:
+    @staticmethod
+    def glog(n):
+        if (n < 1):
+            raise Exception("glog(" + n + ")")
+        return LOG_TABLE[n];
+
+    @staticmethod
+    def gexp(n):
+        while n < 0:
+            n += 255
+        while n >= 256:
+            n -= 255
+        return EXP_TABLE[n];
+
+EXP_TABLE = [x for x in range(256)]
+LOG_TABLE = [x for x in range(256)]
+for i in range(8):
+    EXP_TABLE[i] = 1 << i;
+for i in range(8, 256):
+    EXP_TABLE[i] = (EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^
+                    EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8])
+for i in range(255):
+    LOG_TABLE[EXP_TABLE[i] ] = i
+
+class QRPolynomial:
+    def __init__(self, num, shift):
+        if (len(num) == 0):
+            raise Exception(len(num) + "/" + shift)
+        offset = 0
+        while offset < len(num) and num[offset] == 0:
+            offset += 1
+        self.num = num[offset:] + [0]*shift
+
+    def get(self, index):
+        return self.num[index]
+
+    def getLength(self):
+        return len(self.num)
+
+    def multiply(self, e):
+        num = [0] * (self.getLength() + e.getLength() - 1);
+        for i in range(self.getLength()):
+            for j in range(e.getLength()):
+                num[i + j] ^= QRMath.gexp(QRMath.glog(self.get(i) ) +
+                                          QRMath.glog(e.get(j) ) )
+        return QRPolynomial(num, 0);
+
+    def mod(self, e):
+        if (self.getLength() < e.getLength()):
+            return self;
+        ratio = QRMath.glog(self.num[0] ) - QRMath.glog(e.num[0] )
+        num = [nn ^ QRMath.gexp(QRMath.glog(en) + ratio)
+               for nn,en in zip(self.num, e.num)]
+        num += self.num[e.getLength():]
+        # recursive call
+        return QRPolynomial(num, 0).mod(e);
+
+class QRRSBlock:
+    RS_BLOCK_TABLE = [
+        # L
+        # M
+        # Q
+        # H
+
+        # 1
+        [1, 26, 19],
+        [1, 26, 16],
+        [1, 26, 13],
+        [1, 26, 9],
+
+        # 2
+        [1, 44, 34],
+        [1, 44, 28],
+        [1, 44, 22],
+        [1, 44, 16],
+
+        # 3
+        [1, 70, 55],
+        [1, 70, 44],
+        [2, 35, 17],
+        [2, 35, 13],
+
+        # 4
+        [1, 100, 80],
+        [2, 50, 32],
+        [2, 50, 24],
+        [4, 25, 9],
+
+        # 5
+        [1, 134, 108],
+        [2, 67, 43],
+        [2, 33, 15, 2, 34, 16],
+        [2, 33, 11, 2, 34, 12],
+
+        # 6
+        [2, 86, 68],
+        [4, 43, 27],
+        [4, 43, 19],
+        [4, 43, 15],
+
+        # 7
+        [2, 98, 78],
+        [4, 49, 31],
+        [2, 32, 14, 4, 33, 15],
+        [4, 39, 13, 1, 40, 14],
+
+        # 8
+        [2, 121, 97],
+        [2, 60, 38, 2, 61, 39],
+        [4, 40, 18, 2, 41, 19],
+        [4, 40, 14, 2, 41, 15],
+
+        # 9
+        [2, 146, 116],
+        [3, 58, 36, 2, 59, 37],
+        [4, 36, 16, 4, 37, 17],
+        [4, 36, 12, 4, 37, 13],
+
+        # 10
+        [2, 86, 68, 2, 87, 69],
+        [4, 69, 43, 1, 70, 44],
+        [6, 43, 19, 2, 44, 20],
+        [6, 43, 15, 2, 44, 16],
+
+        # 11
+        [4, 101, 81],
+        [1, 80, 50, 4, 81, 51],
+        [4, 50, 22, 4, 51, 23],
+        [3, 36, 12, 8, 37, 13],
+
+        # 12
+        [2, 116, 92, 2, 117, 93],
+        [6, 58, 36, 2, 59, 37],
+        [4, 46, 20, 6, 47, 21],
+        [7, 42, 14, 4, 43, 15],
+
+        # 13
+        [4, 133, 107],
+        [8, 59, 37, 1, 60, 38],
+        [8, 44, 20, 4, 45, 21],
+        [12, 33, 11, 4, 34, 12],
+
+        # 14
+        [3, 145, 115, 1, 146, 116],
+        [4, 64, 40, 5, 65, 41],
+        [11, 36, 16, 5, 37, 17],
+        [11, 36, 12, 5, 37, 13],
+
+        # 15
+        [5, 109, 87, 1, 110, 88],
+        [5, 65, 41, 5, 66, 42],
+        [5, 54, 24, 7, 55, 25],
+        [11, 36, 12],
+
+        # 16
+        [5, 122, 98, 1, 123, 99],
+        [7, 73, 45, 3, 74, 46],
+        [15, 43, 19, 2, 44, 20],
+        [3, 45, 15, 13, 46, 16],
+
+        # 17
+        [1, 135, 107, 5, 136, 108],
+        [10, 74, 46, 1, 75, 47],
+        [1, 50, 22, 15, 51, 23],
+        [2, 42, 14, 17, 43, 15],
+
+        # 18
+        [5, 150, 120, 1, 151, 121],
+        [9, 69, 43, 4, 70, 44],
+        [17, 50, 22, 1, 51, 23],
+        [2, 42, 14, 19, 43, 15],
+
+        # 19
+        [3, 141, 113, 4, 142, 114],
+        [3, 70, 44, 11, 71, 45],
+        [17, 47, 21, 4, 48, 22],
+        [9, 39, 13, 16, 40, 14],
+
+        # 20
+        [3, 135, 107, 5, 136, 108],
+        [3, 67, 41, 13, 68, 42],
+        [15, 54, 24, 5, 55, 25],
+        [15, 43, 15, 10, 44, 16],
+
+        # 21
+        [4, 144, 116, 4, 145, 117],
+        [17, 68, 42],
+        [17, 50, 22, 6, 51, 23],
+        [19, 46, 16, 6, 47, 17],
+
+        # 22
+        [2, 139, 111, 7, 140, 112],
+        [17, 74, 46],
+        [7, 54, 24, 16, 55, 25],
+        [34, 37, 13],
+
+        # 23
+        [4, 151, 121, 5, 152, 122],
+        [4, 75, 47, 14, 76, 48],
+        [11, 54, 24, 14, 55, 25],
+        [16, 45, 15, 14, 46, 16],
+
+        # 24
+        [6, 147, 117, 4, 148, 118],
+        [6, 73, 45, 14, 74, 46],
+        [11, 54, 24, 16, 55, 25],
+        [30, 46, 16, 2, 47, 17],
+
+        # 25
+        [8, 132, 106, 4, 133, 107],
+        [8, 75, 47, 13, 76, 48],
+        [7, 54, 24, 22, 55, 25],
+        [22, 45, 15, 13, 46, 16],
+
+        # 26
+        [10, 142, 114, 2, 143, 115],
+        [19, 74, 46, 4, 75, 47],
+        [28, 50, 22, 6, 51, 23],
+        [33, 46, 16, 4, 47, 17],
+
+        # 27
+        [8, 152, 122, 4, 153, 123],
+        [22, 73, 45, 3, 74, 46],
+        [8, 53, 23, 26, 54, 24],
+        [12, 45, 15, 28, 46, 16],
+
+        # 28
+        [3, 147, 117, 10, 148, 118],
+        [3, 73, 45, 23, 74, 46],
+        [4, 54, 24, 31, 55, 25],
+        [11, 45, 15, 31, 46, 16],
+
+        # 29
+        [7, 146, 116, 7, 147, 117],
+        [21, 73, 45, 7, 74, 46],
+        [1, 53, 23, 37, 54, 24],
+        [19, 45, 15, 26, 46, 16],
+
+        # 30
+        [5, 145, 115, 10, 146, 116],
+        [19, 75, 47, 10, 76, 48],
+        [15, 54, 24, 25, 55, 25],
+        [23, 45, 15, 25, 46, 16],
+
+        # 31
+        [13, 145, 115, 3, 146, 116],
+        [2, 74, 46, 29, 75, 47],
+        [42, 54, 24, 1, 55, 25],
+        [23, 45, 15, 28, 46, 16],
+
+        # 32
+        [17, 145, 115],
+        [10, 74, 46, 23, 75, 47],
+        [10, 54, 24, 35, 55, 25],
+        [19, 45, 15, 35, 46, 16],
+
+        # 33
+        [17, 145, 115, 1, 146, 116],
+        [14, 74, 46, 21, 75, 47],
+        [29, 54, 24, 19, 55, 25],
+        [11, 45, 15, 46, 46, 16],
+
+        # 34
+        [13, 145, 115, 6, 146, 116],
+        [14, 74, 46, 23, 75, 47],
+        [44, 54, 24, 7, 55, 25],
+        [59, 46, 16, 1, 47, 17],
+
+        # 35
+        [12, 151, 121, 7, 152, 122],
+        [12, 75, 47, 26, 76, 48],
+        [39, 54, 24, 14, 55, 25],
+        [22, 45, 15, 41, 46, 16],
+
+        # 36
+        [6, 151, 121, 14, 152, 122],
+        [6, 75, 47, 34, 76, 48],
+        [46, 54, 24, 10, 55, 25],
+        [2, 45, 15, 64, 46, 16],
+
+        # 37
+        [17, 152, 122, 4, 153, 123],
+        [29, 74, 46, 14, 75, 47],
+        [49, 54, 24, 10, 55, 25],
+        [24, 45, 15, 46, 46, 16],
+
+        # 38
+        [4, 152, 122, 18, 153, 123],
+        [13, 74, 46, 32, 75, 47],
+        [48, 54, 24, 14, 55, 25],
+        [42, 45, 15, 32, 46, 16],
+
+        # 39
+        [20, 147, 117, 4, 148, 118],
+        [40, 75, 47, 7, 76, 48],
+        [43, 54, 24, 22, 55, 25],
+        [10, 45, 15, 67, 46, 16],
+
+        # 40
+        [19, 148, 118, 6, 149, 119],
+        [18, 75, 47, 31, 76, 48],
+        [34, 54, 24, 34, 55, 25],
+        [20, 45, 15, 61, 46, 16]
+
+    ]
+
+    def __init__(self, totalCount, dataCount):
+        self.totalCount = totalCount
+        self.dataCount = dataCount
+
+    @staticmethod
+    def getRSBlocks(version, errorCorrectLevel):
+        rsBlock = QRRSBlock.getRsBlockTable(version, errorCorrectLevel);
+        if rsBlock == None:
+            raise Exception("bad rs block @ version:" + version +
+                            "/errorCorrectLevel:" + errorCorrectLevel)
+        length = len(rsBlock) // 3
+        list = []
+        for i in range(length):
+            count = rsBlock[i * 3 + 0]
+            totalCount = rsBlock[i * 3 + 1]
+            dataCount  = rsBlock[i * 3 + 2]
+            for j in range(count):
+                list.append(QRRSBlock(totalCount, dataCount))
+        return list;
+
+    @staticmethod
+    def getRsBlockTable(version, errorCorrectLevel):
+        if errorCorrectLevel == QRErrorCorrectLevel.L:
+            return QRRSBlock.RS_BLOCK_TABLE[(version - 1) * 4 + 0];
+        elif errorCorrectLevel == QRErrorCorrectLevel.M:
+            return QRRSBlock.RS_BLOCK_TABLE[(version - 1) * 4 + 1];
+        elif errorCorrectLevel ==  QRErrorCorrectLevel.Q:
+            return QRRSBlock.RS_BLOCK_TABLE[(version - 1) * 4 + 2];
+        elif errorCorrectLevel ==  QRErrorCorrectLevel.H:
+            return QRRSBlock.RS_BLOCK_TABLE[(version - 1) * 4 + 3];
+        else:
+            return None;
+
+class QRBitBuffer:
+    def __init__(self):
+        self.buffer = []
+        self.length = 0
+
+    def __repr__(self):
+        return ".".join([str(n) for n in self.buffer])
+
+    def get(self, index):
+        bufIndex = index // 8
+        return ( (self.buffer[bufIndex] >> (7 - index % 8) ) & 1) == 1
+
+    def put(self, num, length):
+        for i in range(length):
+            self.putBit( ( (num >> (length - i - 1) ) & 1) == 1)
+
+    def getLengthInBits(self):
+        return self.length
+
+    def putBit(self, bit):
+        bufIndex = self.length // 8
+        if len(self.buffer) <= bufIndex:
+            self.buffer.append(0)
+        if bit:
+            self.buffer[bufIndex] |= (0x80 >> (self.length % 8) )
+        self.length += 1
diff -uNr reportlab-3.1.8/src/reportlab/graphics/barcode/usps4s.py reportlab-3.1.41/src/reportlab/graphics/barcode/usps4s.py
--- reportlab-3.1.8/src/reportlab/graphics/barcode/usps4s.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/barcode/usps4s.py	2014-08-12 20:28:18.718110784 +0900
@@ -53,12 +53,12 @@
 
     def tracking(self,tracking):
         self._init()
-        self._tracking = value
+        self._tracking = tracking
     tracking = property(lambda self: self._tracking,tracking)
 
     def routing(self,routing):
         self._init()
-        self._routing = value
+        self._routing = routing
     routing = property(lambda self: self._routing,routing)
 
     def widthSize(self,value):
diff -uNr reportlab-3.1.8/src/reportlab/graphics/charts/areas.py reportlab-3.1.41/src/reportlab/graphics/charts/areas.py
--- reportlab-3.1.8/src/reportlab/graphics/charts/areas.py	2013-03-14 20:30:08.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/charts/areas.py	2014-08-12 20:28:18.719110784 +0900
@@ -9,6 +9,7 @@
 from reportlab.graphics.widgetbase import Widget
 from reportlab.graphics.shapes import Rect, Group, Line, Polygon
 from reportlab.lib.attrmap import AttrMap, AttrMapValue
+from reportlab.lib.colors import grey
 
 class PlotArea(Widget):
     "Abstract base class representing a chart's plot area, pretty unusable by itself."
diff -uNr reportlab-3.1.8/src/reportlab/graphics/charts/utils.py reportlab-3.1.41/src/reportlab/graphics/charts/utils.py
--- reportlab-3.1.8/src/reportlab/graphics/charts/utils.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/charts/utils.py	2014-08-12 20:28:18.726110778 +0900
@@ -7,7 +7,7 @@
 from time import mktime, gmtime, strftime
 from math import log10, pi, floor, sin, cos, sqrt, hypot
 import weakref
-from reportlab.graphics.shapes import transformPoint, transformPoints, inverse, Ellipse, Group, String, Path
+from reportlab.graphics.shapes import transformPoint, transformPoints, inverse, Ellipse, Group, String, Path, numericXShift
 from reportlab.lib.utils import flatten
 from reportlab.pdfbase.pdfmetrics import stringWidth
 
diff -uNr reportlab-3.1.8/src/reportlab/graphics/renderPM.py reportlab-3.1.41/src/reportlab/graphics/renderPM.py
--- reportlab-3.1.8/src/reportlab/graphics/renderPM.py	2014-04-04 22:45:37.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/renderPM.py	2014-08-12 20:28:18.727110778 +0900
@@ -137,7 +137,7 @@
         if dstH is None: dstH = srcH
         self._canvas._aapixbuf(
                 image.x, image.y, dstW, dstH,
-                im.tostring(), srcW, srcH, 3,
+                (im.tobytes if hasattr(im,'tobytes') else im.tostring)(), srcW, srcH, 3,
                 )
 
     def drawCircle(self, circle):
@@ -241,7 +241,7 @@
     im = _convert2pilp(im)
     cols, rows = im.size
     #s = _renderPM.pil2pict(cols,rows,im.tostring(),im.im.getpalette(),transparent is not None and Color2Hex(transparent) or -1)
-    s = _renderPM.pil2pict(cols,rows,im.tostring(),im.im.getpalette())
+    s = _renderPM.pil2pict(cols,rows,(im.tobytes if hasattr(im,'tobytes') else im.tostring)(),im.im.getpalette())
     if not hasattr(fn,'write'):
         open(os.path.splitext(fn)[0]+'.'+fmt.lower(),'wb').write(s)
         if os.name=='mac':
diff -uNr reportlab-3.1.8/src/reportlab/graphics/renderPS.py reportlab-3.1.41/src/reportlab/graphics/renderPS.py
--- reportlab-3.1.8/src/reportlab/graphics/renderPS.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/renderPS.py	2014-08-12 20:28:18.728110777 +0900
@@ -585,7 +585,7 @@
         # data source output--now we just need to deliver a hex encode
         # series of lines of the right overall size can follow
         # piddlePDF again
-        rawimage = myimage.tostring()
+        rawimage = (myimage.tobytes if hasattr(myimage,'tobytes') else myimage.tostring)()
         hex_encoded = self._AsciiHexEncode(rawimage)
 
         # write in blocks of 78 chars per line
@@ -655,7 +655,7 @@
                             '>> % End image dictionary',
                             'image'])
         # after image operator just need to dump image dat to file as hexstring
-        rawimage = myimage.tostring()
+        rawimage = (myimage.tobytes if hasattr(myimage,'tobytes') else myimage.tostring)()
         hex_encoded = self._AsciiHexEncode(rawimage)
 
         # write in blocks of 78 chars per line
diff -uNr reportlab-3.1.8/src/reportlab/graphics/shapes.py reportlab-3.1.41/src/reportlab/graphics/shapes.py
--- reportlab-3.1.8/src/reportlab/graphics/shapes.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/graphics/shapes.py	2014-08-12 20:28:18.700110800 +0900
@@ -120,7 +120,9 @@
     return (A[0]*v[0]+A[2]*v[1]+A[4],A[1]*v[0]+A[3]*v[1]+A[5])
 
 def transformPoints(matrix, V):
-    return list(map(transformPoint, V))
+    r = [transformPoint(matrix,v) for v in V]
+    if isinstance(V,tuple): r = tuple(r)
+    return r
 
 def zTransformPoints(matrix, V):
     return list(map(lambda x,matrix=matrix: zTransformPoint(matrix,x), V))
@@ -641,7 +643,12 @@
         renderScale = AttrMapValue(isNumber,desc="Global scaling for rendering"),
         )
 
-    _attrMap = AttrMap(BASE=Group)
+    _attrMap = AttrMap(BASE=Group,
+            formats = AttrMapValue(SequenceOf(
+                OneOf('pdf','gif','png','tif','jpg','tiff','pct','pict',
+                        'bmp','tiffp','tiffl','tiff1','eps','svg','ps','py'),
+                lo=1,emptyOK=0), desc='One or more plot modes'),
+            )
     _attrMap.update(_xtraAttrMap)
 
     def __init__(self, width=400, height=200, *nodes, **keywords):
diff -uNr reportlab-3.1.8/src/reportlab/lib/fonts.py reportlab-3.1.41/src/reportlab/lib/fonts.py
--- reportlab-3.1.8/src/reportlab/lib/fonts.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/fonts.py	2014-08-12 20:28:18.711110790 +0900
@@ -63,9 +63,13 @@
             }
 
 _ps2tt_map={}
-for k,v in _tt2ps_map.items():
-    if k not in _ps2tt_map:
-        _ps2tt_map[v.lower()] = k
+for k in sorted(_tt2ps_map.keys()):
+    v = _tt2ps_map[k].lower()
+    if v not in _ps2tt_map:
+        _ps2tt_map[v] = k
+    v = k[0].lower()
+    if v not in _ps2tt_map:
+        _ps2tt_map[v] = k
 
 def ps2tt(psfn):
     'ps fontname to family name, bold, italic'
diff -uNr reportlab-3.1.8/src/reportlab/lib/pdfencrypt.py reportlab-3.1.41/src/reportlab/lib/pdfencrypt.py
--- reportlab-3.1.8/src/reportlab/lib/pdfencrypt.py	2014-03-27 05:17:14.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/pdfencrypt.py	2014-08-12 20:28:18.714110788 +0900
@@ -384,7 +384,7 @@
         from rlextra.pageCatcher.pageCatcher import storeFormsInMemory, restoreFormsInMemory
     except ImportError:
         raise ImportError('''reportlab.lib.pdfencrypt.encryptPdfInMemory failed because rlextra cannot be imported.
-See http://developer.reportlab.com''')
+See https://www.reportlab.com/downloads''')
 
     (bboxInfo, pickledForms) = storeFormsInMemory(inputPDF, all=1, BBoxes=1)
     names = list(bboxInfo.keys())
@@ -405,13 +405,12 @@
 
     formNames = restoreFormsInMemory(pickledForms, canv)
     for formName in formNames:
-        #need to extract page size in future
+        canv.setPageSize(bboxInfo[formName][2:])
         canv.doForm(formName)
         canv.showPage()
     canv.save()
     return buf.getvalue()
 
-
 def encryptPdfOnDisk(inputFileName, outputFileName,
                   userPassword, ownerPassword=None,
                   canPrint=1, canModify=1, canCopy=1, canAnnotate=1,
@@ -592,7 +591,7 @@
             print("wrote output file '%s'(%s bytes)\n  owner password is '%s'\n  user password is '%s'" % (SAVEFILE, filesize, OWNER, USER))
 
         if len(argv)>0:
-            raise valueError("\nUnrecognised arguments : %s\nknown arguments are:\n%s" % (str(argv)[1:-1], known_modes))
+            raise ValueError("\nUnrecognised arguments : %s\nknown arguments are:\n%s" % (str(argv)[1:-1], known_modes))
     else:
         print(usage)
 
diff -uNr reportlab-3.1.8/src/reportlab/lib/rl_accel.py reportlab-3.1.41/src/reportlab/lib/rl_accel.py
--- reportlab-3.1.8/src/reportlab/lib/rl_accel.py	2014-04-03 18:38:20.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/rl_accel.py	2014-08-12 20:28:18.715110787 +0900
@@ -16,9 +16,9 @@
         add32
         hex32
         '''.split()))
-import __main__
-testing = getattr(__main__,'_rl_testing',False)
-del __main__
+import reportlab
+testing = getattr(reportlab,'_rl_testing',False)
+del reportlab
 
 for fn in __all__:
     try:
diff -uNr reportlab-3.1.8/src/reportlab/lib/styles.py reportlab-3.1.41/src/reportlab/lib/styles.py
--- reportlab-3.1.8/src/reportlab/lib/styles.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/styles.py	2014-08-12 20:28:18.718110784 +0900
@@ -112,7 +112,10 @@
         #'bulletColor':black,
         'textColor': black,
         'backColor':None,
-        'wordWrap':None,
+        'wordWrap':None,        #None means do nothing special
+                                #CJK use Chinese Line breaking
+                                #LTR RTL use left to right / right to left
+                                #with support from pyfribi2 if available
         'borderWidth': 0,
         'borderPadding': 0,
         'borderColor': None,
diff -uNr reportlab-3.1.8/src/reportlab/lib/testutils.py reportlab-3.1.41/src/reportlab/lib/testutils.py
--- reportlab-3.1.8/src/reportlab/lib/testutils.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/testutils.py	2014-08-12 20:28:18.718110784 +0900
@@ -1,8 +1,8 @@
 #Copyright ReportLab Europe Ltd. 2000-2013
 #see license.txt for license details
-import __main__
-__main__._rl_testing=True
-del __main__
+import reportlab
+reportlab._rl_testing=True
+del reportlab
 __version__='''$Id$'''
 __doc__="""Provides support for the test suite.
 
diff -uNr reportlab-3.1.8/src/reportlab/lib/utils.py reportlab-3.1.41/src/reportlab/lib/utils.py
--- reportlab-3.1.8/src/reportlab/lib/utils.py	2014-04-17 21:09:19.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/lib/utils.py	2014-08-12 20:28:18.720110783 +0900
@@ -608,27 +608,67 @@
         if 'b' not in mode and os.linesep!='\n': s = s.replace(os.linesep,'\n')
         return getBytesIO(s)
 
-try:
-    import urllib2
+if not isPy3:
+    import urllib2, urllib
     urlopen=urllib2.urlopen
-except ImportError:
-    import urllib.request
-    urlopen=urllib.request.urlopen
+    def datareader(url,opener=urllib.URLopener().open):
+        return opener(url).read()
+    del urllib, urllib2
+else:
+    from urllib.request import urlopen
+    from urllib.parse import unquote
+    import base64
+    #copied here from urllib.URLopener.open_data because
+    # 1) they want to remove it
+    # 2) the existing one is borken
+    def datareader(url, unquote=unquote, decodebytes=base64.decodebytes):
+        """Use "data" URL."""
+        # ignore POSTed data
+        #
+        # syntax of data URLs:
+        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
+        # mediatype := [ type "/" subtype ] *( ";" parameter )
+        # data      := *urlchar
+        # parameter := attribute "=" value
+        try:
+            typ, data = url.split(',', 1)
+        except ValueError:
+            raise IOError('data error', 'bad data URL')
+        if not typ:
+            typ = 'text/plain;charset=US-ASCII'
+        semi = typ.rfind(';')
+        if semi >= 0 and '=' not in typ[semi:]:
+            encoding = typ[semi+1:]
+            typ = typ[:semi]
+        else:
+            encoding = ''
+        if encoding == 'base64':
+            # XXX is this encoding/decoding ok?
+            data = decodebytes(data.encode('ascii'))
+        else:
+            data = unquote(data).encode('latin-1')
+        return data
+    del unquote, base64
 
-def open_for_read(name,mode='b', urlopen=urlopen):
+def open_for_read(name,mode='b', urlopen=urlopen, datareader=datareader):
     '''attempt to open a file or URL for reading'''
     if hasattr(name,'read'): return name
     try:
         return open_for_read_by_name(name,mode)
     except:
         try:
-            return getBytesIO(urlopen(name).read())
+            return getBytesIO(datareader(name) if name.startswith('data:') else urlopen(name).read())
         except:
             raise IOError('Cannot open resource "%s"' % name)
-del urlopen
+del urlopen, datareader
 
 def open_and_read(name,mode='b'):
-    return open_for_read(name,mode).read()
+    f = open_for_read(name,mode)
+    if name is not f and hasattr(f,'__exit__'):
+        with f:
+            return f.read()
+    else:
+        return f.read()
 
 def open_and_readlines(name,mode='t'):
     return open_and_read(name,mode).split('\n')
@@ -823,12 +863,14 @@
                         im = im.convert('RGB')
                         self.mode = 'RGB'
                     elif mode not in ('L','RGB','CMYK'):
-                        im = im.convert('RGB')
+                        if im.format=='PNG' and im.mode=='P' and 'transparency' in im.info:
+                            im = im.convert('RGBA')
+                            self._dataA = ImageReader(im.split()[3])
+                            im = im.convert('RGB')
+                        else:
+                            im = im.convert('RGB')
                         self.mode = 'RGB'
-                    if hasattr(im, 'tobytes'):  #make pillow and PIL both happy, for now
-                        self._data = im.tobytes()
-                    else:
-                        self._data = im.tostring()
+                    self._data = (im.tobytes if hasattr(im, 'tobytes') else im.tostring)()  #make pillow and PIL both happy, for now
             return self._data
         except:
             annotateException('\nidentity=%s'%self.identity())
diff -uNr reportlab-3.1.8/src/reportlab/pdfbase/cidfonts.py reportlab-3.1.41/src/reportlab/pdfbase/cidfonts.py
--- reportlab-3.1.8/src/reportlab/pdfbase/cidfonts.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfbase/cidfonts.py	2014-08-12 20:28:18.703110796 +0900
@@ -449,7 +449,7 @@
     import os
     files = os.listdir(cmapdir)
     for file in files:
-        if os.path.isfile(cmapdir + os.sep + self.name + '.fastmap'):
+        if os.path.isfile(cmapdir + os.sep + file + '.fastmap'):
             continue
         try:
             enc = CIDEncoding(file)
diff -uNr reportlab-3.1.8/src/reportlab/pdfbase/pdfdoc.py reportlab-3.1.41/src/reportlab/pdfbase/pdfdoc.py
--- reportlab-3.1.8/src/reportlab/pdfbase/pdfdoc.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfbase/pdfdoc.py	2014-08-12 20:28:18.705110795 +0900
@@ -24,6 +24,7 @@
 
 from sys import platform
 from sys import version_info
+from sys import stderr
 
 if platform[:4] == 'java' and version_info[:2] == (2, 1):
     # workaround for list()-bug in Jython 2.1 (should be fixed in 2.2)
@@ -601,7 +602,7 @@
                     try:
                         s.decode('pdfdoc')
                     except:
-                        sys.stderr.write('Error in %s' % (repr(s),))
+                        stderr.write('Error in %s' % (repr(s),))
                         raise
         elif isUnicode(s):
             if enc is 'auto':
@@ -1419,7 +1420,7 @@
                 return tuple(L)
             return L
         # bug contributed by Benjamin Dumke <reportlab@benjamin-dumke.de>
-        raise TypeError("in outline, destination name must be string: got a %s"%Ot)
+        raise TypeError("in outline, destination name must be string: got a %s"%type(object))
 
     def prepare(self, document, canvas):
         """prepare all data structures required for save operation (create related objects)"""
@@ -1484,7 +1485,7 @@
                 eltobj.Count = count(subsections, closedict)
                 (eltobj.First, eltobj.Last) = self.maketree(document, subsections, eltref)
             else:
-                raise ValueError("destination tree elt should be dict or tuple, got %s" % te)
+                raise ValueError("destination tree elt should be dict or tuple, got %s" % type(elt))
             try:
                 [(Title, Dest)] = list(leafdict.items())
             except:
diff -uNr reportlab-3.1.8/src/reportlab/pdfbase/ttfonts.py reportlab-3.1.41/src/reportlab/pdfbase/ttfonts.py
--- reportlab-3.1.8/src/reportlab/pdfbase/ttfonts.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfbase/ttfonts.py	2014-08-12 20:28:18.710110791 +0900
@@ -463,9 +463,9 @@
                     A = N.append
                     while length > 0:
                         char = self.read_ushort()
-                        A(chr(char))
+                        A(bytes([char]) if isPy3 else chr(char))
                         length -= 1
-                    N = ''.join(N)
+                    N = b''.join(N)
                 finally:
                     self._pos = opos
             elif platformId == 1 and encodingId == 0 and languageId == 0: # Macintosh, Roman, English, PS Name
@@ -706,7 +706,7 @@
             T = [self.read_ushort() for i in xrange(256)]   #subheader keys
             maxSHK = max(T)
             SH = []
-            for i in xrange(maxHK+1):
+            for i in xrange(maxSHK+1):
                 firstCode = self.read_ushort()
                 entryCount = self.read_ushort()
                 idDelta = self.read_ushort()
@@ -844,10 +844,6 @@
                     elif flags & GF_WE_HAVE_A_TWO_BY_TWO:
                         self.skip(8)
 
-        numGlyphs = n = len(glyphMap)
-        while n > 1 and self.hmetrics[n][0] == self.hmetrics[n - 1][0]:
-            n -= 1
-        numberOfHMetrics = n
 
         # The following tables are simply copied from the original
         for tag in ('name', 'OS/2', 'cvt ', 'fpgm', 'prep'):
@@ -863,6 +859,26 @@
         post = b"\x00\x03\x00\x00" + self.get_table('post')[4:16] + b"\x00" * 16
         output.add('post', post)
 
+        numGlyphs = len(glyphMap)
+
+        # hmtx - Horizontal Metrics
+        hmtx = []
+        for n in xrange(numGlyphs):
+            aw, lsb = self.hmetrics[glyphMap[n]]
+            hmtx.append(int(aw))
+            hmtx.append(int(lsb))
+
+        #work out n as 0 or first aw that's the start of a run
+        n = len(hmtx)-2
+        while n and hmtx[n]==hmtx[n-2]:
+            n -= 2
+        if not n: n = 2                 #need at least one pair
+        numberOfHMetrics = n>>1         #number of full H Metric pairs
+        hmtx = hmtx[:n] + hmtx[n+1::2]  #full pairs + all the trailing lsb's
+
+        hmtx = pack(*([">%dH" % len(hmtx)] + hmtx))
+        output.add('hmtx', hmtx)
+
         # hhea - Horizontal Header
         hhea = self.get_table('hhea')
         hhea = _set_ushort(hhea, 34, numberOfHMetrics)
@@ -886,17 +902,6 @@
         cmap = pack(*([">%dH" % len(cmap)] + cmap))
         output.add('cmap', cmap)
 
-        # hmtx - Horizontal Metrics
-        hmtx = []
-        for n in xrange(numGlyphs):
-            originalGlyphIdx = glyphMap[n]
-            aw, lsb = self.hmetrics[originalGlyphIdx]
-            if n < numberOfHMetrics:
-                hmtx.append(int(aw))
-            hmtx.append(int(lsb))
-        hmtx = pack(*([">%dH" % len(hmtx)] + hmtx))
-        output.add('hmtx', hmtx)
-
         # glyf - Glyph data
         glyphData = self.get_table('glyf')
         offsets = []
diff -uNr reportlab-3.1.8/src/reportlab/pdfgen/canvas.py reportlab-3.1.41/src/reportlab/pdfgen/canvas.py
--- reportlab-3.1.8/src/reportlab/pdfgen/canvas.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfgen/canvas.py	2014-08-12 20:28:18.712110789 +0900
@@ -272,6 +272,7 @@
         self._cropMarks = cropMarks
 
         self._pagesize = pagesize
+        self._hanging_pagesize = None
         self._pageRotation = 0
         #self._currentPageHasImages = 0
         self._pageTransition = None
@@ -646,6 +647,9 @@
 
     def _startPage(self):
         #now get ready for the next one
+        if self._hanging_pagesize:
+            self.setPageSize(self._hanging_pagesize)
+            self._hanging_pagesize = None
         self._pageNumber += 1
         self._restartAccumulators()
         self.init_graphics_state()
@@ -997,7 +1001,7 @@
         self._doc.inForm()
         #self._inForm0()
 
-    def endForm(self):
+    def endForm(self,**extra_attributes):
         """emit the current collection of graphics operations as a Form
            as declared previously in beginForm."""
         (name, lowerx, lowery, upperx, uppery) = self._formData
@@ -1012,6 +1016,8 @@
         form = pdfdoc.PDFFormXObject(lowerx=lowerx, lowery=lowery, upperx=upperx, uppery=uppery)
         form.compression = self._pageCompression
         form.setStreamList([self._preamble] + self._code) # ??? minus preamble (seems to be needed!)
+        for k, v in extra_attributes.items():
+            setattr(form,k,v)
         self._setColorSpace(form)
         self._setExtGState(form)
         self._setXObjects(form)
diff -uNr reportlab-3.1.8/src/reportlab/pdfgen/pdfimages.py reportlab-3.1.41/src/reportlab/pdfgen/pdfimages.py
--- reportlab-3.1.8/src/reportlab/pdfgen/pdfimages.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfgen/pdfimages.py	2014-08-12 20:28:18.713110789 +0900
@@ -122,8 +122,8 @@
         imagedata=['BI /W %d /H %d /BPC %d /CS /%s /F [%s/Fl] ID' % (imgwidth, imgheight, bpc, colorSpace, rl_config.useA85 and '/A85 ' or '')]
 
         #use a flate filter and, optionally, Ascii Base 85 to compress
-        raw = myimage.tostring()
-        rowstride = (imgwidth*bpc*bpp+7)/8
+        raw = (myimage.tobytes if hasattr(myimage,'tobytes') else myimage.tostring)()
+        rowstride = (imgwidth*bpc*bpp+7)>>3
         assert len(raw) == rowstride*imgheight, "Wrong amount of data for image"
         data = zlib.compress(raw)    #this bit is very fast...
         if rl_config.useA85:
diff -uNr reportlab-3.1.8/src/reportlab/pdfgen/textobject.py reportlab-3.1.41/src/reportlab/pdfgen/textobject.py
--- reportlab-3.1.8/src/reportlab/pdfgen/textobject.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/pdfgen/textobject.py	2014-08-12 20:28:18.714110788 +0900
@@ -15,6 +15,16 @@
 from reportlab.lib.utils import isBytes, isStr, asUnicode
 from reportlab.lib.rl_accel import fp_str
 from reportlab.pdfbase import pdfmetrics
+from reportlab.rl_config import rtlSupport
+
+log2vis = None
+if rtlSupport:
+    try:
+        from pyfribidi2 import log2vis, ON as DIR_ON, LTR as DIR_LTR, RTL as DIR_RTL
+        directionsMap = dict(LTR=DIR_LTR,RTL=DIR_RTL)
+    except:
+        import warnings
+        warnings.warn('pyfribidi is not installed - RTL not supported')
 
 class _PDFColorSetter:
     '''Abstracts the color setting operations; used in Canvas and Textobject
@@ -168,7 +178,7 @@
 
     It keeps track of x and y coordinates relative to its origin."""
 
-    def __init__(self, canvas, x=0,y=0):
+    def __init__(self, canvas, x=0,y=0, direction=None):
         self._code = ['BT']    #no point in [] then append RGB
         self._canvas = canvas  #canvas sets this so it has access to size info
         self._fontname = self._canvas._fontname
@@ -179,6 +189,7 @@
         self._enforceColorSpace = getattr(canvas,'_enforceColorSpace',None)
         font = pdfmetrics.getFont(self._fontname)
         self._curSubset = -1
+        self.direction = direction
         self.setTextOrigin(x, y)
         self._textRenderMode = 0
         self._clipping = 0
@@ -355,13 +366,16 @@
             self._code.append('%d Tr' % mode)
 
     def setRise(self, rise):
-        "Move text baseline up or down to allow superscrip/subscripts"
+        "Move text baseline up or down to allow superscript/subscripts"
         self._rise = rise
         self._y = self._y - rise    # + ?  _textLineMatrix?
         self._code.append('%s Ts' % fp_str(rise))
 
     def _formatText(self, text):
         "Generates PDF text output operator(s)"
+        if log2vis and self.direction in ('LTR','RTL'):
+            # Use pyfribidi to write the text in the correct visual order.
+            text = log2vis(text, directionsMap.get(self.direction.upper(),DIR_ON))
         canv = self._canvas
         font = pdfmetrics.getFont(self._fontname)
         R = []
@@ -433,7 +447,7 @@
         off each line and from the beginning; set trim=0 to preserve
         whitespace."""
         if isStr(stuff):
-            lines = '\n'.split(asUnicode(stuff).strip())
+            lines = asUnicode(stuff).strip().split(u'\n')
             if trim==1:
                 lines = [s.strip() for s in lines]
         elif isinstance(stuff,(tuple,list)):
diff -uNr reportlab-3.1.8/src/reportlab/platypus/doctemplate.py reportlab-3.1.41/src/reportlab/platypus/doctemplate.py
--- reportlab-3.1.8/src/reportlab/platypus/doctemplate.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/doctemplate.py	2014-08-12 20:28:18.716110786 +0900
@@ -291,7 +291,7 @@
 
 def _addGeneratedContent(flowables,frame):
     S = getattr(frame,'_generated_content',None)
-    if S: 
+    if S:
         flowables[0:0] = S
         del frame._generated_content
 
@@ -372,7 +372,7 @@
     First attempt at defining a document template class.
 
     The basic idea is simple.
-    
+
     1)  The document has a list of data associated with it
         this data should derive from flowables. We'll have
         special classes like PageBreak, FrameBreak to do things
@@ -417,7 +417,7 @@
     - bottomMargin:  Margin sizes in points (default 1 inch).  These margins may be
       overridden by the pageTemplates.  They are primarily of interest for the
       SimpleDocumentTemplate subclass.
-    
+
     - allowSplitting:  If set flowables (eg, paragraphs) may be split across frames or pages
       (default: 1)
     - title: Internal title for document (does not automatically display on any page)
@@ -832,7 +832,7 @@
                                 pageCompression=self.pageCompression,
                                 enforceColorSpace=self.enforceColorSpace,
                                 )
- 
+
         getattr(self.canv,'setEncrypt',lambda x: None)(self.encrypt)
 
         self.canv._cropMarks = self.cropMarks
@@ -929,7 +929,14 @@
     def notify(self, kind, stuff):
         """Forward to any listeners"""
         for l in self._indexingFlowables:
-            l.notify(kind, stuff)
+            _canv = getattr(l,'_canv',self)
+            try:
+                if _canv==self:
+                    l._canv = self.canv
+                l.notify(kind, stuff)
+            finally:
+                if _canv==self:
+                    del l._canv
 
     def pageRef(self, label):
         """hook to register a page number"""
@@ -943,7 +950,7 @@
                    ):
         """Makes multiple passes until all indexing flowables
         are happy.
-        
+
         Returns number of passes"""
         self._indexingFlowables = []
         #scan the story and keep a copy
@@ -990,7 +997,7 @@
         del self._multiBuildEdits
         if verbose: print('saved')
         return passes
-        
+
     #these are pure virtuals override in derived classes
     #NB these get called at suitable places by the base class
     #so if you derive and override the handle_xxx methods
diff -uNr reportlab-3.1.8/src/reportlab/platypus/flowables.py reportlab-3.1.41/src/reportlab/platypus/flowables.py
--- reportlab-3.1.8/src/reportlab/platypus/flowables.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/flowables.py	2014-08-12 20:28:18.718110784 +0900
@@ -30,9 +30,10 @@
 from reportlab.lib.rl_accel import fp_str
 from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY
 from reportlab.lib.styles import _baseFontName
+from reportlab.lib.utils import strTypes
 from reportlab.pdfbase import pdfutils
 from reportlab.pdfbase.pdfmetrics import stringWidth
-from reportlab.rl_config import _FUZZ, overlapAttachedSpace, ignoreContainerActions
+from reportlab.rl_config import _FUZZ, overlapAttachedSpace, ignoreContainerActions, listWrapOnFakeWidth
 import collections
 
 __all__=('TraceInfo','Flowable','XBox','Preformatted','Image','Spacer','PageBreak','SlowPageBreak',
@@ -465,7 +466,9 @@
         if a=='_img':
             from reportlab.lib.utils import ImageReader  #this may raise an error
             self._img = ImageReader(self._file)
-            del self._file
+            if not isinstance(self._file,strTypes):
+                self._file = None
+                if self._lazy>=2: self._lazy = 1    #here we're assuming we cannot read again
             return self._img
         elif a in ('drawWidth','drawHeight','imageWidth','imageHeight'):
             self._setup_inner()
@@ -487,7 +490,7 @@
                                 mask=self._mask,
                                 )
         if lazy>=2:
-            self._img = None
+            self._img = self._file = None
             self._lazy = lazy
 
     def identity(self,maxLen=None):
@@ -553,10 +556,12 @@
     def identity(self,maxLen=None):
         return repr(self).replace(')',',frame=%s)'%self._frameName())
 
-def _listWrapOn(F,availWidth,canv,mergeSpace=1,obj=None,dims=None):
+def _listWrapOn(F,availWidth,canv,mergeSpace=1,obj=None,dims=None,fakeWidth=None):
     '''return max width, required height for a list of flowables F'''
     doct = getattr(canv,'_doctemplate',None)
     cframe = getattr(doct,'frame',None)
+    if fakeWidth is None:
+        fakeWidth = listWrapOnFakeWidth
     if cframe:
         from reportlab.platypus.doctemplate import _addGeneratedContent, Indenter
         doct_frame = cframe
@@ -581,7 +586,7 @@
             if cframe:
                 _addGeneratedContent(F,cframe)
             if w<=_FUZZ or h<=_FUZZ: continue
-            W = max(W,min(w,availWidth))
+            W = max(W,min(w,availWidth) if fakeWidth else w)
             H += h
             if not atTop:
                 h = f.getSpaceBefore()
@@ -921,10 +926,10 @@
         n = len(C)
         I2W = {}
         dLeft = dRight = 0
-        for x in range(n):
+        for x in xrange(n):
             c = C[x]
             I = c._ptoinfo
-            if I not in list(I2W.keys()):
+            if I not in I2W.keys():
                 T = I.trailer
                 Hdr = I.header
                 tW, tH = _listWrapOn(T, availWidth, self.canv)
@@ -1029,12 +1034,13 @@
     return max(1./s1, 1./s2)
 
 class KeepInFrame(_Container,Flowable):
-    def __init__(self, maxWidth, maxHeight, content=[], mergeSpace=1, mode='shrink', name='',hAlign='LEFT',vAlign='BOTTOM'):
+    def __init__(self, maxWidth, maxHeight, content=[], mergeSpace=1, mode='shrink', name='',hAlign='LEFT',vAlign='BOTTOM', fakeWidth=None):
         '''mode describes the action to take when overflowing
             error       raise an error in the normal way
             continue    ignore ie just draw it and report maxWidth, maxHeight
             shrink      shrinkToFit
             truncate    fit as much as possible
+            set fakeWidth to False to make _listWrapOn do the 'right' thing
         '''
         self.name = name
         self.maxWidth = maxWidth
@@ -1047,6 +1053,7 @@
         self._content = content or []
         self.vAlign = vAlign
         self.hAlign = hAlign
+        self.fakeWidth = fakeWidth
 
     def _getAvailableWidth(self):
         return self.maxWidth - self._leftExtraIndent - self._rightExtraIndent
@@ -1062,7 +1069,8 @@
         mode = self.mode
         maxWidth = float(min(self.maxWidth or availWidth,availWidth))
         maxHeight = float(min(self.maxHeight or availHeight,availHeight))
-        W, H = _listWrapOn(self._content,maxWidth,self.canv)
+        fakeWidth = self.fakeWidth
+        W, H = _listWrapOn(self._content,maxWidth,self.canv, fakeWidth=fakeWidth)
         if (mode=='error' and (W>maxWidth+_FUZZ or H>maxHeight+_FUZZ)):
             ident = 'content %sx%s too large for %s' % (W,H,self.identity(30))
             #leave to keep apart from the raise
@@ -1075,7 +1083,8 @@
             self.height = min(maxHeight,H)-_FUZZ
         else:
             def func(x):
-                W, H = _listWrapOn(self._content,x*maxWidth,self.canv)
+                x = float(x)
+                W, H = _listWrapOn(self._content,x*maxWidth,self.canv, fakeWidth=fakeWidth)
                 W /= x
                 H /= x
                 return W, H
@@ -1084,7 +1093,7 @@
             s0 = 1
             if W>maxWidth+_FUZZ:
                 #squeeze out the excess width and or Height
-                s1 = W/maxWidth
+                s1 = W/maxWidth     #linear model
                 W, H = func(s1)
                 if H<=maxHeight+_FUZZ:
                     self.width = W-_FUZZ
diff -uNr reportlab-3.1.8/src/reportlab/platypus/frames.py reportlab-3.1.41/src/reportlab/platypus/frames.py
--- reportlab-3.1.8/src/reportlab/platypus/frames.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/frames.py	2014-08-12 20:28:18.718110784 +0900
@@ -11,7 +11,7 @@
 logger = logging.getLogger('reportlab.platypus')
 
 _geomAttr=('x1', 'y1', 'width', 'height', 'leftPadding', 'bottomPadding', 'rightPadding', 'topPadding')
-from reportlab import rl_config
+from reportlab import rl_config, isPy3
 _FUZZ=rl_config._FUZZ
 
 class ShowBoundaryValue:
@@ -19,8 +19,13 @@
         self.color = color
         self.width = width
 
-    def __bool__(self):
-        return self.color is not None and self.width>=0
+    if isPy3:
+        def __bool__(self):
+            return self.color is not None and self.width>=0
+    else:
+        def __nonzero__(self):
+            return self.color is not None and self.width>=0
+
 
 class Frame:
     '''
diff -uNr reportlab-3.1.8/src/reportlab/platypus/para.py reportlab-3.1.41/src/reportlab/platypus/para.py
--- reportlab-3.1.8/src/reportlab/platypus/para.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/para.py	2014-08-12 20:28:18.720110783 +0900
@@ -634,7 +634,7 @@
                    hasattr(this,'width') or hasattr(next,'width'):
                     doswap = 0
                 # only swap two tuples if the second one is an end operation and the first is something else
-                elif isintance(this,tuple):
+                elif isinstance(this,tuple):
                     thisindicator = this[0]
                     if isinstance(next,tuple):
                         nextindicator = next[0]
@@ -868,7 +868,7 @@
     elif text.upper() in ("N", "NO", "FALSE", "0"):
         return 0
     else:
-        raise RMLError("true/false attribute has illegal value '%s'" % text)
+        raise ValueError("true/false attribute has illegal value '%s'" % text)
 
 def readAlignment(text):
     up = text.upper()
@@ -903,7 +903,7 @@
                 'pt':1
                 }[units]
         except KeyError:
-            raise RMLError("invalid length attribute '%s'" % text)
+            raise ValueError("invalid length attribute '%s'" % text)
 
         return number * multiplier
 
diff -uNr reportlab-3.1.8/src/reportlab/platypus/paragraph.py reportlab-3.1.41/src/reportlab/platypus/paragraph.py
--- reportlab-3.1.8/src/reportlab/platypus/paragraph.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/paragraph.py	2014-08-12 20:28:18.722110781 +0900
@@ -585,9 +585,16 @@
                 elif g.text[-1]!=' ': g.text += ' '
     return f
 
-def _drawBullet(canvas, offset, cur_y, bulletText, style):
+def _drawBullet(canvas, offset, cur_y, bulletText, style, rtl):
     '''draw a bullet text could be a simple string or a frag list'''
-    tx2 = canvas.beginText(style.bulletIndent, cur_y+getattr(style,"bulletOffsetY",0))
+    if not rtl:
+        tx2 = canvas.beginText(style.bulletIndent, cur_y+getattr(style,"bulletOffsetY",0))
+    else:
+        bt = bulletText[0].text
+        bulletWidth = stringWidth(bt, style.bulletFontName, style.bulletFontSize)
+        width = rtl[0]
+        bulletStart = width+style.rightIndent-(style.bulletIndent+bulletWidth)
+        tx2 = canvas.beginText(bulletStart, cur_y+getattr(style,"bulletOffsetY",0))
     tx2.setFont(style.bulletFontName, style.bulletFontSize)
     tx2.setFillColor(hasattr(style,'bulletColor') and style.bulletColor or style.textColor)
     if isinstance(bulletText,strTypes):
@@ -599,10 +606,11 @@
             tx2.textOut(f.text)
 
     canvas.drawText(tx2)
-    #AR making definition lists a bit less ugly
-    #bulletEnd = tx2.getX()
-    bulletEnd = tx2.getX() + style.bulletFontSize * 0.6
-    offset = max(offset,bulletEnd - style.leftIndent)
+    if not rtl:
+        #AR making definition lists a bit less ugly
+        #bulletEnd = tx2.getX()
+        bulletEnd = tx2.getX() + style.bulletFontSize * 0.6
+        offset = max(offset,bulletEnd - style.leftIndent)
     return offset
 
 def _handleBulletWidth(bulletText,style,maxWidths):
@@ -616,11 +624,14 @@
             bulletWidth = 0
             for f in bulletText:
                 bulletWidth = bulletWidth + stringWidth(f.text, f.fontName, f.fontSize)
-        bulletRight = style.bulletIndent + bulletWidth + 0.6 * style.bulletFontSize
-        indent = style.leftIndent+style.firstLineIndent
-        if bulletRight > indent:
+        bulletLen = style.bulletIndent + bulletWidth + 0.6 * style.bulletFontSize
+        if style.wordWrap=='RTL':
+            indent = style.rightIndent+style.firstLineIndent
+        else:
+            indent = style.leftIndent+style.firstLineIndent
+        if bulletLen > indent:
             #..then it overruns, and we have less space available on line 1
-            maxWidths[0] -= (bulletRight - indent)
+            maxWidths[0] -= (bulletLen - indent)
 
 def splitLines0(frags,widths):
     '''
@@ -1027,12 +1038,13 @@
         leftIndent = style.leftIndent
         first_line_width = availWidth - (leftIndent+style.firstLineIndent) - style.rightIndent
         later_widths = availWidth - leftIndent - style.rightIndent
+        self._wrapWidths = [first_line_width, later_widths]
 
         if style.wordWrap == 'CJK':
             #use Asian text wrap algorithm to break characters
-            blPara = self.breakLinesCJK([first_line_width, later_widths])
+            blPara = self.breakLinesCJK(self._wrapWidths)
         else:
-            blPara = self.breakLines([first_line_width, later_widths])
+            blPara = self.breakLines(self._wrapWidths)
         self.blPara = blPara
         autoLeading = getattr(self,'autoLeading',getattr(style,'autoLeading',''))
         leading = style.leading
@@ -1555,7 +1567,7 @@
                 else:
                     cur_y = self.height - getattr(f,'ascent',f.fontSize)
                 if bulletText:
-                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style)
+                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style,rtl=style.wordWrap=='RTL' and self._wrapWidths or False)
 
                 #set up the font etc.
                 canvas.setFillColor(f.textColor)
@@ -1566,6 +1578,9 @@
                 elif autoLeading=='min':
                     leading = blPara.ascent-blPara.descent
 
+                # set the paragraph direction
+                tx.direction = self.style.wordWrap
+
                 #now the font for the rest of the paragraph
                 tx.setFont(f.fontName, f.fontSize, leading)
                 ws = lines[0][0]
@@ -1609,6 +1624,9 @@
                     for i in range(1, nLines):
                         dpl( tx, _offsets[i], lines[i][0], lines[i][1], noJustifyLast and i==lim)
             else:
+                if self.style.wordWrap == 'RTL':
+                    for line in lines:
+                        line.words = line.words[::-1]
                 f = lines[0]
                 if rl_config.paraFontSizeHeightOffset:
                     cur_y = self.height - f.fontSize
@@ -1618,7 +1636,7 @@
                 dpl = _leftDrawParaLineX
                 if bulletText:
                     oo = offset
-                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style)
+                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style, rtl=style.wordWrap=='RTL' and self._wrapWidths or False)
                 if alignment == TA_LEFT:
                     dpl = _leftDrawParaLineX
                 elif alignment == TA_CENTER:
@@ -1632,6 +1650,9 @@
 
                 #set up the font etc.
                 tx = self.beginText(cur_x, cur_y)
+                # set the paragraph direction
+                tx.direction = self.style.wordWrap
+
                 xs = tx.XtraState=ABag()
                 xs.textColor=None
                 xs.backColor=None
@@ -1659,7 +1680,7 @@
                 _do_post_text(tx)
 
                 #now the middle of the paragraph, aligned with the left margin which is our origin.
-                for i in range(1, nLines):
+                for i in xrange(1, nLines):
                     f = lines[i]
                     dpl( tx, _offsets[i], f, noJustifyLast and i==lim)
                     _do_post_text(tx)
diff -uNr reportlab-3.1.8/src/reportlab/platypus/paraparser.py reportlab-3.1.41/src/reportlab/platypus/paraparser.py
--- reportlab-3.1.8/src/reportlab/platypus/paraparser.py	2014-04-22 21:33:42.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/paraparser.py	2014-08-12 20:28:18.723110780 +0900
@@ -596,52 +596,51 @@
 
     #### bold
     def start_b( self, attributes ):
-        self._push(bold=1)
+        self._push('b',bold=1)
 
     def end_b( self ):
-        self._pop(bold=1)
+        self._pop('b')
 
     def start_strong( self, attributes ):
-        self._push(bold=1)
+        self._push('strong',bold=1)
 
     def end_strong( self ):
-        self._pop(bold=1)
+        self._pop('strong')
 
     #### italics
     def start_i( self, attributes ):
-        self._push(italic=1)
+        self._push('i',italic=1)
 
     def end_i( self ):
-        self._pop(italic=1)
+        self._pop('i')
 
     def start_em( self, attributes ):
-        self._push(italic=1)
+        self._push('em', italic=1)
 
     def end_em( self ):
-        self._pop(italic=1)
+        self._pop('em')
 
     #### underline
     def start_u( self, attributes ):
-        self._push(underline=1)
+        self._push('u',underline=1)
 
     def end_u( self ):
-        self._pop(underline=1)
+        self._pop('u')
 
     #### strike
     def start_strike( self, attributes ):
-        self._push(strike=1)
+        self._push('strike',strike=1)
 
     def end_strike( self ):
-        self._pop(strike=1)
+        self._pop('strike')
 
     #### link
     def start_link(self, attributes):
-        self._push(**self.getAttributes(attributes,_linkAttrMap))
+        self._push('link',**self.getAttributes(attributes,_linkAttrMap))
 
     def end_link(self):
-        frag = self._stack[-1]
-        del self._stack[-1]
-        assert frag.link!=None
+        if self._pop('link').link is None:
+            raise ValueError('<link> has no target or href')
 
     #### anchor
     def start_a(self, attributes):
@@ -659,33 +658,35 @@
             href = A.get('href','').strip()
             A['link'] = href    #convert to our link form
             A.pop('href',None)
-        self._push(**A)
+        self._push('a',**A)
 
     def end_a(self):
         frag = self._stack[-1]
         sct = getattr(frag,'_selfClosingTag','')
         if sct:
-            assert sct=='anchor' and frag.name,'Parser failure in <a/>'
+            if not (sct=='anchor' and frag.name):
+                raise ValueError('Parser failure in <a/>')
             defn = frag.cbDefn = ABag()
             defn.label = defn.kind = 'anchor'
             defn.name = frag.name
             del frag.name, frag._selfClosingTag
             self.handle_data('')
-            self._pop()
+            self._pop('a')
         else:
-            del self._stack[-1]
-            assert frag.link!=None
+            if self._pop('a').link is None:
+                raise ValueError('<link> has no href')
 
     def start_img(self,attributes):
         A = self.getAttributes(attributes,_imgAttrMap)
         if not A.get('src'):
             self._syntax_error('<img> needs src attribute')
         A['_selfClosingTag'] = 'img'
-        self._push(**A)
+        self._push('img',**A)
 
     def end_img(self):
         frag = self._stack[-1]
-        assert getattr(frag,'_selfClosingTag',''),'Parser failure in <img/>'
+        if not getattr(frag,'_selfClosingTag',''):
+            raise ValueError('Parser failure in <img/>')
         defn = frag.cbDefn = ABag()
         defn.kind = 'img'
         defn.src = getattr(frag,'src',None)
@@ -696,24 +697,27 @@
         defn.valign = getattr(frag,'valign','bottom')
         del frag._selfClosingTag
         self.handle_data('')
-        self._pop()
+        self._pop('img')
 
     #### super script
     def start_super( self, attributes ):
-        self._push(super=1)
+        self._push('super',super=1)
 
     def end_super( self ):
-        self._pop(super=1)
+        self._pop('super')
+
+    def start_sup( self, attributes ):
+        self._push('sup',super=1)
 
-    start_sup = start_super
-    end_sup = end_super
+    def end_sup( self ):
+        self._pop('sup')
 
     #### sub script
     def start_sub( self, attributes ):
-        self._push(sub=1)
+        self._push('sub',sub=1)
 
     def end_sub( self ):
-        self._pop(sub=1)
+        self._pop('sub')
 
     #### greek script
     #### add symbol encoding
@@ -736,10 +740,10 @@
         self.errors.append(message)
 
     def start_greek(self, attr):
-        self._push(greek=1)
+        self._push('greek',greek=1)
 
     def end_greek(self):
-        self._pop(greek=1)
+        self._pop('greek')
 
     def start_unichar(self, attr):
         if 'name' in attr:
@@ -748,7 +752,7 @@
             try:
                 v = unicodedata.lookup(attr['name'])
             except KeyError:
-                self._syntax_error('<unichar/> invalid name attribute\n"%s"' % ascii(name))
+                self._syntax_error('<unichar/> invalid name attribute\n"%s"' % ascii(attr['name']))
                 v = '\0'
         elif 'code' in attr:
             try:
@@ -764,16 +768,19 @@
 
         if v is not None:
             self.handle_data(v)
-        self._push(_selfClosingTag='unichar')
+        self._push('unichar',_selfClosingTag='unichar')
 
     def end_unichar(self):
-        self._pop()
+        self._pop('unichar')
 
     def start_font(self,attr):
-        self._push(**self.getAttributes(attr,_fontAttrMap))
+        A = self.getAttributes(attr,_spanAttrMap)
+        if 'fontName' in A:
+            A['fontName'], A['bold'], A['italic'] = ps2tt(A['fontName'])
+        self._push('font',**A)
 
     def end_font(self):
-        self._pop()
+        self._pop('font')
 
     def start_span(self,attr):
         A = self.getAttributes(attr,_spanAttrMap)
@@ -786,20 +793,24 @@
                 D[k] = v
             D.update(A)
             A = D
-        self._push(**A)
+        if 'fontName' in A:
+            A['fontName'], A['bold'], A['italic'] = ps2tt(A['fontName'])
+        self._push('span',**A)
 
-    end_span = end_font
+    def end_span(self):
+        self._pop('span')
 
     def start_br(self, attr):
-        self._push(_selfClosingTag='br',lineBreak=True,text='')
+        self._push('br',_selfClosingTag='br',lineBreak=True,text='')
         
     def end_br(self):
         #print('\nend_br called, %d frags in list' % len(self.fragList))
         frag = self._stack[-1]
-        assert frag._selfClosingTag=='br' and frag.lineBreak,'Parser failure in <br/>'
+        if not (frag._selfClosingTag=='br' and frag.lineBreak):
+                raise ValueError('Parser failure in <br/>')
         del frag._selfClosingTag
         self.handle_data('')
-        self._pop()
+        self._pop('br')
 
     def _initial_frag(self,attr,attrMap,bullet=0):
         style = self._style
@@ -828,10 +839,12 @@
         return frag
 
     def start_para(self,attr):
-        self._stack = [self._initial_frag(attr,_paraAttrMap)]
+        frag = self._initial_frag(attr,_paraAttrMap)
+        frag.__tag__ = 'para'
+        self._stack = [frag]
 
     def end_para(self):
-        self._pop()
+        self._pop('para')
 
     def start_bullet(self,attr):
         if hasattr(self,'bFragList'):
@@ -839,10 +852,11 @@
         self.bFragList = []
         frag = self._initial_frag(attr,_bulletAttrMap,1)
         frag.isBullet = 1
+        frag.__tag__ = 'bullet'
         self._stack.append(frag)
 
     def end_bullet(self):
-        self._pop()
+        self._pop('bullet')
 
     #---------------------------------------------------------------
     def start_seqdefault(self, attr):
@@ -938,9 +952,9 @@
 
         if 'label' in attr: defn.label = attr['label']
         defn.kind='onDraw'
-        self._push(cbDefn=defn)
+        self._push('ondraw',cbDefn=defn)
         self.handle_data('')
-        self._pop()
+        self._pop('ondraw')
     start_onDraw=start_ondraw 
     end_onDraw=end_ondraw=end_seq
 
@@ -967,9 +981,9 @@
         defn.label = encode_label((label,format,offset))
         defn.name = name
         defn.kind='index'
-        self._push(cbDefn=defn)
+        self._push('index',cbDefn=defn)
         self.handle_data('')
-        self._pop()
+        self._pop('index',)
     end_index=end_seq
 
     def start_unknown(self,attr):
@@ -977,17 +991,16 @@
     end_unknown=end_seq
 
     #---------------------------------------------------------------
-    def _push(self,**attr):
+    def _push(self,tag,**attr):
         frag = copy.copy(self._stack[-1])
+        frag.__tag__ = tag
         _applyAttributes(frag,attr)
         self._stack.append(frag)
 
-    def _pop(self,**kw):
-        frag = self._stack[-1]
-        del self._stack[-1]
-        for k, v in kw.items():
-            assert getattr(frag,k)==v
-        return frag
+    def _pop(self,tag):
+        frag = self._stack.pop()
+        if tag==frag.__tag__: return frag
+        raise ValueError('Parse error: saw </%s> instead of expected </%s>' % (tag,frag.__tag__))
 
     def getAttributes(self,attr,attrMap):
         A = {}
@@ -1148,7 +1161,7 @@
         try:
             self.feed(text)
         except:
-            annotateException('paragraph text %s caused exception' % ascii(text))
+            annotateException('\nparagraph text %s caused exception' % ascii(text))
         return self._complete_parse()
 
     def handle_starttag(self, tag, attrs):
diff -uNr reportlab-3.1.8/src/reportlab/platypus/tableofcontents.py reportlab-3.1.41/src/reportlab/platypus/tableofcontents.py
--- reportlab-3.1.8/src/reportlab/platypus/tableofcontents.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/tableofcontents.py	2014-08-12 20:28:18.724110780 +0900
@@ -74,13 +74,12 @@
     If dot is a string, pagestr is drawn right-aligned. If the string is not empty,
     the gap is filled with it.
     '''
-    pages.sort()
     pagestr = ', '.join([str(p) for p, _ in pages])
     x, y = canvas._curr_tx_info['cur_x'], canvas._curr_tx_info['cur_y']
-    
+
     fontSize = style.fontSize
     pagestrw = stringWidth(pagestr, style.fontName, fontSize)
-    
+
     #if it's too long to fit, we need to shrink to fit in 10% increments.
     #it would be very hard to output multiline entries.
     #however, we impose a minimum size of 1 point as we don't want an
@@ -90,8 +89,8 @@
     while pagestrw > freeWidth and fontSize >= 1.0:
         fontSize = 0.9 * fontSize
         pagestrw = stringWidth(pagestr, style.fontName, fontSize)
-        
-    
+
+
     if isinstance(dot, strTypes):
         if dot:
             dotw = stringWidth(dot, style.fontName, fontSize)
@@ -313,7 +312,7 @@
     def setup(self, style=None, dot=None, tableStyle=None, headers=True, name=None, format='123', offset=0):
         """
         This method makes it possible to change styling and other parameters on an existing object.
-        
+
         style is the paragraph style to use for index entries.
         dot can either be None or a string. If it's None, entries are immediatly followed by their
             corresponding page numbers. If it's a string, page numbers are aligned on the right side
@@ -321,16 +320,16 @@
         tableStyle is the style used by the table which the index uses to draw itself. Use this to
             change properties like spacing between elements.
         headers is a boolean. If it is True, alphabetic headers are displayed in the Index when the first
-        letter changes. If False, we just output some extra space before the next item 
+        letter changes. If False, we just output some extra space before the next item
         name makes it possible to use several indexes in one document. If you want this use this
             parameter to give each index a unique name. You can then index a term by refering to the
             name of the index which it should appear in:
-            
+
                 <index item="term" name="myindex" />
 
         format can be 'I', 'i', '123',  'ABC', 'abc'
         """
-        
+
         if style is None:
             style = ParagraphStyle(name='index',
                                         fontName=_baseFontName,
@@ -359,12 +358,13 @@
             offset = self.offset
 
         terms = commasplit(terms)
-        pns = formatFunc(canv.getPageNumber()-offset)
+        cPN = canv.getPageNumber()
+        pns = formatFunc(cPN-offset)
         key = 'ix_%s_%s_p_%s' % (self.name, label, pns)
 
         info = canv._curr_tx_info
         canv.bookmarkHorizontal(key, info['cur_x'], info['cur_y'] + info['leading'])
-        self.addEntry(terms, pns, key)
+        self.addEntry(terms, (cPN,pns), key)
 
     def getCanvasMaker(self, canvasmaker=canvas.Canvas):
 
@@ -396,8 +396,8 @@
         Here we are interested in 'IndexEntry' events only.
         """
         if kind == 'IndexEntry':
-            (text, pageNum) = stuff
-            self.addEntry(text, pageNum)
+            text, pageNum = stuff
+            self.addEntry(text, (self._canv.getPageNumber(),pageNum))
 
     def addEntry(self, text, pageNum, key=None):
         """Allows incremental buildup"""
@@ -429,7 +429,7 @@
         def drawIndexEntryEnd(canvas, kind, label):
             '''Callback to draw dots and page numbers after each entry.'''
             style = self.getLevelStyle(leveloffset)
-            pages = decode_label(label)
+            pages = [(p[1],k) for p,k in sorted(decode_label(label))]
             drawPageNumbers(canvas, style, pages, availWidth, availHeight, self.dot)
         self.canv.drawIndexEntryEnd = drawIndexEntryEnd
 
@@ -453,7 +453,7 @@
                 tableData.append([Paragraph(header, alphaStyle),])
                 tableData.append([Spacer(1, alphaStyle.spaceAfter),])
 
-                    
+
             i, diff = listdiff(lastTexts, texts)
             if diff:
                 lastTexts = texts
@@ -461,11 +461,11 @@
             label = encode_label(list(pageNumbers))
             texts[-1] = '%s<onDraw name="drawIndexEntryEnd" label="%s"/>' % (texts[-1], label)
             for text in texts:
-                #Platypus and RML differ on how parsed XML attributes are escaped.  
+                #Platypus and RML differ on how parsed XML attributes are escaped.
                 #e.g. <index item="M&S"/>.  The only place this seems to bite us is in
                 #the index entries so work around it here.
-                text = escapeOnce(text)    
-                
+                text = escapeOnce(text)
+
                 style = self.getLevelStyle(i+leveloffset)
                 para = Paragraph(text, style)
                 if style.spaceBefore:
@@ -551,5 +551,3 @@
 
     def drawOn(self, canvas, x, y, _sW=0):
         self._para.drawOn(canvas, x, y, _sW)
-
-
diff -uNr reportlab-3.1.8/src/reportlab/platypus/xpreformatted.py reportlab-3.1.41/src/reportlab/platypus/xpreformatted.py
--- reportlab-3.1.8/src/reportlab/platypus/xpreformatted.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/platypus/xpreformatted.py	2014-08-12 20:28:18.726110778 +0900
@@ -247,6 +247,7 @@
         return fontifiedCode
 
 if __name__=='__main__':    #NORUNTESTS
+    import sys
     def dumpXPreformattedLines(P):
         print('\n############dumpXPreforemattedLines(%s)' % str(P))
         lines = P.blPara.lines
diff -uNr reportlab-3.1.8/src/reportlab/rl_config.py reportlab-3.1.41/src/reportlab/rl_config.py
--- reportlab-3.1.8/src/reportlab/rl_config.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/rl_config.py	2014-08-12 20:28:18.727110778 +0900
@@ -30,9 +30,14 @@
     except ImportError:
         _overrides=_DEFAULTS.copy()
         try:
-            with open(os.path.expanduser(os.path.join('~','.reportlab_settings')),'rb') as f:
-                rl_exec(f.read(),_overrides)
-            _DEFAULTS.update(_overrides)
+            try:
+                fn = os.path.expanduser(os.path.join('~','.reportlab_settings'))    #appengine fails with ImportError
+            except ImportError:
+                fn = None
+            if fn:
+                with open(fn,'rb') as f:
+                    rl_exec(f.read(),_overrides)
+                _DEFAULTS.update(_overrides)
         except:
             pass
     return _DEFAULTS
@@ -89,7 +94,11 @@
             P=[]
             for p in _SAVED[k]:
                 d = (p % D).replace('/',os.sep)
-                if '~' in d: d = os.path.expanduser(d)
+                if '~' in d:
+                    try:
+                        d = os.path.expanduser(d)   #appengine fails with ImportError
+                    except ImportError:
+                        continue
                 if rl_isdir(d): P.append(d)
             _setOpt(k,os.pathsep.join(P),lambda x:x.split(os.pathsep))
             globals()[k] = list(filter(rl_isdir,globals()[k]))
diff -uNr reportlab-3.1.8/src/reportlab/rl_settings.py reportlab-3.1.41/src/reportlab/rl_settings.py
--- reportlab-3.1.8/src/reportlab/rl_settings.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/reportlab/rl_settings.py	2014-08-12 20:28:18.727110778 +0900
@@ -43,6 +43,8 @@
 pdfMultiLine
 pdfComments
 debug
+rtlSupport
+listWrapOnFakeWidth
 T1SearchPath
 TTFSearchPath
 CMapSearchPath'''.split())
@@ -92,6 +94,9 @@
 pdfMultiLine=               0                       #use more lines in pdf etc
 pdfComments=                0                       #put in pdf comments
 debug=                      0                       #for debugging code
+rtlSupport=                 0                       #set to 1 to attempt import of RTL assistance eg fribidi etc etc
+listWrapOnFakeWidth=        1                       #set to 0/False to force platypus.flowables._listWrapOn to report correct widths
+                                                    #else it reports minimum(required,available) width
 
 # places to look for T1Font information
 T1SearchPath =  (
@@ -114,6 +119,7 @@
                 '/usr/local/Acrobat6/Resource/Font',    #Linux, Acrobat 5?
                 '/usr/local/Acrobat5/Resource/Font',    #Linux, Acrobat 5?
                 '/usr/local/Acrobat4/Resource/Font',    #Linux, Acrobat 4
+                '/usr/share/fonts/default/Type1',       #Linux, Fedora
                 '%(REPORTLAB_DIR)s/fonts',              #special
                 '%(REPORTLAB_DIR)s/../fonts',           #special
                 '%(REPORTLAB_DIR)s/../../fonts',        #special
@@ -130,6 +136,8 @@
                 'c:/windows/fonts',
                 '/usr/lib/X11/fonts/TrueType/',
                 '/usr/share/fonts/truetype',
+                '/usr/share/fonts',             #Linux, Fedora
+                '/usr/share/fonts/dejavu',      #Linux, Fedora
                 '%(REPORTLAB_DIR)s/fonts',      #special
                 '%(REPORTLAB_DIR)s/../fonts',   #special
                 '%(REPORTLAB_DIR)s/../../fonts',#special
diff -uNr reportlab-3.1.8/src/rl_addons/renderPM/_renderPM.c reportlab-3.1.41/src/rl_addons/renderPM/_renderPM.c
--- reportlab-3.1.8/src/rl_addons/renderPM/_renderPM.c	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/src/rl_addons/renderPM/_renderPM.c	2014-08-12 20:28:18.728110777 +0900
@@ -18,7 +18,7 @@
 #endif
 
 
-#define VERSION "2.00"
+#define VERSION "2.01"
 #define MODULENAME "_renderPM"
 #ifdef isPy3
 #	define PyInt_FromLong	PyLong_FromLong
@@ -1262,19 +1262,19 @@
 
 static PyObject* gstate__aapixbuf(gstateObject* self, PyObject* args)
 {
-	int			dstX, dstY, dstW, dstH, srclen;
-	double		ctm[6];
+	int			srclen;
+	double		ctm[6], dstX, dstY, dstW, dstH;
 	ArtPixBuf	src;
 
 	src.n_channels = 3;
 
 	/*(dstX,dstY,dstW,dstH,src,srcW,srcH[,srcD[,aff]])*/
-	if(!PyArg_ParseTuple(args,"iiiit#ii|i:_aapixbuf",
+	if(!PyArg_ParseTuple(args,"ddddt#ii|i:_aapixbuf",
 				&dstX, &dstY, &dstW, &dstH,
 				&src.pixels,&srclen,&src.width,&src.height,&src.n_channels)) return NULL;
-	ctm[0] = ((float)dstW)/src.width;
+	ctm[0] = dstW/src.width;
 	ctm[1] = ctm[2] = 0;
-	ctm[3] = -((float)dstH)/src.height;
+	ctm[3] = -dstH/src.height;
 	ctm[4] = dstX;
 	ctm[5] = dstY+dstH;
 	art_affine_multiply(ctm,ctm,self->ctm);
バイナリーファイル reportlab-3.1.8/tests/test-cross.tiff とreportlab-3.1.41/tests/test-cross.tiff は異なります
バイナリーファイル reportlab-3.1.8/tests/test-indexed.png とreportlab-3.1.41/tests/test-indexed.png は異なります
バイナリーファイル reportlab-3.1.8/tests/test-rgba.png とreportlab-3.1.41/tests/test-rgba.png は異なります
diff -uNr reportlab-3.1.8/tests/test_graphics_barcode.py reportlab-3.1.41/tests/test_graphics_barcode.py
--- reportlab-3.1.8/tests/test_graphics_barcode.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_graphics_barcode.py	2014-08-12 20:28:18.704110795 +0900
@@ -28,7 +28,8 @@
         CN = list(getCodes().items())
         for name,C in CN:
             i = C()
-            D = Drawing(100,50)
+            x0,y0,x1,y1 = i.getBounds()
+            D = Drawing(x1-x0,y1-y0)
             D.add(i)
             D.save(formats=formats,outDir=outDir,fnRoot=name)
             a('<h2>%s</h2><img src="%s.gif"><br>' % (name, name))
diff -uNr reportlab-3.1.8/tests/test_lib_utils.py reportlab-3.1.41/tests/test_lib_utils.py
--- reportlab-3.1.8/tests/test_lib_utils.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_lib_utils.py	2014-08-12 20:28:18.709110792 +0900
@@ -122,6 +122,15 @@
         b = getBytesIO(_rel_open_and_read('../docs/images/Edit_Prefs.gif'))
         b = open_and_read(b)
 
+    def test11(self):
+        "test open and read of an RFC 2397 data URI with base64 encoding"
+        result = _rel_open_and_read('data:image/gif;base64,R0lGODdhAQABAIAAAP///////ywAAAAAAQABAAACAkQBADs=')
+        self.assertEquals(result,b'GIF87a\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\xff\xff\xff,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;')
+
+    def test12(self):
+        "test open and read of an RFC 2397 data URI without an encoding"
+        result = _rel_open_and_read('data:text/plain;,Hello%20World')
+        self.assertEquals(result,b'Hello World')
 
     def testRecursiveImportErrors(self):
         "check we get useful error messages"
diff -uNr reportlab-3.1.8/tests/test_paragraphs.py reportlab-3.1.41/tests/test_paragraphs.py
--- reportlab-3.1.8/tests/test_paragraphs.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_paragraphs.py	2014-08-12 20:28:18.712110789 +0900
@@ -5,14 +5,17 @@
 from reportlab.lib.testutils import setOutDir,makeSuiteForClasses, outputfile, printLocation
 setOutDir(__name__)
 import unittest
-from reportlab.platypus import Paragraph, SimpleDocTemplate, XBox, Indenter, XPreformatted, PageBreak
+from reportlab.platypus import Paragraph, SimpleDocTemplate, XBox, Indenter, XPreformatted, PageBreak, Spacer
 from reportlab.lib.styles import ParagraphStyle
 from reportlab.lib.units import inch
 from reportlab.lib.abag import ABag
 from reportlab.lib.colors import red, black, navy, white, green
 from reportlab.lib.randomtext import randomText
 from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
-from reportlab.rl_config import defaultPageSize
+from reportlab.rl_config import defaultPageSize, rtlSupport
+from reportlab.pdfbase import ttfonts
+from reportlab.pdfbase import pdfmetrics
+from reportlab.lib.fonts import addMapping, tt2ps
 
 (PAGE_WIDTH, PAGE_HEIGHT) = defaultPageSize
 
@@ -27,7 +30,6 @@
     canvas.drawString(4 * inch, 0.75 * inch, "First Page")
     canvas.restoreState()
 
-
 def myLaterPages(canvas, doc):
     canvas.saveState()
     canvas.setStrokeColor(red)
@@ -37,6 +39,33 @@
     canvas.drawString(4 * inch, 0.75 * inch, "Page %d" % doc.page)
     canvas.restoreState()
 
+def getAFont():
+    '''register a font that supports most Unicode characters'''
+    I = []
+    font_name = 'DejaVuSans'
+    I.append([(font_name, 0, 0, font_name),
+                 (font_name, 1, 0, font_name + '-Bold'),
+                 (font_name, 0, 1, font_name + '-Oblique'),
+                 (font_name, 1, 1, font_name + '-BoldOblique'),
+                 ])
+    font_name = 'FreeSerif'
+    I.append([(font_name, 0, 0, font_name),
+                 (font_name, 1, 0, font_name + 'Bold'),
+                 (font_name, 0, 1, font_name + 'Italic'),
+                 (font_name, 1, 1, font_name + 'BoldItalic'),
+                 ])
+    for info in I:
+        n = 0
+        for font in info:
+            fontName = font[3]
+            try:
+                pdfmetrics.registerFont(ttfonts.TTFont(fontName,fontName + '.ttf'))
+                addMapping(*font)
+                n += 1
+            except:
+                pass
+        if n==4: return font[0]
+    raise ValueError('could not find suitable font')
 
 class ParagraphTestCase(unittest.TestCase):
     "Test Paragraph class (eyeball-test)."
@@ -92,7 +121,6 @@
                                    spaceBefore=12,
                                    spaceAfter=12)
 
-
         SA(Paragraph("This is a normal paragraph. "+ randomText(), styNormal))
         SA(Paragraph("There follows a paragraph with only \"&lt;br/&gt;\"", styNormal))
         SA(Paragraph("<br/>", styNormal))
@@ -215,12 +243,192 @@
                                      showBoundary=1)
         template.build(story,
             onFirstPage=myFirstPage, onLaterPages=myLaterPages)
-
+    
+    if rtlSupport:
+        def testBidi(self):
+            fontName = getAFont()
+
+            # create styles based on the registered font
+            stySTD = ParagraphStyle('STD', fontName = fontName)
+            styRJ = ParagraphStyle('RJ', parent=stySTD, alignment=TA_RIGHT)
+            styLTR = ParagraphStyle('LTR', parent=stySTD, wordWrap='LTR')
+            styRTL = ParagraphStyle('RTL', parent = stySTD, alignment = TA_RIGHT,
+                                    wordWrap = 'RTL', spaceAfter = 12)
+
+            # strings for testing Normal & LTR styles
+            ltrStrings = [# English followed by Arabic.
+                          b'English followed by \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a.',
+                          # English with Arabic in the middle
+                          b'English with \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a in the middle.',
+                          # English symbols (!@#$%^&*) Arabic
+                          b'English symbols (!@#$%^&*) \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a.',
+                          # ((testing integers in LTR)) 
+                          b'123 LTR 123 Integers 123.',
+                          # ((testing decimals in LTR))
+                          b'456.78 LTR 456.78 Decimals 456.78.',
+                          # Long English text with RTL script in the middle, splitting over multiple lines
+                          b'Long \xd8\xb7\xd9\x88\xd9\x8a\xd9\x84 English text'
+                              b' \xd9\x86\xd8\xb5 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a with RTL script'
+                              b' \xd9\x83\xd8\xaa\xd8\xa7\xd8\xa8\xd8\xa9 \xd9\x85\xd9\x86'
+                              b' \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86 \xd8\xa5\xd9\x84\xd9\x89'
+                              b' \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1 in the middle,'
+                              b' \xd9\x81\xd9\x8a \xd8\xa7\xd9\x84\xd9\x88\xd8\xb3\xd8\xb7\xd8\x8c'
+                              b' splitting \xd9\x85\xd9\x82\xd8\xb3\xd9\x85 over \xd8\xb9\xd9\x84\xd9\x89'
+                              b' multiple lines \xd8\xb9\xd8\xaf\xd8\xa9 \xd8\xb3\xd8\xb7\xd9\x88\xd8\xb1.',
+                          ]
+
+            # strings for testing RTL
+            rtlStrings = [# Arabic followed by English
+                          b'\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd9\x85\xd8\xaa\xd8\xa8\xd9\x88\xd8\xb9'
+                              b' \xd8\xa8\xd9\x80 English.',
+                          # Arabic with English in the middle
+                          b'\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd9\x85\xd8\xb9 English \xd9\x81\xd9\x8a'
+                              b' \xd8\xa7\xd9\x84\xd9\x85\xd9\x86\xd8\xaa\xd8\xb5\xd9\x81.',
+                          # Arabic symbols (!@##$%^&*) English
+                          b'\xd8\xb1\xd9\x85\xd9\x88\xd8\xb2 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9'
+                              b' (!@#$%^&*) English.',
+                          # 123 from right to left 123 integer numbers 123. ((testing integers in RTL))
+                          b'123 \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' 123 \xd8\xa3\xd8\xb1\xd9\x82\xd8\xa7\xd9\x85'
+                              b' \xd8\xb5\xd8\xad\xd9\x8a\xd8\xad\xd8\xa9 123.',
+                          # 456.78 from right to left 456.78 decimal numbers 456.78. ((testing decimals in RTL))
+                          b'456.78 \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' 456.78 \xd8\xa3\xd8\xb1\xd9\x82\xd8\xa7\xd9\x85'
+                              b' \xd8\xb9\xd8\xb4\xd8\xb1\xd9\x8a\xd8\xa9 456.78.',
+                          # Long Arabic text with LTR text in the middle, splitting over multiple lines
+                          b'\xd9\x86\xd8\xb5 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd8\xb7\xd9\x88\xd9\x8a\xd9\x84'
+                              b' Long Arabic text \xd9\x85\xd8\xb9 with \xd9\x83\xd8\xaa\xd8\xa7\xd8\xa8\xd8\xa9'
+                              b' \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' LTR script \xd9\x81\xd9\x8a \xd8\xa7\xd9\x84\xd9\x88\xd8\xb3\xd8\xb7\xd8\x8c'
+                              b' in the middle, \xd9\x85\xd9\x82\xd8\xb3\xd9\x85 splitted'
+                              b' \xd8\xb9\xd9\x84\xd9\x89 over \xd8\xb9\xd8\xaf\xd8\xa9'
+                              b' \xd8\xb3\xd8\xb7\xd9\x88\xd8\xb1 multiple lines.'
+                          ]
+
+            assert len(ltrStrings) == len(rtlStrings)
+            n = len(ltrStrings)
+            
+            # create a store to be printed
+            story = []
+            
+            story.append(Paragraph("<b><i>Following pairs of left justified texts have style.wordWrap=None &amp; 'LTR'.</i></b><br/>",stySTD))
+            # write every LTR string and its corresponding RTL string to be matched.
+            for i in xrange(n):
+                story.append(Paragraph(ltrStrings[i], stySTD))
+                story.append(Paragraph(ltrStrings[i], styLTR))
+
+            story.append(Paragraph("<br/><b><i>Following pairs of right justfied texts have style.wordWrap=None &amp; 'RTL'.</i></b><br/>",stySTD))
+            for i in xrange(n):
+                story.append(Paragraph(rtlStrings[i], styRJ))
+                story.append(Paragraph(rtlStrings[i], styRTL))
+
+            story.append(Paragraph("<b><i><br/>Following texts have style.wordWrap='RTL'</i></b>",stySTD))
+            # a few additional scripts for testing.
+            story.append(
+                Paragraph(b'\xd9\x87\xd8\xb0\xd9\x87 \xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd8\xb9\xd8\xa7\xd8\xaf\xd9\x8a\xd8\xa9. ', styRTL))
+            story.append(
+                Paragraph(b'\xd9\x87\xd8\xb0\xd9\x87 \xd8\xa7\xd9\x84\xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd9\x84\xd8\xaf\xd9\x8a\xd9\x87\xd8\xa7 12'
+                              b' \xd9\x86\xd9\x82\xd8\xb7\xd8\xa9 \xd9\x82\xd8\xa8\xd9\x84\xd9\x87\xd8\xa7'
+                              b' \xd9\x88\xd8\xa8\xd8\xb9\xd8\xaf\xd9\x87\xd8\xa7. ', styRTL))
+            story.append(
+                Paragraph(b'<para spacebefore="12" spaceafter="12">'
+                              b'\xd9\x87\xd8\xb0\xd9\x87 \xd8\xa7\xd9\x84\xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd9\x84\xd8\xaf\xd9\x8a\xd9\x87\xd8\xa7 12 \xd9\x86\xd9\x82\xd8\xb7\xd8\xa9'
+                              b' \xd9\x82\xd8\xa8\xd9\x84\xd9\x87\xd8\xa7'
+                              b' \xd9\x88\xd8\xa8\xd8\xb9\xd8\xaf\xd9\x87\xd8\xa7\xd8\x8c'
+                              b' \xd9\x85\xd8\xad\xd8\xaf\xd8\xaf\xd8\xa9 \xd8\xa8\xd9\x80 XML.'
+                              b' \xd8\xa5\xd9\x86\xd9\x87\xd8\xa7 \xd8\xaa\xd8\xb9\xd9\x85\xd9\x84'
+                              b' \xd8\xa3\xd9\x8a\xd8\xb6\xd8\xa7! \xd9\x80.'
+                              b'</para>',
+                          styRTL))
+
+            # TODO: add more RTL scripts to the test (Farsi, Hebrew, etc.)
+
+            template = SimpleDocTemplate(outputfile('test_paragraphs_bidi.pdf'))
+            template.build(story)
+
+        def testRTLBullets(self):
+            try:
+                import mwlib.ext
+            except ImportError:
+                pass
+
+            font_name = getAFont()
+            doc = SimpleDocTemplate(outputfile('test_rtl_bullets.pdf'),showBoundary=True)
+            p_style = ParagraphStyle('default')
+            p_style.leftIndent = 0
+            p_style.rightIndent = 0
+
+            list_styles=[ParagraphStyle('list%d' % n) for n in range(3)]
+            all_styles = list_styles[:]
+            all_styles.append(p_style)
+
+            direction='rtl'
+
+            for s in all_styles:
+                s.fontSize = 15
+                s.leading = s.fontSize*1.2
+                s.fontName = font_name
+                if direction=='rtl':
+                    s.wordWrap = 'RTL'
+                    s.alignment = TA_RIGHT
+                else:
+                    s.alignment = TA_JUSTIFY
+
+            indent_amount = 20
+
+            for list_lvl, list_style in enumerate(list_styles):
+                list_lvl += 1
+                list_style.bulletIndent = indent_amount*(list_lvl-1)
+
+                if direction=='rtl':
+                    list_style.rightIndent = indent_amount*list_lvl
+                else:
+                    list_style.leftIndent = indent_amount*list_lvl
+
+            elements =[]
+
+            TEXTS=[
+                    b'\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f, \xd7\x94\xd7\x95\xd7\x90 \xd7\x94\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x90\xd7\x97\xd7\xa8\xd7\x90\xd7\x99 \xd7\xa2\xd7\x9c \xd7\x9e\xd7\xa9\xd7\xa8\xd7\x93 \xd7\x96\xd7\x94. \xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93 \xd7\x96\xd7\x94 \xd7\xa0\xd7\x97\xd7\xa9\xd7\x91 \xd7\x9c\xd7\x90\xd7\x97\xd7\x93 \xd7\x94\xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93\xd7\x99\xd7\x9d \xd7\x94\xd7\x91\xd7\x9b\xd7\x99\xd7\xa8\xd7\x99\xd7\x9d \xd7\x91\xd7\x9e\xd7\x9e\xd7\xa9\xd7\x9c\xd7\x94. \xd7\x9c\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f \xd7\x9e\xd7\xaa\xd7\x9e\xd7\xa0\xd7\x94 \xd7\x9c\xd7\xa8\xd7\x95\xd7\x91 \xd7\x92\xd7\x9d \xd7\xa1\xd7\x92\xd7\x9f \xd7\xa9\xd7\xa8.',
+                    b'\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f, <b>\xd7\x94\xd7\x95\xd7\x90 \xd7\x94\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x90\xd7\x97\xd7\xa8\xd7\x90\xd7\x99 \xd7\xa2\xd7\x9c \xd7\x9e\xd7\xa9\xd7\xa8\xd7\x93 \xd7\x96\xd7\x94.</b> \xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93 \xd7\x96\xd7\x94 <i>\xd7\xa0\xd7\x97\xd7\xa9\xd7\x91 \xd7\x9c\xd7\x90\xd7\x97\xd7\x93</i> \xd7\x94\xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93\xd7\x99\xd7\x9d <b><i>\xd7\x94\xd7\x91\xd7\x9b\xd7\x99\xd7\xa8\xd7\x99\xd7\x9d \xd7\x91\xd7\x9e\xd7\x9e\xd7\xa9\xd7\x9c\xd7\x94</i></b>. \xd7\x9c\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f \xd7\x9e\xd7\xaa\xd7\x9e\xd7\xa0\xd7\x94 \xd7\x9c\xd7\xa8\xd7\x95\xd7\x91 \xd7\x92\xd7\x9d \xd7\xa1\xd7\x92\xd7\x9f \xd7\xa9\xd7\xa8.',
+                    u'<bullet>\u2022</bullet>\u05e9\u05e8 \u05d4\u05d1\u05d9\u05d8\u05d7\u05d5\u05df, <b>\u05d4\u05d5\u05d0 \u05d4\u05e9\u05e8 \u05d4\u05d0\u05d7\u05e8\u05d0\u05d9 \u05e2\u05dc \u05de\u05e9\u05e8\u05d3 \u05d6\u05d4.</b> \u05ea\u05e4\u05e7\u05d9\u05d3 \u05d6\u05d4 <i>\u05e0\u05d7\u05e9\u05d1 \u05dc\u05d0\u05d7\u05d3</i> \u05d4\u05ea\u05e4\u05e7\u05d9\u05d3\u05d9\u05dd <b><i>\u05d4\u05d1\u05db\u05d9\u05e8\u05d9\u05dd \u05d1\u05de\u05de\u05e9\u05dc\u05d4</i></b>. \u05dc\u05e9\u05e8\u05d4\u05d1\u05d9\u05d8\u05d7\u05d5\u05df \u05de\u05ea\u05de\u05e0\u05d4 \u05dc\u05e8\u05d5\u05d1 \u05d2\u05dd \u05e1\u05d2\u05df \u05e9\u05e8.',
+                    ]
+
+            # simple text in a paragraph
+            # working with patch from Hosam Aly
+            p = Paragraph(TEXTS[0], p_style)
+            elements.append(p)
+
+            elements.append(Spacer(0, 40))
+
+            # uses intra paragraph markup -> style text
+            p = Paragraph(TEXTS[1], p_style)
+            elements.append(p)
+            elements.append(Spacer(0, 40))
+
+            # list item (just a paragraph with a leading <bullet> element
+            for list_style in list_styles:
+                p = Paragraph(TEXTS[2], list_style)
+                elements.append(p)
+
+            doc.build(elements)
+
+        def testParsing(self):
+            fontName = getAFont()
+            fontNameBI = tt2ps(fontName,1,1)
+            stySTD = ParagraphStyle('STD',fontName=fontName)
+            styBI = ParagraphStyle('BI',fontName=fontNameBI)
+            self.assertRaises(ValueError,Paragraph,'aaaa <b><i>bibibi</b></i> ccccc',stySTD)
+            self.assertRaises(ValueError,Paragraph,'AAAA <b><i>BIBIBI</b></i> CCCCC',styBI)
 
 def makeSuite():
     return makeSuiteForClasses(ParagraphTestCase)
 
-
 #noruntests
 if __name__ == "__main__":
     unittest.TextTestRunner().run(makeSuite())
diff -uNr reportlab-3.1.8/tests/test_pdfgen_general.py reportlab-3.1.41/tests/test_pdfgen_general.py
--- reportlab-3.1.8/tests/test_pdfgen_general.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_pdfgen_general.py	2014-08-12 20:28:18.716110786 +0900
@@ -680,6 +680,11 @@
         gif = os.path.join(testsFolder,'pythonpowered.gif')
         c.drawInlineImage(gif,2*inch, 7*inch)
         c.drawInlineImage(os.path.join(testsFolder,'pythonpowered-gs.gif'),4*inch, 7.5*inch)
+        tif = os.path.join(testsFolder,'test-cross.tiff')   #example of a mode '1' image
+        c.drawInlineImage(tif,1*inch, 1*inch)
+        from reportlab.lib.utils import Image as PilImage
+        if PilImage:
+            c.drawInlineImage(PilImage.open(tif),1.25*inch, 1*inch)
     else:
         c.rect(2*inch, 7*inch, 110, 44)
         c.rect(4*inch, 7*inch, 110, 44)
@@ -715,6 +720,8 @@
     if haveImages:
         c.drawImage(gif, 1*inch, 1.2*inch, w, h, mask=myMask)
         c.drawImage(gif, 3*inch, 1.2*inch, w, h, mask='auto')
+        c.drawImage(os.path.join(testsFolder,'test-rgba.png'),5*inch,1.2*inch,width=10,height=10,mask='auto')
+        c.drawImage(os.path.join(testsFolder,'test-indexed.png'),5.5*inch,1.2*inch,width=10,height=10,mask='auto')
     else:
         c.rect(1*inch, 1.2*inch, w, h)
         c.rect(3*inch, 1.2*inch, w, h)
@@ -1055,11 +1062,17 @@
         self.assertRaises(ValueError,trySomeColors,cmyk+rgb+seps,'cmyk')
         trySomeColors(cmyk+['black']+seps,'cmyk')   #OK because black & seps are convertible
 
-    def test5(self):
+    def test5(self,uopw=None):
         from reportlab.lib.pagesizes import A4,LETTER
-        canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes.pdf'),
-                        pagesize=A4,
-                        )
+        if uopw:
+            from reportlab.lib import pdfencrypt
+            encrypt = pdfencrypt.StandardEncryption(uopw[0], uopw[1])
+            encrypt.setAllPermissions(0)
+            encrypt.canPrint = 1
+            canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes_encrypted.pdf'),pagesize=A4)
+            canv._doc.encrypt = encrypt
+        else:
+            canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes.pdf'),pagesize=A4)
         canv.setFont('Helvetica',10)
         S = A4
         canv.drawString(0,S[1]-10,'Top Left=(%s,%s) Page Size=%s x %s' % (0,S[1],S[0],S[1]))
@@ -1088,6 +1101,9 @@
         canv.showPage()
         canv.save()
 
+    def test6(self):
+        self.test5(('User','Password'))
+
     def testMultipleSavesOk(self):
         c=canvas.Canvas(outputfile('test_pdfgen_savetwice.pdf'))
         c.drawString(100, 700, 'Hello. This was saved twice')
diff -uNr reportlab-3.1.8/tests/test_platypus_general.py reportlab-3.1.41/tests/test_platypus_general.py
--- reportlab-3.1.8/tests/test_platypus_general.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_platypus_general.py	2014-08-12 20:28:18.719110784 +0900
@@ -560,7 +560,6 @@
 
 
 class PlatypusTestCase(unittest.TestCase):
-    "Make documents with lots of Platypus features"
 
     def test0(self):
         "Make a platypus document"
@@ -582,6 +581,16 @@
         doc = SimpleDocTemplate(outputfile('test_drawing_keepwithnext.pdf'))
         doc.build(story)
 
+    def test2(self):
+        '''ensure showBoundaryValue works as expected'''
+        from reportlab.platypus.frames import ShowBoundaryValue
+        assert (1 if ShowBoundaryValue(width=1) else 0) == 1
+        assert (1 if ShowBoundaryValue(color=None,width=1) else 0) == 0
+        assert (1 if ShowBoundaryValue(width=-1) else 0) == 0
+        assert bool(ShowBoundaryValue(width=1)) == True
+        assert bool(ShowBoundaryValue(color=None,width=1)) == False
+        assert bool(ShowBoundaryValue(width=-1)) == False
+
 def makeSuite():
     return makeSuiteForClasses(PlatypusTestCase)
 
diff -uNr reportlab-3.1.8/tests/test_platypus_paraparser.py reportlab-3.1.41/tests/test_platypus_paraparser.py
--- reportlab-3.1.8/tests/test_platypus_paraparser.py	2014-03-27 05:17:15.000000000 +0900
+++ reportlab-3.1.41/tests/test_platypus_paraparser.py	2014-08-12 20:28:18.702110797 +0900
@@ -104,6 +104,16 @@
         self.assertEquals([x.text for x in fragList], ['Hello ','',' World'])
         self.assertEquals(fragList[1].lineBreak, True)
 
+
+    def testRejectsBadlyFormed(self):
+        txt = "Hello <b>World"
+
+        def parseIt(txt, style=self.style):
+            fragList = ParaParser().parse(txt, self.style)[1]
+
+        self.assertRaises(ValueError, parseIt, txt)
+        
+
     #def testNakedAmpersands(self):
         #We no longer require this error to be raised when using html.parser
         # import pyRXPU
