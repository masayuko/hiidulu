diff -r f32cd7c4645a README.txt
--- a/README.txt	Tue Apr 22 12:43:10 2014 +0100
+++ b/README.txt	Fri May 23 11:13:03 2014 +0900
@@ -54,31 +54,25 @@
 
 2.1 General prerequisites
 --------------------------
-You need to have installed Python (versions 2.5 through 2.7),
-and ideally PIL with Freetype support; more notes on prerequisites
+You need to have installed Python (versions 2.7 or >=3.3),
+and ideally PIL or Pillow with Freetype support; more notes on prerequisites
 follow below.  
 
 2.2. Where to get the code
 ------------------------------------------
+Latest builds are available from ReportLab's
+open source download area::
 
-    
-Daily and release builds are available from ReportLab's
-open download area::
+    https://www.reportlab.com/pypi/
 
-    http://www.reportlab.org/ftp/
-
-Daily builds will unzip/untar to produce a dated directory e.g. 
-``reportlab-YYYYMMDD/`` but are otherwise structured just like the Mercurial
-repository and release builds.
-
-Releases are also available from the Python Package Index:
+Main releases are also available from the Python Package Index:
 
     http://pypi.python.org/
 
 From March 2013, the code is being hosted in Mercurial on BitBucket.
 You can obtain the latest code from our Mercurial repository with::
 
-    hg clone http://bitbucket.org/rptlab/reportlab
+    hg clone https://bitbucket.org/rptlab/reportlab
 
 
 Users of our commercial libraries, and/or anyone who registers on our site,
@@ -89,16 +83,20 @@
 
 
 
-2.3 Windows Installer
---------------------------
-A binary ``.exe`` installer for Windows (built with distutils) is
-available on our website.  This will install the 'reportlab' package
-into your site-packages area (e.g. ``C:\Python27\lib\site-packages``).
+2.3 Windows Packages
+--------------------
+We provide ``.whl`` files with compiled C extensions for all supported
+python versions at 
+
+    http://pypi.python.org/
+
+these may be installed using recent pip or other competent distribution
+package.
 
 This will NOT install the tests, examples and documentation.  If you want
 to learn your way around the package or do development with it on Windows,
-we suggest you also download a source copy, unzip it and work with the
-examples/tests within that directory.
+we suggest you also obtain source from https://bitbucket.org/rptlab/reportlab 
+and work with the examples/tests within that directory.
 
 2.4 Mac OS
 -------------
@@ -146,7 +144,7 @@
 going back to Python 1.5 or thereabouts.
 
 There are no absolute prerequisites beyond the Python
-standard library; but the Python Imaging Library (PIL)
+standard library; but the Python Imaging Library (PIL or Pillow)
 is needed to include images other than JPG inside PDF files.
 
 The C extension are optional but anyone able to do so should
diff -r f32cd7c4645a setup.py
--- a/setup.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/setup.py	Fri May 23 11:13:03 2014 +0900
@@ -522,7 +522,7 @@
             ext_modules =   EXT_MODULES,
             
             #this probably only works for setuptools, but distutils seems to ignore it
-            install_requires=['pillow ==2.0.0, >=2.4.0','pip>=1.4.1', 'setuptools>=2.2'],
+            install_requires=['pillow>=2.4.0','pip>=1.4.1', 'setuptools>=2.2'],
             )
         print()
         print('########## SUMMARY INFO #########')
diff -r f32cd7c4645a src/reportlab/__init__.py
--- a/src/reportlab/__init__.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/__init__.py	Fri May 23 11:13:03 2014 +0900
@@ -3,7 +3,7 @@
 #history http://www.reportlab.co.uk/cgi-bin/viewcvs.cgi/public/reportlab/trunk/reportlab/__init__.py
 __version__=''' $Id$ '''
 __doc__="""The Reportlab PDF generation library."""
-Version = "3.1.8"
+Version = "3.1.14"
 
 import sys, os, imp
 
diff -r f32cd7c4645a src/reportlab/lib/rl_accel.py
--- a/src/reportlab/lib/rl_accel.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/lib/rl_accel.py	Fri May 23 11:13:03 2014 +0900
@@ -16,9 +16,9 @@
         add32
         hex32
         '''.split()))
-import __main__
-testing = getattr(__main__,'_rl_testing',False)
-del __main__
+import reportlab
+testing = getattr(reportlab,'_rl_testing',False)
+del reportlab
 
 for fn in __all__:
     try:
diff -r f32cd7c4645a src/reportlab/lib/styles.py
--- a/src/reportlab/lib/styles.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/lib/styles.py	Fri May 23 11:13:03 2014 +0900
@@ -112,7 +112,10 @@
         #'bulletColor':black,
         'textColor': black,
         'backColor':None,
-        'wordWrap':None,
+        'wordWrap':None,        #None means do nothing special
+                                #CJK use Chinese Line breaking
+                                #LTR RTL use left to right / right to left
+                                #with support from pyfribi2 if available
         'borderWidth': 0,
         'borderPadding': 0,
         'borderColor': None,
diff -r f32cd7c4645a src/reportlab/lib/testutils.py
--- a/src/reportlab/lib/testutils.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/lib/testutils.py	Fri May 23 11:13:03 2014 +0900
@@ -1,8 +1,8 @@
 #Copyright ReportLab Europe Ltd. 2000-2013
 #see license.txt for license details
-import __main__
-__main__._rl_testing=True
-del __main__
+import reportlab
+reportlab._rl_testing=True
+del reportlab
 __version__='''$Id$'''
 __doc__="""Provides support for the test suite.
 
diff -r f32cd7c4645a src/reportlab/lib/utils.py
--- a/src/reportlab/lib/utils.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/lib/utils.py	Fri May 23 11:13:03 2014 +0900
@@ -608,24 +608,59 @@
         if 'b' not in mode and os.linesep!='\n': s = s.replace(os.linesep,'\n')
         return getBytesIO(s)
 
-try:
-    import urllib2
+if not isPy3:
+    import urllib2, urllib
     urlopen=urllib2.urlopen
-except ImportError:
-    import urllib.request
-    urlopen=urllib.request.urlopen
+    def datareader(url,opener=urllib.URLopener().open):
+        return opener(url).read()
+    del urllib, urllib2
+else:
+    from urllib.request import urlopen
+    from urllib.parse import unquote
+    import base64
+    #copied here from urllib.URLopener.open_data because
+    # 1) they want to remove it
+    # 2) the existing one is borken
+    def datareader(url, unquote=unquote, decodebytes=base64.decodebytes):
+        """Use "data" URL."""
+        # ignore POSTed data
+        #
+        # syntax of data URLs:
+        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
+        # mediatype := [ type "/" subtype ] *( ";" parameter )
+        # data      := *urlchar
+        # parameter := attribute "=" value
+        try:
+            typ, data = url.split(',', 1)
+        except ValueError:
+            raise IOError('data error', 'bad data URL')
+        if not typ:
+            typ = 'text/plain;charset=US-ASCII'
+        semi = typ.rfind(';')
+        if semi >= 0 and '=' not in typ[semi:]:
+            encoding = typ[semi+1:]
+            typ = typ[:semi]
+        else:
+            encoding = ''
+        if encoding == 'base64':
+            # XXX is this encoding/decoding ok?
+            data = decodebytes(data.encode('ascii'))
+        else:
+            data = unquote(data).encode('latin-1')
+        return data
+    del unquote, base64
 
-def open_for_read(name,mode='b', urlopen=urlopen):
+def open_for_read(name,mode='b', urlopen=urlopen, datareader=datareader):
     '''attempt to open a file or URL for reading'''
     if hasattr(name,'read'): return name
     try:
         return open_for_read_by_name(name,mode)
     except:
         try:
-            return getBytesIO(urlopen(name).read())
+            return getBytesIO(datareader(name) if name.startswith('data:') else urlopen(name).read())
         except:
             raise IOError('Cannot open resource "%s"' % name)
-del urlopen
+del urlopen, datareader
 
 def open_and_read(name,mode='b'):
     return open_for_read(name,mode).read()
@@ -823,7 +858,12 @@
                         im = im.convert('RGB')
                         self.mode = 'RGB'
                     elif mode not in ('L','RGB','CMYK'):
-                        im = im.convert('RGB')
+                        if im.format=='PNG' and im.mode=='P' and 'transparency' in im.info:
+                            im = im.convert('RGBA')
+                            self._dataA = ImageReader(im.split()[3])
+                            im = im.convert('RGB')
+                        else:
+                            im = im.convert('RGB')
                         self.mode = 'RGB'
                     if hasattr(im, 'tobytes'):  #make pillow and PIL both happy, for now
                         self._data = im.tobytes()
diff -r f32cd7c4645a src/reportlab/pdfgen/pdfimages.py
--- a/src/reportlab/pdfgen/pdfimages.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/pdfgen/pdfimages.py	Fri May 23 11:13:03 2014 +0900
@@ -123,7 +123,7 @@
 
         #use a flate filter and, optionally, Ascii Base 85 to compress
         raw = myimage.tostring()
-        rowstride = (imgwidth*bpc*bpp+7)/8
+        rowstride = (imgwidth*bpc*bpp+7)>>3
         assert len(raw) == rowstride*imgheight, "Wrong amount of data for image"
         data = zlib.compress(raw)    #this bit is very fast...
         if rl_config.useA85:
diff -r f32cd7c4645a src/reportlab/pdfgen/textobject.py
--- a/src/reportlab/pdfgen/textobject.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/pdfgen/textobject.py	Fri May 23 11:13:03 2014 +0900
@@ -15,6 +15,16 @@
 from reportlab.lib.utils import isBytes, isStr, asUnicode
 from reportlab.lib.rl_accel import fp_str
 from reportlab.pdfbase import pdfmetrics
+from reportlab.rl_config import rtlSupport
+
+log2vis = None
+if rtlSupport:
+    try:
+        from pyfribidi2 import log2vis, ON as DIR_ON, LTR as DIR_LTR, RTL as DIR_RTL
+        directionsMap = dict(LTR=DIR_LTR,RTL=DIR_RTL)
+    except:
+        import warnings
+        warnings.warn('pyfribidi is not installed - RTL not supported')
 
 class _PDFColorSetter:
     '''Abstracts the color setting operations; used in Canvas and Textobject
@@ -168,7 +178,7 @@
 
     It keeps track of x and y coordinates relative to its origin."""
 
-    def __init__(self, canvas, x=0,y=0):
+    def __init__(self, canvas, x=0,y=0, direction=None):
         self._code = ['BT']    #no point in [] then append RGB
         self._canvas = canvas  #canvas sets this so it has access to size info
         self._fontname = self._canvas._fontname
@@ -179,6 +189,7 @@
         self._enforceColorSpace = getattr(canvas,'_enforceColorSpace',None)
         font = pdfmetrics.getFont(self._fontname)
         self._curSubset = -1
+        self.direction = direction
         self.setTextOrigin(x, y)
         self._textRenderMode = 0
         self._clipping = 0
@@ -355,13 +366,16 @@
             self._code.append('%d Tr' % mode)
 
     def setRise(self, rise):
-        "Move text baseline up or down to allow superscrip/subscripts"
+        "Move text baseline up or down to allow superscript/subscripts"
         self._rise = rise
         self._y = self._y - rise    # + ?  _textLineMatrix?
         self._code.append('%s Ts' % fp_str(rise))
 
     def _formatText(self, text):
         "Generates PDF text output operator(s)"
+        if log2vis and self.direction in ('LTR','RTL'):
+            # Use pyfribidi to write the text in the correct visual order.
+            text = log2vis(text, directionsMap.get(self.direction.upper(),DIR_ON))
         canv = self._canvas
         font = pdfmetrics.getFont(self._fontname)
         R = []
diff -r f32cd7c4645a src/reportlab/platypus/frames.py
--- a/src/reportlab/platypus/frames.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/platypus/frames.py	Fri May 23 11:13:03 2014 +0900
@@ -11,7 +11,7 @@
 logger = logging.getLogger('reportlab.platypus')
 
 _geomAttr=('x1', 'y1', 'width', 'height', 'leftPadding', 'bottomPadding', 'rightPadding', 'topPadding')
-from reportlab import rl_config
+from reportlab import rl_config, isPy3
 _FUZZ=rl_config._FUZZ
 
 class ShowBoundaryValue:
@@ -19,8 +19,13 @@
         self.color = color
         self.width = width
 
-    def __bool__(self):
-        return self.color is not None and self.width>=0
+    if isPy3:
+        def __bool__(self):
+            return self.color is not None and self.width>=0
+    else:
+        def __nonzero__(self):
+            return self.color is not None and self.width>=0
+
 
 class Frame:
     '''
diff -r f32cd7c4645a src/reportlab/platypus/paragraph.py
--- a/src/reportlab/platypus/paragraph.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/platypus/paragraph.py	Fri May 23 11:13:03 2014 +0900
@@ -585,9 +585,16 @@
                 elif g.text[-1]!=' ': g.text += ' '
     return f
 
-def _drawBullet(canvas, offset, cur_y, bulletText, style):
+def _drawBullet(canvas, offset, cur_y, bulletText, style, rtl):
     '''draw a bullet text could be a simple string or a frag list'''
-    tx2 = canvas.beginText(style.bulletIndent, cur_y+getattr(style,"bulletOffsetY",0))
+    if not rtl:
+        tx2 = canvas.beginText(style.bulletIndent, cur_y+getattr(style,"bulletOffsetY",0))
+    else:
+        bt = bulletText[0].text
+        bulletWidth = stringWidth(bt, style.bulletFontName, style.bulletFontSize)
+        width = rtl[0]
+        bulletStart = width+style.rightIndent-(style.bulletIndent+bulletWidth)
+        tx2 = canvas.beginText(bulletStart, cur_y+getattr(style,"bulletOffsetY",0))
     tx2.setFont(style.bulletFontName, style.bulletFontSize)
     tx2.setFillColor(hasattr(style,'bulletColor') and style.bulletColor or style.textColor)
     if isinstance(bulletText,strTypes):
@@ -599,10 +606,11 @@
             tx2.textOut(f.text)
 
     canvas.drawText(tx2)
-    #AR making definition lists a bit less ugly
-    #bulletEnd = tx2.getX()
-    bulletEnd = tx2.getX() + style.bulletFontSize * 0.6
-    offset = max(offset,bulletEnd - style.leftIndent)
+    if not rtl:
+        #AR making definition lists a bit less ugly
+        #bulletEnd = tx2.getX()
+        bulletEnd = tx2.getX() + style.bulletFontSize * 0.6
+        offset = max(offset,bulletEnd - style.leftIndent)
     return offset
 
 def _handleBulletWidth(bulletText,style,maxWidths):
@@ -616,11 +624,14 @@
             bulletWidth = 0
             for f in bulletText:
                 bulletWidth = bulletWidth + stringWidth(f.text, f.fontName, f.fontSize)
-        bulletRight = style.bulletIndent + bulletWidth + 0.6 * style.bulletFontSize
-        indent = style.leftIndent+style.firstLineIndent
-        if bulletRight > indent:
+        bulletLen = style.bulletIndent + bulletWidth + 0.6 * style.bulletFontSize
+        if style.wordWrap=='RTL':
+            indent = style.rightIndent+style.firstLineIndent
+        else:
+            indent = style.leftIndent+style.firstLineIndent
+        if bulletLen > indent:
             #..then it overruns, and we have less space available on line 1
-            maxWidths[0] -= (bulletRight - indent)
+            maxWidths[0] -= (bulletLen - indent)
 
 def splitLines0(frags,widths):
     '''
@@ -1027,12 +1038,13 @@
         leftIndent = style.leftIndent
         first_line_width = availWidth - (leftIndent+style.firstLineIndent) - style.rightIndent
         later_widths = availWidth - leftIndent - style.rightIndent
+        self._wrapWidths = [first_line_width, later_widths]
 
         if style.wordWrap == 'CJK':
             #use Asian text wrap algorithm to break characters
-            blPara = self.breakLinesCJK([first_line_width, later_widths])
+            blPara = self.breakLinesCJK(self._wrapWidths)
         else:
-            blPara = self.breakLines([first_line_width, later_widths])
+            blPara = self.breakLines(self._wrapWidths)
         self.blPara = blPara
         autoLeading = getattr(self,'autoLeading',getattr(style,'autoLeading',''))
         leading = style.leading
@@ -1555,7 +1567,7 @@
                 else:
                     cur_y = self.height - getattr(f,'ascent',f.fontSize)
                 if bulletText:
-                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style)
+                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style,rtl=style.wordWrap=='RTL' and self._wrapWidths or False)
 
                 #set up the font etc.
                 canvas.setFillColor(f.textColor)
@@ -1566,6 +1578,9 @@
                 elif autoLeading=='min':
                     leading = blPara.ascent-blPara.descent
 
+                # set the paragraph direction
+                tx.direction = self.style.wordWrap
+
                 #now the font for the rest of the paragraph
                 tx.setFont(f.fontName, f.fontSize, leading)
                 ws = lines[0][0]
@@ -1609,6 +1624,9 @@
                     for i in range(1, nLines):
                         dpl( tx, _offsets[i], lines[i][0], lines[i][1], noJustifyLast and i==lim)
             else:
+                if self.style.wordWrap == 'RTL':
+                    for line in lines:
+                        line.words = line.words[::-1]
                 f = lines[0]
                 if rl_config.paraFontSizeHeightOffset:
                     cur_y = self.height - f.fontSize
@@ -1618,7 +1636,7 @@
                 dpl = _leftDrawParaLineX
                 if bulletText:
                     oo = offset
-                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style)
+                    offset = _drawBullet(canvas,offset,cur_y,bulletText,style, rtl=style.wordWrap=='RTL' and self._wrapWidths or False)
                 if alignment == TA_LEFT:
                     dpl = _leftDrawParaLineX
                 elif alignment == TA_CENTER:
@@ -1632,6 +1650,9 @@
 
                 #set up the font etc.
                 tx = self.beginText(cur_x, cur_y)
+                # set the paragraph direction
+                tx.direction = self.style.wordWrap
+
                 xs = tx.XtraState=ABag()
                 xs.textColor=None
                 xs.backColor=None
@@ -1659,7 +1680,7 @@
                 _do_post_text(tx)
 
                 #now the middle of the paragraph, aligned with the left margin which is our origin.
-                for i in range(1, nLines):
+                for i in xrange(1, nLines):
                     f = lines[i]
                     dpl( tx, _offsets[i], f, noJustifyLast and i==lim)
                     _do_post_text(tx)
diff -r f32cd7c4645a src/reportlab/platypus/paraparser.py
--- a/src/reportlab/platypus/paraparser.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/platypus/paraparser.py	Fri May 23 11:13:03 2014 +0900
@@ -596,52 +596,51 @@
 
     #### bold
     def start_b( self, attributes ):
-        self._push(bold=1)
+        self._push('b',bold=1)
 
     def end_b( self ):
-        self._pop(bold=1)
+        self._pop('b')
 
     def start_strong( self, attributes ):
-        self._push(bold=1)
+        self._push('strong',bold=1)
 
     def end_strong( self ):
-        self._pop(bold=1)
+        self._pop('strong')
 
     #### italics
     def start_i( self, attributes ):
-        self._push(italic=1)
+        self._push('i',italic=1)
 
     def end_i( self ):
-        self._pop(italic=1)
+        self._pop('i')
 
     def start_em( self, attributes ):
-        self._push(italic=1)
+        self._push('em', italic=1)
 
     def end_em( self ):
-        self._pop(italic=1)
+        self._pop('em')
 
     #### underline
     def start_u( self, attributes ):
-        self._push(underline=1)
+        self._push('u',underline=1)
 
     def end_u( self ):
-        self._pop(underline=1)
+        self._pop('u')
 
     #### strike
     def start_strike( self, attributes ):
-        self._push(strike=1)
+        self._push('strike',strike=1)
 
     def end_strike( self ):
-        self._pop(strike=1)
+        self._pop('strike')
 
     #### link
     def start_link(self, attributes):
-        self._push(**self.getAttributes(attributes,_linkAttrMap))
+        self._push('link',**self.getAttributes(attributes,_linkAttrMap))
 
     def end_link(self):
-        frag = self._stack[-1]
-        del self._stack[-1]
-        assert frag.link!=None
+        if self._pop('link').link is None:
+            raise ValueError('<link> has no target or href')
 
     #### anchor
     def start_a(self, attributes):
@@ -659,33 +658,35 @@
             href = A.get('href','').strip()
             A['link'] = href    #convert to our link form
             A.pop('href',None)
-        self._push(**A)
+        self._push('a',**A)
 
     def end_a(self):
         frag = self._stack[-1]
         sct = getattr(frag,'_selfClosingTag','')
         if sct:
-            assert sct=='anchor' and frag.name,'Parser failure in <a/>'
+            if not (sct=='anchor' and frag.name):
+                raise ValueError('Parser failure in <a/>')
             defn = frag.cbDefn = ABag()
             defn.label = defn.kind = 'anchor'
             defn.name = frag.name
             del frag.name, frag._selfClosingTag
             self.handle_data('')
-            self._pop()
+            self._pop('a')
         else:
-            del self._stack[-1]
-            assert frag.link!=None
+            if self._pop('a').link is None:
+                raise ValueError('<link> has no href')
 
     def start_img(self,attributes):
         A = self.getAttributes(attributes,_imgAttrMap)
         if not A.get('src'):
             self._syntax_error('<img> needs src attribute')
         A['_selfClosingTag'] = 'img'
-        self._push(**A)
+        self._push('img',**A)
 
     def end_img(self):
         frag = self._stack[-1]
-        assert getattr(frag,'_selfClosingTag',''),'Parser failure in <img/>'
+        if not getattr(frag,'_selfClosingTag',''):
+            raise ValueError('Parser failure in <img/>')
         defn = frag.cbDefn = ABag()
         defn.kind = 'img'
         defn.src = getattr(frag,'src',None)
@@ -696,24 +697,27 @@
         defn.valign = getattr(frag,'valign','bottom')
         del frag._selfClosingTag
         self.handle_data('')
-        self._pop()
+        self._pop('img')
 
     #### super script
     def start_super( self, attributes ):
-        self._push(super=1)
+        self._push('super',super=1)
 
     def end_super( self ):
-        self._pop(super=1)
+        self._pop('super')
 
-    start_sup = start_super
-    end_sup = end_super
+    def start_sup( self, attributes ):
+        self._push('sup',super=1)
+
+    def end_sup( self ):
+        self._pop('sup')
 
     #### sub script
     def start_sub( self, attributes ):
-        self._push(sub=1)
+        self._push('sub',sub=1)
 
     def end_sub( self ):
-        self._pop(sub=1)
+        self._pop('sub')
 
     #### greek script
     #### add symbol encoding
@@ -736,10 +740,10 @@
         self.errors.append(message)
 
     def start_greek(self, attr):
-        self._push(greek=1)
+        self._push('greek',greek=1)
 
     def end_greek(self):
-        self._pop(greek=1)
+        self._pop('greek')
 
     def start_unichar(self, attr):
         if 'name' in attr:
@@ -764,16 +768,16 @@
 
         if v is not None:
             self.handle_data(v)
-        self._push(_selfClosingTag='unichar')
+        self._push('unichar',_selfClosingTag='unichar')
 
     def end_unichar(self):
-        self._pop()
+        self._pop('unichar')
 
     def start_font(self,attr):
-        self._push(**self.getAttributes(attr,_fontAttrMap))
+        self._push('font',**self.getAttributes(attr,_fontAttrMap))
 
     def end_font(self):
-        self._pop()
+        self._pop('font')
 
     def start_span(self,attr):
         A = self.getAttributes(attr,_spanAttrMap)
@@ -786,20 +790,22 @@
                 D[k] = v
             D.update(A)
             A = D
-        self._push(**A)
+        self._push('span',**A)
 
-    end_span = end_font
+    def end_span(self):
+        self._pop('span')
 
     def start_br(self, attr):
-        self._push(_selfClosingTag='br',lineBreak=True,text='')
+        self._push('br',_selfClosingTag='br',lineBreak=True,text='')
         
     def end_br(self):
         #print('\nend_br called, %d frags in list' % len(self.fragList))
         frag = self._stack[-1]
-        assert frag._selfClosingTag=='br' and frag.lineBreak,'Parser failure in <br/>'
+        if not (frag._selfClosingTag=='br' and frag.lineBreak):
+                raise ValueError('Parser failure in <br/>')
         del frag._selfClosingTag
         self.handle_data('')
-        self._pop()
+        self._pop('br')
 
     def _initial_frag(self,attr,attrMap,bullet=0):
         style = self._style
@@ -828,10 +834,12 @@
         return frag
 
     def start_para(self,attr):
-        self._stack = [self._initial_frag(attr,_paraAttrMap)]
+        frag = self._initial_frag(attr,_paraAttrMap)
+        frag.__tag__ = 'para'
+        self._stack = [frag]
 
     def end_para(self):
-        self._pop()
+        self._pop('para')
 
     def start_bullet(self,attr):
         if hasattr(self,'bFragList'):
@@ -839,10 +847,11 @@
         self.bFragList = []
         frag = self._initial_frag(attr,_bulletAttrMap,1)
         frag.isBullet = 1
+        frag.__tag__ = 'bullet'
         self._stack.append(frag)
 
     def end_bullet(self):
-        self._pop()
+        self._pop('bullet')
 
     #---------------------------------------------------------------
     def start_seqdefault(self, attr):
@@ -938,9 +947,9 @@
 
         if 'label' in attr: defn.label = attr['label']
         defn.kind='onDraw'
-        self._push(cbDefn=defn)
+        self._push('ondraw',cbDefn=defn)
         self.handle_data('')
-        self._pop()
+        self._pop('ondraw')
     start_onDraw=start_ondraw 
     end_onDraw=end_ondraw=end_seq
 
@@ -967,9 +976,9 @@
         defn.label = encode_label((label,format,offset))
         defn.name = name
         defn.kind='index'
-        self._push(cbDefn=defn)
+        self._push('index',cbDefn=defn)
         self.handle_data('')
-        self._pop()
+        self._pop('index',)
     end_index=end_seq
 
     def start_unknown(self,attr):
@@ -977,17 +986,16 @@
     end_unknown=end_seq
 
     #---------------------------------------------------------------
-    def _push(self,**attr):
+    def _push(self,tag,**attr):
         frag = copy.copy(self._stack[-1])
+        frag.__tag__ = tag
         _applyAttributes(frag,attr)
         self._stack.append(frag)
 
-    def _pop(self,**kw):
-        frag = self._stack[-1]
-        del self._stack[-1]
-        for k, v in kw.items():
-            assert getattr(frag,k)==v
-        return frag
+    def _pop(self,tag):
+        frag = self._stack.pop()
+        if tag==frag.__tag__: return frag
+        raise ValueError('Parse error: saw </%s> instead of expected </%s>' % (tag,frag.__tag__))
 
     def getAttributes(self,attr,attrMap):
         A = {}
@@ -1148,7 +1156,7 @@
         try:
             self.feed(text)
         except:
-            annotateException('paragraph text %s caused exception' % ascii(text))
+            annotateException('\nparagraph text %s caused exception' % ascii(text))
         return self._complete_parse()
 
     def handle_starttag(self, tag, attrs):
diff -r f32cd7c4645a src/reportlab/rl_settings.py
--- a/src/reportlab/rl_settings.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/src/reportlab/rl_settings.py	Fri May 23 11:13:03 2014 +0900
@@ -43,6 +43,7 @@
 pdfMultiLine
 pdfComments
 debug
+rtlSupport
 T1SearchPath
 TTFSearchPath
 CMapSearchPath'''.split())
@@ -92,6 +93,7 @@
 pdfMultiLine=               0                       #use more lines in pdf etc
 pdfComments=                0                       #put in pdf comments
 debug=                      0                       #for debugging code
+rtlSupport=                 0                       #set to 1 to attempt import of RTL assistance eg fribidi etc etc
 
 # places to look for T1Font information
 T1SearchPath =  (
@@ -114,6 +116,7 @@
                 '/usr/local/Acrobat6/Resource/Font',    #Linux, Acrobat 5?
                 '/usr/local/Acrobat5/Resource/Font',    #Linux, Acrobat 5?
                 '/usr/local/Acrobat4/Resource/Font',    #Linux, Acrobat 4
+                '/usr/share/fonts/default/Type1',       #Linux, Fedora
                 '%(REPORTLAB_DIR)s/fonts',              #special
                 '%(REPORTLAB_DIR)s/../fonts',           #special
                 '%(REPORTLAB_DIR)s/../../fonts',        #special
@@ -130,6 +133,8 @@
                 'c:/windows/fonts',
                 '/usr/lib/X11/fonts/TrueType/',
                 '/usr/share/fonts/truetype',
+                '/usr/share/fonts',             #Linux, Fedora
+                '/usr/share/fonts/dejavu',      #Linux, Fedora
                 '%(REPORTLAB_DIR)s/fonts',      #special
                 '%(REPORTLAB_DIR)s/../fonts',   #special
                 '%(REPORTLAB_DIR)s/../../fonts',#special
diff -r f32cd7c4645a tests/test-cross.tiff
Binary file tests/test-cross.tiff has changed
diff -r f32cd7c4645a tests/test-indexed.png
Binary file tests/test-indexed.png has changed
diff -r f32cd7c4645a tests/test-rgba.png
Binary file tests/test-rgba.png has changed
diff -r f32cd7c4645a tests/test_lib_utils.py
--- a/tests/test_lib_utils.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/tests/test_lib_utils.py	Fri May 23 11:13:03 2014 +0900
@@ -122,6 +122,15 @@
         b = getBytesIO(_rel_open_and_read('../docs/images/Edit_Prefs.gif'))
         b = open_and_read(b)
 
+    def test11(self):
+        "test open and read of an RFC 2397 data URI with base64 encoding"
+        result = _rel_open_and_read('data:image/gif;base64,R0lGODdhAQABAIAAAP///////ywAAAAAAQABAAACAkQBADs=')
+        self.assertEquals(result,b'GIF87a\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\xff\xff\xff,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;')
+
+    def test12(self):
+        "test open and read of an RFC 2397 data URI without an encoding"
+        result = _rel_open_and_read('data:text/plain;,Hello%20World')
+        self.assertEquals(result,b'Hello World')
 
     def testRecursiveImportErrors(self):
         "check we get useful error messages"
diff -r f32cd7c4645a tests/test_paragraphs.py
--- a/tests/test_paragraphs.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/tests/test_paragraphs.py	Fri May 23 11:13:03 2014 +0900
@@ -5,14 +5,17 @@
 from reportlab.lib.testutils import setOutDir,makeSuiteForClasses, outputfile, printLocation
 setOutDir(__name__)
 import unittest
-from reportlab.platypus import Paragraph, SimpleDocTemplate, XBox, Indenter, XPreformatted, PageBreak
+from reportlab.platypus import Paragraph, SimpleDocTemplate, XBox, Indenter, XPreformatted, PageBreak, Spacer
 from reportlab.lib.styles import ParagraphStyle
 from reportlab.lib.units import inch
 from reportlab.lib.abag import ABag
 from reportlab.lib.colors import red, black, navy, white, green
 from reportlab.lib.randomtext import randomText
 from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
-from reportlab.rl_config import defaultPageSize
+from reportlab.rl_config import defaultPageSize, rtlSupport
+from reportlab.pdfbase import ttfonts
+from reportlab.pdfbase import pdfmetrics
+from reportlab.lib.fonts import addMapping, tt2ps
 
 (PAGE_WIDTH, PAGE_HEIGHT) = defaultPageSize
 
@@ -27,7 +30,6 @@
     canvas.drawString(4 * inch, 0.75 * inch, "First Page")
     canvas.restoreState()
 
-
 def myLaterPages(canvas, doc):
     canvas.saveState()
     canvas.setStrokeColor(red)
@@ -37,6 +39,33 @@
     canvas.drawString(4 * inch, 0.75 * inch, "Page %d" % doc.page)
     canvas.restoreState()
 
+def getAFont():
+    '''register a font that supports most Unicode characters'''
+    I = []
+    font_name = 'DejaVuSans'
+    I.append([(font_name, 0, 0, font_name),
+                 (font_name, 1, 0, font_name + '-Bold'),
+                 (font_name, 0, 1, font_name + '-Oblique'),
+                 (font_name, 1, 1, font_name + '-BoldOblique'),
+                 ])
+    font_name = 'FreeSerif'
+    I.append([(font_name, 0, 0, font_name),
+                 (font_name, 1, 0, font_name + 'Bold'),
+                 (font_name, 0, 1, font_name + 'Italic'),
+                 (font_name, 1, 1, font_name + 'BoldItalic'),
+                 ])
+    for info in I:
+        n = 0
+        for font in info:
+            fontName = font[3]
+            try:
+                pdfmetrics.registerFont(ttfonts.TTFont(fontName,fontName + '.ttf'))
+                addMapping(*font)
+                n += 1
+            except:
+                pass
+        if n==4: return font[0]
+    raise ValueError('could not find suitable font')
 
 class ParagraphTestCase(unittest.TestCase):
     "Test Paragraph class (eyeball-test)."
@@ -92,7 +121,6 @@
                                    spaceBefore=12,
                                    spaceAfter=12)
 
-
         SA(Paragraph("This is a normal paragraph. "+ randomText(), styNormal))
         SA(Paragraph("There follows a paragraph with only \"&lt;br/&gt;\"", styNormal))
         SA(Paragraph("<br/>", styNormal))
@@ -215,12 +243,192 @@
                                      showBoundary=1)
         template.build(story,
             onFirstPage=myFirstPage, onLaterPages=myLaterPages)
+    
+    if rtlSupport:
+        def testBidi(self):
+            fontName = getAFont()
 
+            # create styles based on the registered font
+            stySTD = ParagraphStyle('STD', fontName = fontName)
+            styRJ = ParagraphStyle('RJ', parent=stySTD, alignment=TA_RIGHT)
+            styLTR = ParagraphStyle('LTR', parent=stySTD, wordWrap='LTR')
+            styRTL = ParagraphStyle('RTL', parent = stySTD, alignment = TA_RIGHT,
+                                    wordWrap = 'RTL', spaceAfter = 12)
+
+            # strings for testing Normal & LTR styles
+            ltrStrings = [# English followed by Arabic.
+                          b'English followed by \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a.',
+                          # English with Arabic in the middle
+                          b'English with \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a in the middle.',
+                          # English symbols (!@#$%^&*) Arabic
+                          b'English symbols (!@#$%^&*) \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a.',
+                          # ((testing integers in LTR)) 
+                          b'123 LTR 123 Integers 123.',
+                          # ((testing decimals in LTR))
+                          b'456.78 LTR 456.78 Decimals 456.78.',
+                          # Long English text with RTL script in the middle, splitting over multiple lines
+                          b'Long \xd8\xb7\xd9\x88\xd9\x8a\xd9\x84 English text'
+                              b' \xd9\x86\xd8\xb5 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a with RTL script'
+                              b' \xd9\x83\xd8\xaa\xd8\xa7\xd8\xa8\xd8\xa9 \xd9\x85\xd9\x86'
+                              b' \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86 \xd8\xa5\xd9\x84\xd9\x89'
+                              b' \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1 in the middle,'
+                              b' \xd9\x81\xd9\x8a \xd8\xa7\xd9\x84\xd9\x88\xd8\xb3\xd8\xb7\xd8\x8c'
+                              b' splitting \xd9\x85\xd9\x82\xd8\xb3\xd9\x85 over \xd8\xb9\xd9\x84\xd9\x89'
+                              b' multiple lines \xd8\xb9\xd8\xaf\xd8\xa9 \xd8\xb3\xd8\xb7\xd9\x88\xd8\xb1.',
+                          ]
+
+            # strings for testing RTL
+            rtlStrings = [# Arabic followed by English
+                          b'\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd9\x85\xd8\xaa\xd8\xa8\xd9\x88\xd8\xb9'
+                              b' \xd8\xa8\xd9\x80 English.',
+                          # Arabic with English in the middle
+                          b'\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd9\x85\xd8\xb9 English \xd9\x81\xd9\x8a'
+                              b' \xd8\xa7\xd9\x84\xd9\x85\xd9\x86\xd8\xaa\xd8\xb5\xd9\x81.',
+                          # Arabic symbols (!@##$%^&*) English
+                          b'\xd8\xb1\xd9\x85\xd9\x88\xd8\xb2 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9'
+                              b' (!@#$%^&*) English.',
+                          # 123 from right to left 123 integer numbers 123. ((testing integers in RTL))
+                          b'123 \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' 123 \xd8\xa3\xd8\xb1\xd9\x82\xd8\xa7\xd9\x85'
+                              b' \xd8\xb5\xd8\xad\xd9\x8a\xd8\xad\xd8\xa9 123.',
+                          # 456.78 from right to left 456.78 decimal numbers 456.78. ((testing decimals in RTL))
+                          b'456.78 \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' 456.78 \xd8\xa3\xd8\xb1\xd9\x82\xd8\xa7\xd9\x85'
+                              b' \xd8\xb9\xd8\xb4\xd8\xb1\xd9\x8a\xd8\xa9 456.78.',
+                          # Long Arabic text with LTR text in the middle, splitting over multiple lines
+                          b'\xd9\x86\xd8\xb5 \xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a \xd8\xb7\xd9\x88\xd9\x8a\xd9\x84'
+                              b' Long Arabic text \xd9\x85\xd8\xb9 with \xd9\x83\xd8\xaa\xd8\xa7\xd8\xa8\xd8\xa9'
+                              b' \xd9\x85\xd9\x86 \xd8\xa7\xd9\x84\xd9\x8a\xd8\xb3\xd8\xa7\xd8\xb1'
+                              b' \xd8\xa5\xd9\x84\xd9\x89 \xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x8a\xd9\x86'
+                              b' LTR script \xd9\x81\xd9\x8a \xd8\xa7\xd9\x84\xd9\x88\xd8\xb3\xd8\xb7\xd8\x8c'
+                              b' in the middle, \xd9\x85\xd9\x82\xd8\xb3\xd9\x85 splitted'
+                              b' \xd8\xb9\xd9\x84\xd9\x89 over \xd8\xb9\xd8\xaf\xd8\xa9'
+                              b' \xd8\xb3\xd8\xb7\xd9\x88\xd8\xb1 multiple lines.'
+                          ]
+
+            assert len(ltrStrings) == len(rtlStrings)
+            n = len(ltrStrings)
+            
+            # create a store to be printed
+            story = []
+            
+            story.append(Paragraph("<b><i>Following pairs of left justified texts have style.wordWrap=None &amp; 'LTR'.</i></b><br/>",stySTD))
+            # write every LTR string and its corresponding RTL string to be matched.
+            for i in xrange(n):
+                story.append(Paragraph(ltrStrings[i], stySTD))
+                story.append(Paragraph(ltrStrings[i], styLTR))
+
+            story.append(Paragraph("<br/><b><i>Following pairs of right justfied texts have style.wordWrap=None &amp; 'RTL'.</i></b><br/>",stySTD))
+            for i in xrange(n):
+                story.append(Paragraph(rtlStrings[i], styRJ))
+                story.append(Paragraph(rtlStrings[i], styRTL))
+
+            story.append(Paragraph("<b><i><br/>Following texts have style.wordWrap='RTL'</i></b>",stySTD))
+            # a few additional scripts for testing.
+            story.append(
+                Paragraph(b'\xd9\x87\xd8\xb0\xd9\x87 \xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd8\xb9\xd8\xa7\xd8\xaf\xd9\x8a\xd8\xa9. ', styRTL))
+            story.append(
+                Paragraph(b'\xd9\x87\xd8\xb0\xd9\x87 \xd8\xa7\xd9\x84\xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd9\x84\xd8\xaf\xd9\x8a\xd9\x87\xd8\xa7 12'
+                              b' \xd9\x86\xd9\x82\xd8\xb7\xd8\xa9 \xd9\x82\xd8\xa8\xd9\x84\xd9\x87\xd8\xa7'
+                              b' \xd9\x88\xd8\xa8\xd8\xb9\xd8\xaf\xd9\x87\xd8\xa7. ', styRTL))
+            story.append(
+                Paragraph(b'<para spacebefore="12" spaceafter="12">'
+                              b'\xd9\x87\xd8\xb0\xd9\x87 \xd8\xa7\xd9\x84\xd9\x81\xd9\x82\xd8\xb1\xd8\xa9'
+                              b' \xd9\x84\xd8\xaf\xd9\x8a\xd9\x87\xd8\xa7 12 \xd9\x86\xd9\x82\xd8\xb7\xd8\xa9'
+                              b' \xd9\x82\xd8\xa8\xd9\x84\xd9\x87\xd8\xa7'
+                              b' \xd9\x88\xd8\xa8\xd8\xb9\xd8\xaf\xd9\x87\xd8\xa7\xd8\x8c'
+                              b' \xd9\x85\xd8\xad\xd8\xaf\xd8\xaf\xd8\xa9 \xd8\xa8\xd9\x80 XML.'
+                              b' \xd8\xa5\xd9\x86\xd9\x87\xd8\xa7 \xd8\xaa\xd8\xb9\xd9\x85\xd9\x84'
+                              b' \xd8\xa3\xd9\x8a\xd8\xb6\xd8\xa7! \xd9\x80.'
+                              b'</para>',
+                          styRTL))
+
+            # TODO: add more RTL scripts to the test (Farsi, Hebrew, etc.)
+
+            template = SimpleDocTemplate(outputfile('test_paragraphs_bidi.pdf'))
+            template.build(story)
+
+        def testRTLBullets(self):
+            try:
+                import mwlib.ext
+            except ImportError:
+                pass
+
+            font_name = getAFont()
+            doc = SimpleDocTemplate(outputfile('test_rtl_bullets.pdf'),showBoundary=True)
+            p_style = ParagraphStyle('default')
+            p_style.leftIndent = 0
+            p_style.rightIndent = 0
+
+            list_styles=[ParagraphStyle('list%d' % n) for n in range(3)]
+            all_styles = list_styles[:]
+            all_styles.append(p_style)
+
+            direction='rtl'
+
+            for s in all_styles:
+                s.fontSize = 15
+                s.leading = s.fontSize*1.2
+                s.fontName = font_name
+                if direction=='rtl':
+                    s.wordWrap = 'RTL'
+                    s.alignment = TA_RIGHT
+                else:
+                    s.alignment = TA_JUSTIFY
+
+            indent_amount = 20
+
+            for list_lvl, list_style in enumerate(list_styles):
+                list_lvl += 1
+                list_style.bulletIndent = indent_amount*(list_lvl-1)
+
+                if direction=='rtl':
+                    list_style.rightIndent = indent_amount*list_lvl
+                else:
+                    list_style.leftIndent = indent_amount*list_lvl
+
+            elements =[]
+
+            TEXTS=[
+                    b'\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f, \xd7\x94\xd7\x95\xd7\x90 \xd7\x94\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x90\xd7\x97\xd7\xa8\xd7\x90\xd7\x99 \xd7\xa2\xd7\x9c \xd7\x9e\xd7\xa9\xd7\xa8\xd7\x93 \xd7\x96\xd7\x94. \xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93 \xd7\x96\xd7\x94 \xd7\xa0\xd7\x97\xd7\xa9\xd7\x91 \xd7\x9c\xd7\x90\xd7\x97\xd7\x93 \xd7\x94\xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93\xd7\x99\xd7\x9d \xd7\x94\xd7\x91\xd7\x9b\xd7\x99\xd7\xa8\xd7\x99\xd7\x9d \xd7\x91\xd7\x9e\xd7\x9e\xd7\xa9\xd7\x9c\xd7\x94. \xd7\x9c\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f \xd7\x9e\xd7\xaa\xd7\x9e\xd7\xa0\xd7\x94 \xd7\x9c\xd7\xa8\xd7\x95\xd7\x91 \xd7\x92\xd7\x9d \xd7\xa1\xd7\x92\xd7\x9f \xd7\xa9\xd7\xa8.',
+                    b'\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f, <b>\xd7\x94\xd7\x95\xd7\x90 \xd7\x94\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x90\xd7\x97\xd7\xa8\xd7\x90\xd7\x99 \xd7\xa2\xd7\x9c \xd7\x9e\xd7\xa9\xd7\xa8\xd7\x93 \xd7\x96\xd7\x94.</b> \xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93 \xd7\x96\xd7\x94 <i>\xd7\xa0\xd7\x97\xd7\xa9\xd7\x91 \xd7\x9c\xd7\x90\xd7\x97\xd7\x93</i> \xd7\x94\xd7\xaa\xd7\xa4\xd7\xa7\xd7\x99\xd7\x93\xd7\x99\xd7\x9d <b><i>\xd7\x94\xd7\x91\xd7\x9b\xd7\x99\xd7\xa8\xd7\x99\xd7\x9d \xd7\x91\xd7\x9e\xd7\x9e\xd7\xa9\xd7\x9c\xd7\x94</i></b>. \xd7\x9c\xd7\xa9\xd7\xa8 \xd7\x94\xd7\x91\xd7\x99\xd7\x98\xd7\x97\xd7\x95\xd7\x9f \xd7\x9e\xd7\xaa\xd7\x9e\xd7\xa0\xd7\x94 \xd7\x9c\xd7\xa8\xd7\x95\xd7\x91 \xd7\x92\xd7\x9d \xd7\xa1\xd7\x92\xd7\x9f \xd7\xa9\xd7\xa8.',
+                    u'<bullet>\u2022</bullet>\u05e9\u05e8 \u05d4\u05d1\u05d9\u05d8\u05d7\u05d5\u05df, <b>\u05d4\u05d5\u05d0 \u05d4\u05e9\u05e8 \u05d4\u05d0\u05d7\u05e8\u05d0\u05d9 \u05e2\u05dc \u05de\u05e9\u05e8\u05d3 \u05d6\u05d4.</b> \u05ea\u05e4\u05e7\u05d9\u05d3 \u05d6\u05d4 <i>\u05e0\u05d7\u05e9\u05d1 \u05dc\u05d0\u05d7\u05d3</i> \u05d4\u05ea\u05e4\u05e7\u05d9\u05d3\u05d9\u05dd <b><i>\u05d4\u05d1\u05db\u05d9\u05e8\u05d9\u05dd \u05d1\u05de\u05de\u05e9\u05dc\u05d4</i></b>. \u05dc\u05e9\u05e8\u05d4\u05d1\u05d9\u05d8\u05d7\u05d5\u05df \u05de\u05ea\u05de\u05e0\u05d4 \u05dc\u05e8\u05d5\u05d1 \u05d2\u05dd \u05e1\u05d2\u05df \u05e9\u05e8.',
+                    ]
+
+            # simple text in a paragraph
+            # working with patch from Hosam Aly
+            p = Paragraph(TEXTS[0], p_style)
+            elements.append(p)
+
+            elements.append(Spacer(0, 40))
+
+            # uses intra paragraph markup -> style text
+            p = Paragraph(TEXTS[1], p_style)
+            elements.append(p)
+            elements.append(Spacer(0, 40))
+
+            # list item (just a paragraph with a leading <bullet> element
+            for list_style in list_styles:
+                p = Paragraph(TEXTS[2], list_style)
+                elements.append(p)
+
+            doc.build(elements)
+
+        def testParsing(self):
+            fontName = getAFont()
+            fontNameBI = tt2ps(fontName,1,1)
+            stySTD = ParagraphStyle('STD',fontName=fontName)
+            styBI = ParagraphStyle('BI',fontName=fontNameBI)
+            self.assertRaises(ValueError,Paragraph,'aaaa <b><i>bibibi</b></i> ccccc',stySTD)
+            self.assertRaises(ValueError,Paragraph,'AAAA <b><i>BIBIBI</b></i> CCCCC',styBI)
 
 def makeSuite():
     return makeSuiteForClasses(ParagraphTestCase)
 
-
 #noruntests
 if __name__ == "__main__":
     unittest.TextTestRunner().run(makeSuite())
diff -r f32cd7c4645a tests/test_pdfgen_general.py
--- a/tests/test_pdfgen_general.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/tests/test_pdfgen_general.py	Fri May 23 11:13:03 2014 +0900
@@ -680,6 +680,11 @@
         gif = os.path.join(testsFolder,'pythonpowered.gif')
         c.drawInlineImage(gif,2*inch, 7*inch)
         c.drawInlineImage(os.path.join(testsFolder,'pythonpowered-gs.gif'),4*inch, 7.5*inch)
+        tif = os.path.join(testsFolder,'test-cross.tiff')   #example of a mode '1' image
+        c.drawInlineImage(tif,1*inch, 1*inch)
+        from reportlab.lib.utils import Image as PilImage
+        if PilImage:
+            c.drawInlineImage(PilImage.open(tif),1.25*inch, 1*inch)
     else:
         c.rect(2*inch, 7*inch, 110, 44)
         c.rect(4*inch, 7*inch, 110, 44)
@@ -715,6 +720,8 @@
     if haveImages:
         c.drawImage(gif, 1*inch, 1.2*inch, w, h, mask=myMask)
         c.drawImage(gif, 3*inch, 1.2*inch, w, h, mask='auto')
+        c.drawImage(os.path.join(testsFolder,'test-rgba.png'),5*inch,1.2*inch,width=10,height=10,mask='auto')
+        c.drawImage(os.path.join(testsFolder,'test-indexed.png'),5.5*inch,1.2*inch,width=10,height=10,mask='auto')
     else:
         c.rect(1*inch, 1.2*inch, w, h)
         c.rect(3*inch, 1.2*inch, w, h)
@@ -1055,11 +1062,17 @@
         self.assertRaises(ValueError,trySomeColors,cmyk+rgb+seps,'cmyk')
         trySomeColors(cmyk+['black']+seps,'cmyk')   #OK because black & seps are convertible
 
-    def test5(self):
+    def test5(self,uopw=None):
         from reportlab.lib.pagesizes import A4,LETTER
-        canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes.pdf'),
-                        pagesize=A4,
-                        )
+        if uopw:
+            from reportlab.lib import pdfencrypt
+            encrypt = pdfencrypt.StandardEncryption(uopw[0], uopw[1])
+            encrypt.setAllPermissions(0)
+            encrypt.canPrint = 1
+            canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes_encrypted.pdf'),pagesize=A4)
+            canv._doc.encrypt = encrypt
+        else:
+            canv = canvas.Canvas(outputfile('test_pdfgen_general_page_sizes.pdf'),pagesize=A4)
         canv.setFont('Helvetica',10)
         S = A4
         canv.drawString(0,S[1]-10,'Top Left=(%s,%s) Page Size=%s x %s' % (0,S[1],S[0],S[1]))
@@ -1088,6 +1101,9 @@
         canv.showPage()
         canv.save()
 
+    def test6(self):
+        self.test5(('User','Password'))
+
     def testMultipleSavesOk(self):
         c=canvas.Canvas(outputfile('test_pdfgen_savetwice.pdf'))
         c.drawString(100, 700, 'Hello. This was saved twice')
diff -r f32cd7c4645a tests/test_platypus_general.py
--- a/tests/test_platypus_general.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/tests/test_platypus_general.py	Fri May 23 11:13:03 2014 +0900
@@ -560,7 +560,6 @@
 
 
 class PlatypusTestCase(unittest.TestCase):
-    "Make documents with lots of Platypus features"
 
     def test0(self):
         "Make a platypus document"
@@ -582,6 +581,16 @@
         doc = SimpleDocTemplate(outputfile('test_drawing_keepwithnext.pdf'))
         doc.build(story)
 
+    def test2(self):
+        '''ensure showBoundaryValue works as expected'''
+        from reportlab.platypus.frames import ShowBoundaryValue
+        assert (1 if ShowBoundaryValue(width=1) else 0) == 1
+        assert (1 if ShowBoundaryValue(color=None,width=1) else 0) == 0
+        assert (1 if ShowBoundaryValue(width=-1) else 0) == 0
+        assert bool(ShowBoundaryValue(width=1)) == True
+        assert bool(ShowBoundaryValue(color=None,width=1)) == False
+        assert bool(ShowBoundaryValue(width=-1)) == False
+
 def makeSuite():
     return makeSuiteForClasses(PlatypusTestCase)
 
diff -r f32cd7c4645a tests/test_platypus_paraparser.py
--- a/tests/test_platypus_paraparser.py	Tue Apr 22 12:43:10 2014 +0100
+++ b/tests/test_platypus_paraparser.py	Fri May 23 11:13:03 2014 +0900
@@ -104,6 +104,16 @@
         self.assertEquals([x.text for x in fragList], ['Hello ','',' World'])
         self.assertEquals(fragList[1].lineBreak, True)
 
+
+    def testRejectsBadlyFormed(self):
+        txt = "Hello <b>World"
+
+        def parseIt(txt, style=self.style):
+            fragList = ParaParser().parse(txt, self.style)[1]
+
+        self.assertRaises(ValueError, parseIt, txt)
+        
+
     #def testNakedAmpersands(self):
         #We no longer require this error to be raised when using html.parser
         # import pyRXPU
